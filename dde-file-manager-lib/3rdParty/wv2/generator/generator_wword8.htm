<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.77 [en] (X11; U; Linux 2.4.3-20mdk i686) [Netscape]">
   <title>Microsoft Word 97 Binary File Format</title>
</head>
<body>
<tt>/*</tt>
<br><tt>Copyright (C) 2000, 2001, S.R.Haque.</tt>
<p><tt>This file is a modified version of the original document published
by Microsoft. Copies of the original are available at various places including:</tt>
<p><tt>http://www.wotsit.org/download.asp?f=wword8</tt>
<p><tt>It has had its formatting regularised to facilitate automated extract
of the structure definitions contained within it. It also contains:</tt>
<ul><tt>-some corrections for "obvious" mistakes in the original.</tt><tt></tt>
<p><tt>-rationalisation of the types used in the structure definitions
to use unsigned variables as the basic type.</tt><tt></tt>
<p><tt>-signed types might need adding back in specific instances that
I missed.</tt><tt></tt>
<p><tt>-rationalisation of the way bitfields are described.</tt></ul>
<tt>MODIFICATION HISTORY</tt>
<p><tt>23-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Merge Werner's changes.</tt>
<br><tt>19-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Reconciled with Word
95 spec.</tt>
<br><tt>17-Jul-2001 shaheedhaque&nbsp;&nbsp;&nbsp; Reorder alphabetically
to ease comparison.</tt>
<br><tt>7-Jul-2001&nbsp; shaheedhaque&nbsp;&nbsp;&nbsp; Tweak to make consistent
with Word95 doc.</tt>
<br><tt>25-Sep-2000 shaheedhaque&nbsp;&nbsp;&nbsp; Rework the handling
of PICF to make it parseable, add OBJHEADER</tt>
<br><tt>10-Aug-2000 shaheedhaque&nbsp;&nbsp;&nbsp; Minor corrections.</tt>
<br><tt>20-Jul-2000 shaheedhaque&nbsp;&nbsp;&nbsp; First released.</tt>
<br><tt>&nbsp;*/</tt>
<h1>
Microsoft Word 97 Binary File Format</h1>
Microsoft Word 97 (aka Version 8) for Windows and Macintosh. From the Office
book, found in the Microsoft Office Development section in the <a href="http://premium.microsoft.com/msdn/library/">MSDN
Online Library</a>. HTMLified June 1998. Revised Aug 1 1998, added missing
Definitions section. Revised Dec 21 1998, added missing Document Properties
(section).
<h2>
Contents</h2>

<ul>
<li>
<a href="#01">Note</a></li>

<li>
<a href="#02">Word and Docfiles</a></li>

<li>
<a href="#defin">Definitions</a></li>

<li>
<a href="#03">Naming Conventions</a></li>

<li>
<a href="#04">Format of the Summary Info Stream in a Word File</a></li>

<li>
<a href="#05">Format of the Main Stream in a Word Non-Complex File</a></li>

<li>
<a href="#06">Format of the Main Stream in a Complex File</a></li>

<li>
<a href="#07">Format of the Table Stream</a></li>

<li>
<a href="#08">Format of the Data Stream</a></li>

<li>
<a href="#09">FIB</a></li>

<li>
<a href="#10">Text</a></li>

<li>
<a href="#11">Character and Paragraph Formatting Properties</a></li>

<li>
<a href="#12">Bin Tables</a></li>

<li>
<a href="#13">Stylesheet</a></li>

<ul>
<li>
<a href="#14">STSHI</a></li>

<li>
<a href="#15">STD</a></li>
</ul>

<li>
<a href="#16">List Tables</a></li>

<ul>
<li>
<a href="#17">LST records and the rglst</a></li>

<li>
<a href="#18">List Names and the sttbListNames</a></li>

<li>
<a href="#19">LFO records and the pllfo</a></li>

<li>
<a href="#20">Paragraph List Formatting</a></li>
</ul>

<li>
<a href="#21">SPRM Definitions</a></li>

<li>
<a href="#22">Complex File Format</a></li>

<ul>
<li>
<a href="#23">Algorithm to determine the bounds of a paragraph containing
a certain character in a complex file</a></li>

<li>
<a href="#24">Algorithm to determine paragraph properties for a paragraph
in a complex file</a></li>

<li>
<a href="#25">Algorithm to determine table properties for a table row in
a complex file</a></li>

<li>
<a href="#26">Algorithm to determine the character properties of a character
in a complex file</a></li>

<li>
<a href="#27">Algorithm to determine the section properties of a section
in a complex file</a></li>

<li>
<a href="#28">Algorithm to determine the pic of a picture in a complex
file.</a></li>
</ul>

<li>
<a href="#29">Footnotes &amp; Endnotes</a></li>

<li>
<a href="#30">Headers and Footers</a></li>

<li>
<a href="#31">Page Table</a></li>

<li>
<a href="#32">Glossary Files</a></li>

<li>
<a href="#33">Routing Slip</a></li>

<li>
<a href="#34">Autosummary</a></li>

<li>
<a href="#35">STTBFASSOC (Table of Associated Strings)</a></li>

<li>
<a href="#36">Structure Definitions</a></li>

<ul>
<li>
<a href="#37">Autonumbered List Data Descriptor (ANLD)</a></li>

<li>
<a href="#38">AnnoTation Reference Descriptor (ATRD)</a></li>

<li>
<a href="#39">Autonumber Level Descriptor (ANLV)</a></li>

<li>
<a href="#40">AutoSummary Analysis (ASUMY)</a></li>

<li>
<a href="#41">AutoSummary Info (ASUMYI)</a></li>

<li>
<a href="#42">Bin Table Entry (BTE)</a></li>

<li>
<a href="#43">BreaK Descriptor (BKD)</a></li>

<li>
<a href="#44">BooKmark First descriptor (BKF)</a></li>

<li>
<a href="#45">BooKmark Lim descriptor (BKL)</a></li>

<li>
<a href="#46">Border Code (BRC)</a></li>

<li>
<a href="#47">Border Code for Windows Word 1.0 (BRC10)</a></li>

<li>
<a href="#48">Character Properties (CHP)</a></li>

<li>
<a href="#49">Character Property Exceptions (CHPX)</a></li>

<li>
<a href="#50">Date and Time (internal date format) (DTTM)</a></li>

<li>
<a href="#51">Drop Cap Specifier(DCS)</a></li>

<li>
<a href="#52">Drawing Object Grid (DOGRID)</a></li>

<li>
<a href="#52a">Document Properties (DOP)</a></li>

<li>
<a href="#53">Document Typography Info (DOPTYPOGRAPHY)</a></li>

<li>
<a href="#54">Field Descriptor (FLD)</a></li>

<li>
<a href="#55">File Shape Address (FSPA)</a></li>

<li>
<a href="#56">Font Family Name (FFN)</a></li>

<li>
<a href="#57">File Information Block (FIB)</a></li>

<li>
<a href="#58">Footnote Reference Descriptor (FRD)</a></li>

<li>
<a href="#59">Formatted Disk Page for CHPXs (CHPX FKP)</a></li>

<li>
<a href="#60">Formatted Disk Page for PAPXs (PAPX FKP)</a></li>

<li>
<a href="#61">List LeVeL (on File) (LVLF)</a></li>

<li>
<a href="#62">Line Spacing Descriptor (LSPD)</a></li>

<li>
<a href="#63">LiST Data (on File) (LSTF)</a></li>

<li>
<a href="#64">List Format Override (LFO)</a></li>

<li>
<a href="#65">List Format Override for a single LeVeL (LFOLVL)</a></li>

<li>
<a href="#66">Outline LiST Data (OLST)</a></li>

<li>
<a href="#METAFILEPICT">METAFILEPICT</a></li>

<li>
<a href="#67">Number Revision Mark Data (NUMRM)</a></li>

<li>
<a href="#_OBJHEADER">Embedded Object properties (OBJHEADER)</a></li>

<li>
<a href="#68">Page Descriptor (PGD)</a></li>

<li>
<a href="#69">Paragraph Height (PHE)</a></li>

<li>
<a href="#70">Paragraph Properties (PAP)</a></li>

<li>
<a href="#71">Paragraph Property Exceptions (PAPX)</a></li>

<li>
<a href="#72">Picture Descriptor (on File) (PICF)</a></li>

<li>
<a href="#73">Piece Descriptor (PCD)</a></li>

<li>
<a href="#74">Plex of CPs stored in File (PLCF)</a></li>

<li>
<a href="#75">Property Modifier(variant 1) (PRM)</a></li>

<li>
<a href="#76">Property Modifier(variant 2) (PRM)</a></li>

<li>
<a href="#77">Routing Slip (RS)</a></li>

<li>
<a href="#78">Routing Recipient (RR)</a></li>

<li>
<a href="#79">Section Descriptor (SED)</a></li>

<li>
<a href="#80">Section Properties (SEP)</a></li>

<li>
<a href="#81">Section Property Exceptions (SEPX)</a></li>

<li>
<a href="#82">Shading Descriptor (SHD)</a></li>

<li>
<a href="#83">Tab Descriptor (TBD)</a></li>

<li>
<a href="#84">Table Cell Descriptors (TC)</a></li>

<li>
<a href="#85">Table Autoformat Look sPecifier (TLP)</a></li>

<li>
<a href="#86">Table Properties (TAP)</a></li>

<li>
<a href="#87">TeXtBoX Story (FTXBXS)</a></li>

<li>
<a href="#88">WorK Book (WKB)</a></li>
</ul>

<li>
<a href="#89">Appendix A - Reading a Macintosh PICT Graphic</a></li>

<li>
<a href="#90">Appendix B - Calculation of font (FTC) and language (LID)</a></li>
</ul>
<a NAME="01"></a>
<h2>
Note</h2>
Many of the structures written in Word files differ slightly from the corresponding
structures Word uses internally. The file-specific version of a structure
is typically named by adding a preceding or (more often) trailing F. For
example, Word uses internally a PLC (PLex of Cps), but writes to files
a PLCF (PLex of Cps in File). Many discussions in this document use the
name of the internal structure when the file-specific structure is what
is really being referred to. The reader should remember that the name of
a seemingly undefined structure type may simply be missing a leading or
trailing F.
<br><a NAME="02"></a>
<h2>
Word and Docfiles</h2>
Word 97 is an OLE 2.0 application. A Word binary file is a docfile and
Word binary data is written into streams within the docfile using the OLE
2.0 docfile APIs. These streams are stored in the file as linked lists
of file blocks and this data cannot be reliably accessed by using the operating
system Open APIs. To access data within a Word binary file, the file must
be opened using the OLE 2.0 docfile APIs, and it must be read with the
appropriate docfile APIs.
<p>A word docfile consists of a main stream, a summary information stream,
a table stream, a data stream, and 0 or more object streams which contain
private data for OLE 2.0 objects embedded within the Word document. The
summary information stream is described in the section immediately following
this one. The object storages contain binary data for embedded objects.
Word has no knowledge of the contents of these storages; this information
is accessed and manipulated though the OLE 2.0 APIs.
<p>The majority of this document describes the contents of the main stream
and the table stream.
<br><a NAME="defin"></a>
<h2>
Definitions</h2>
<b>OLE 2.0:</b>
<p>Object Linking and Embedding 2.0
<p>API (Application Programming Interface):
<p>A set of libraries, functions, definitions, etc. which describe an interface
to a programming environment or model.
<p><b>docfile:</b>
<p>An OLE 2.0 compatible multi-stream file. Word files are docfiles.
<p><b>page (or sector):</b>
<p>512 byte segment of the main stream within a Word docfile that begins
on a 512-byte boundary. (bytes 0-511 are in page 0, bytes 512-1023 are
in page 1, etc.). In Word data structures, an unsigned two-byte integer
page number is given the acronym <b>PN </b>(for <b>P</b>age <b>N</b>umber).
<p><b>document:</b>
<p>A named, multi-linked list of data structures, representing an ordered
stream of text with properties that was produced by a user of Microsoft
Word
<p><b>stream:</b>
<p>The physical encoding of a Word document 's text and sub data structures
in a random access stream within a docfile.
<p><b>main stream:</b>
<p>The stream within a Word docfile containing the bulk of Word's binary
data.
<p><b>table stream:</b>
<p>The stream within a Word docfile containing the various plcf's and tables
that describe a documents structures.
<p><b>data stream:</b>
<p>The stream within a Word docfile containing various data that hang off
of characters in the main stream. For example, binary data describing in-line
pictures and/or formfields.
<p><b>summary information stream:</b>
<p>The stream within a Word docfile containing the document summary information.
<p><b>object storage:</b>
<p>A storage containing binary data for an embedded OLE 2.0 object.
<p><b>CP (Character Position):</b>
<p>A four-byte integer which is the position coordinate of a character
of text within the logical text stream of a document.
<p><b>FC( File Character position):</b>
<p>A four-byte integer which is the byte offset of a character (or other
object) from the beginning of a stream of the docfile. Before a file has
been edited(i.e. in a full saved Word document), CPs<b> </b>can be transformed
into <b>FC</b>s by adding the <b>FC</b> coordinate of the beginning of
a document's text stream to the CP. After a file has been edited (i.e.
in a fast-saved Word document), the mapping from <b>CP</b> to <b>FC</b>
is recorded in the <b>piece table </b>(see below)
<p><b>XCHAR( eXtended CHARacter set):</b>
<p>A data type which defines a "character". Each XCHAR corresponds to a
character in the document, where "character" is defined as a glyph, regardless
of whether it is a single-byte or double-byte character. With Word6/FE,
Word95/FE, Word97/all and future versions of Word, this is defined as a
16-bit integer corresponding to the Unicode character code of the glyph.
<p><b>PLF(PLex stored in File):</b>
<p>A data structure consisting of an array of structures preceded by a
long count of structures.
<p><b>PLCF(PLex of Cps(or FCs) stored in File):</b>
<p>A data structure consisting of two parallel arrays that allows a relation
to be established between a certain <b>CP</b> position in the document
text stream (or <b>FC</b> position in a file) and an arbitrary data structure.
It consists of an array of <b>n+1 CP</b>s or <b>FC</b>s followed by an
array of <b>n</b> instances of a particular arbitrary data structure. In
typical usage, the <b>nth CP </b>or<b> FC</b> of the <b>PLCF</b> is in
one-to-one correspondence with the <b>nth </b>instance<b> </b>of the arbitrary
data structure, with the <b>n+1st</b> <b>CP </b>or<b> FC</b> marking the
limit of the <b>nth</b> instance's influence. When a <b>PLCF</b> is used
to record a partitioning of the document's text stream or a partitioning
of the bytes stored in a file, the 0th <b>CP/FC </b>stored in the <b>PLCF</b>
will be 0. When a <b>PLCF </b>is used to record the location of certain
marks or links within the document text stream, the 0th <b>CP/FC</b> stored
in the <b>PLCF </b>will record the position of the 0th mark or link. To
properly interpret a <b>PLCF</b> stored in a Word file, the length of the
stored <b>PLCF</b> and the length of the arbitrary data structure stored
in the <b>PLCF </b>must be known<b>. </b>The length of the stored <b>PLCF</b>
is recorded in the <b>FIB. </b>The lengths of the data structures stored
in <b>PLCF</b>s within Word files are listed later in this document.
<p><b>piece table:</b>
<p>The <b>piece table </b>is a data structure that describes the logical
sequence of characters in a Word document and records recent changes to
the formatting of a Word document. It is stored in a Word file as a <b>PLCF</b>
named the <b>plcfpcd</b> (<b>PL</b>ex of <b>C</b>ps containing <b>P</b>ie<b>c</b>e
<b>D</b>escriptors).The
piece table relates a logical character number, called a <b>CP </b>(<b>C</b>haracter
<b>P</b>osition),
to a physical location within a Word file (an <b>FC</b>). The array of
<b>CP</b>s
in the <b>plcfpcd</b> defines a partitioning of the Word document into
disjoint pieces. The second array is an array of
<b>PCD</b>s (<b>P</b>ie<b>c</b>e
<b>D</b>escriptors)
which is in 1-to-1 correspondence to the array of <b>CP</b>s that records
the physical location in the Word file where the corresponding piece begins.
To find the physical location of a particular logical character in aWord
document, take the
<b>CP</b> coordinate of that character within the document
and find the piece that contains that character. This is done by finding
the index of the largest<b> CP </b>in the array of <b>CP</b>s that is less
than the character <b>CP</b>. Then<b> </b>reference the <b>PCD</b> with
that index in the array of <b>PCD</b>s. The <b>FC</b> stored in the
<b>PCD
</b>gives
the position of the beginning of the piece in the file. Finally, add the
offset of the desired character from the beginning of its piece to the
<b>FC</b>
of the beginning of the piece. This gives a "virtual" file offset of the
character. If the second most significant bit is clear, then this indicates
the actual file offset of the unicode character (two bytes). If the second
most significant bit is set, then the actual address of the codepage-1252
compressed version of the unicode character (one byte), is actually at
the offset indicated by clearing this bit and dividing by two.
<p><b>sprm (Single PRoperty Modifier):</b>
<p>An instruction to modify one or more properties within one of the property
defining data structures (<b>CHP</b>, <b>PAP</b>, <b>TAP</b>, <b>SEP, or
PIC</b>). It consists of an operation code which identifies the field(s)
to be changed, and an<b> </b>operand which gives the value that a particular
field is changed to or else which is a parameter to a procedure which will
change the field or fields. A <b>prl</b> (<b>pr</b>operty modifiers stored
in a <b>l</b>ist) is a <b>sprm</b> plus its operand.
<p><b>grpprl (group of prls):</b>
<p>A grpprl is a data structure that records a set of<b> sprm</b>s. The
0th <b>sprm</b> is recorded at offset 0 of the structure. Any succeeding
<b>sprm</b>s
are recorded immediately after the end of the preceding <b>sprm</b> . To
traverse a <b>grpprl</b> and locate the <b>sprms</b> recorded within it,
it's necessary to fetch the opcode of the first <b>sprm</b>, lookup the
length of the <b>sprm</b> with that opcode, use that length to skip past
the first <b>sprm</b>, fetch the opcode of the second <b>sprm</b>, lookup
the length of that <b>sprm</b>, use the length to skip the second
<b>sprm</b>,
and so on. See the table in the "<b>SPRM Definition</b>" topic to determine
the length of a <b>sprm</b>.
<p>The phrase "<b>apply the sprms of a grpprl</b> (or <b>papx</b> or <b>sepx)</b>"
used later in this document means to fetch the 0th <b>sprm </b>recorded
in the <b>grpprl</b> and perform the action for that sprm, fetch the first
<b>sprm</b>
and perform its action, and continue this procedure until all
<b>sprms</b>
in the <b>grpprl</b> (or <b>papx</b> or <b>sepx) </b>have been processed.
<p><b>prm (PRoperty Modifier):</b>
<p>A field in piece table entries that records how the properties of text
within a piece were changed to reflect user formatting operations. The
<b>prm</b>
usually contains an index to a <b>grpprl</b> which records the user's formatting
changes as a group of <b>sprm</b>s. If the user has made only a small change
to formatting that can be expressed as a single 2 or 1-byte <b>sprm</b>,
that <b>sprm </b>is stored within the <b>prm</b>.
<p><b>STTBF (STring TaBle stored in File)</b>
<p>Word has many tables of strings that are stored as Pascal type strings.
STTBFs consist of an optional short containing 0xFFFF, indicating that
the strings are extended character strings, a short indicating how many
strings are included in the string table, another short indicating the
size in bytes of the extra data stored with each string and each string
followed by the extra data. Non-extended charater Pascal strings begin
with a single byte length count which describes how many characters follow
the length byte in the string. If pst is a pointer to an array of characters
storing a Pascal style string then the length of the string is *pst+1.
In an STTBF Pascal style strings are concatenated one after another until
the length of the STTBF recorded in the FIB is exhausted.<b> </b>Extra
data associated with a string may also be stored in an sttbf.<b> </b>When
extra data is stored for an STTBF, it is written at the end of each string.
For example:<b> </b>The extra data for an STTBF consists of a short.If
the string "Cat" were stored, the actual entry in the string table would
consist of a length byte containing 3 (3 for "Cat") followed by the bytes
'C' 'a' 't', followed by the 2 bytes containing the short. Extended character
strings are stored just the same, except they have a double byte length
count and each extended character occupies two bytes.
<p><b>full-saved (or non-complex) file:</b>
<p>A Word file in which the physical order of characters stored in the
file is identical to the logical order of characters in the document that
the file represents. The text stream of a non-complex file can be described
by an <b>fc</b> (an offset from the beginning of the file) to mark where
the text begins and a <b>ccp </b>(<b>c</b>ount of <b>CP</b>s) to record
how many characters are stored in the text stream. Due to unicode compression
to code page 1252, all files (simple and complex) now contain a piece table.
However, a full-saved piece table will not have property modifiers (prms)
and all text in the file will be referenced by the piece table.
<p><b>fast-saved (or complex) file:</b>
<p>A Word file in which the physical order of characters stored in the
file does not match the logical order of characters in the document that
the file represents. A <b>piece table</b> must be stored in the file to
describe the text stream of the document. Due to unicode compression to
code page 1252, all files (simple and complex) now contain a piece table.
<p><b>FIB (File Information Block):</b>
<p>The header of a Word file. Begins at offset 0 in file. Gives the beginning
offset<b> </b>and lengths of the document's text stream and subsidiary
data structures within the file. Also stores other file status information.
<p><b>paragraph</b>
<p>A contiguous sequence of characters within the text stream of a document
that is delimited by a paragraph mark, cell mark, row mark, or a section
mark (These are special characters described later in this document).
<p><b>run of text</b>
<p>A contiguous sequence of characters within the text stream of a document
that have the same character formatting properties. A single run may cross
paragraph boundaries and may encompass the entire document.
<p><b>section</b>
<p>A contiguous sequence of paragraphs within the text stream of a document
that is delimited by a section mark or by the final paragraph mark at the
end of a document. Users frequently treat sections as the equivalent of
a chapter in a book. The boundaries of sections mark locations where the
layout rules for a document (number of columns, text of headers and footers
to use, whether page numbers should be displayed, etc.) are changed.
<p><b>paragraph style</b>
<p>A named set of character and paragraph properties that can be associated
with any number of <b>paragraphs</b> in a Word document's text stream.
A <b>paragraph</b> <b>style</b> provides a set of character and paragraph
property defaults for the text of any paragraph tagged with that style.
When a new paragraph is created and given a particular style, newly typed
text is given the character and paragraph properties of that style unless
the user makes an exception to the paragraph style definition by performing
other editing operations.
<p><b>CHP (CHaracter Properties)</b>
<p>The data structure describing the character properties of a run of text.
<p><b>CHPX (Character Property EXception)</b>
<p>A data structure which describes how a particular <b>CHP</b> differs
from a reference <b>CHP</b>. In Win Word 6.0, the <b>CHPX</b> simply consists
of a <b>grpprl</b> which is applied to the reference <b>CHP</b> to produce
the originally encoded <b>CHP</b>. By applying a <b>CHPX </b>to the character
properties (<b>CHP)</b> inherited by a particular paragraph from its <b>style</b>,it
is possible to reconstitute the <b>CHP </b>for the portion of the character
run that intersects that paragraph
<p><b>character style</b>
<p>A named character property exception that can be associated with any
number of runs of text in a Word document's text stream. When a run of
text is tagged with a particular <b>character style</b>, a <b>chpx</b>
recorded for the character style is applied to the character properties
that are defined for the paragraph style of the paragraph that contains
the text. This means that the character style can change one or more of
the character property field settings specified by the paragraph style
of a paragraph to a particular setting without changing the value of any
other field.
<p><b>PAP (PAragraph Properties)</b>
<p>The data structure which describes the properties of a particular paragraph.
<p><b>PAPX (PAragraph Property EXception)</b>
<p>A data structure describing how a particular paragraph's properties
differ from the paragraph properties of the style assigned to the paragraph.
By applying a <b>PAPX</b> to the paragraph properties (<b>PAP</b>) inherited
by a particular paragraph from its <b>style</b>, it is possible to reconstitute
the <b>PAP</b> for that paragraph. The <b>PAPX</b> contains an <b>ISTD
</b>(a
style code to identify the style in control of the paragraph and a <b>grpprl</b>
which specifies how the style's paragraph properties must be changed to
produce the paragraph properties of the paragraph.
<p><b>table row:</b>
<p>A contiguous sequence of paragraphs within the text stream of a document
that is partitioned into subsequences of paragraphs called <b>cells.</b>
The last paragraph of each cell is terminated by a special paragraph mark
called a <b>cell mark.</b> Following the cell mark that ends the last cell
of a table row, the table row is terminated by a special paragraph mark
called a <b>row mark</b>. When Word displays a table row, it assigns a
rectangular shaped display area to each cell in the row. All of the cell
display area's top's are aligned at the same vertical position on a page.
The leftmost display area in a table row is assigned to the 0th cell of
the row; the next display area to the right is assigned to the 1st cell
of the row, etc. The text of the cell is wrapped to fit its display area.As
more text is added to the cell, the cell display area extends downward.
A set of table properties that determine how many cells are in a row, where
the horizontal boundaries of cell display areas are, and what borders are
drawn around each cell in the table is stored for the <b>row mark </b>that
marks the end of the table row.
<p><b>TAP (TAble Properties):</b>
<p>The data structure which describes the properties of a single table
row. The information in the <b>TAP</b> for a table row is stored in a Word
file as a list of sprms that modify a <b>TAP </b>which has been cleared
to zeros. This list of table sprms is appended to the <b>grpprl</b> of
paragraph sprms that is recorded in the <b>PAPX</b> for the <b>row mark</b>
that delimits the end of a <b>table row</b>.
<p><b>STSH (STyle SHeet)</b>
<p>A data structure which represents every style defined within the Word
document. The <b>STSH</b> records a unique name string for every style
and associates each name with a particular <b>CHP</b> and/or a <b>PAP.
</b>The
indexes used to refer to individual styles are called <b>ISTD</b>s (<b>I</b>ndexes to<b>
ST</b>yle<b> D</b>escriptors). Every <b>PAPX
</b>for every paragraph recorded
in a document<b> </b>contains an <b>ISTD
</b>which identifies the style
from which a paragraph inherited its default character and paragraph properties.
<b>CHPX</b>s
recorded for the text within the paragraph and
<b>PAPX</b>s recorded for
the paragraph itself encode changes that the user has made with respect
to the style's default properties.
<p><b>FKP (Formatted disK Page):</b>
<p>A data structure that fits in one 512-byte page that encodes either
the character properties or the paragraph properties of a certain portion
of a Microsoft Word file. An <b>FKP </b>consists of four components:
<p>1) a count of the number of runs or paragraphs described by the page.
<p>2) an array of <b>FC</b>s recorded in ascending order demarcating the
boundaries between runs or paragraphs that are recorded adjacent to one
another in the Word file.
<p>3) In <b>character FKP</b>s an array of offsets within the <b>FKP </b>in
one to one correspondence with the array of <b>FC</b>s that locate the
properties of the run that begins at a particular <b>FC.</b>
<p>In <b>LVC FKP</b>s an array of offsets within the FKP in one to one
correspondence with the array of FCs that locate the LVCXs that describe
the run that begins at a particular FC.
<p>In <b>paragraph FKP</b>s an array of <b>BX </b>structures follows the
array of <b>FC</b>s in one to one correspondence with the array of <b>FC</b>s.
Each <b>BX</b> begins with an offset that locates the properties of the
paragraph that begins at a particular FC. The remainder of the <b>BX</b>
contains a <b>PHE </b>structure that encodes information about the height
of the paragraph that begins at that <b>FC</b>.
<p>4) a group of <b>CHPX</b>s if the <b>FKP</b> stores character properties,
a group of <b>PAPX</b>s if the <b>FKP</b> stores paragraph<b> </b>and table
properties, or a group of LVCXs if the FKP stores paragraph level and numbering
cache information
<p>To find the <b>CHPX</b>/<b>PAPX</b> corresponding to a particular character
in a document, calculate the <b>FC</b> coordinate for that character. Then
search through the <b>bin table</b> (see next entry)<b> </b>for the type
of property you want to produce, to find the <b>FKP</b> in the document
stream whose array of <b>FC</b>s encompasses the <b>FC</b> of the documentcharacter.
<p>Then search within the <b>FKP</b> to find the index of the largest <b>FC
</b>entry
that is less than or equal to the <b>FC</b> of the document character.
Use this index to look up an offset in the array of offsets (for <b>character
FKPs</b>) or look up an offset in the array of <b>Bx</b>s (for <b>paragraph
FKPs</b>) within the <b>FKP</b>. Add this offset to the beginning address
of the <b>FKP </b>in memory. This will be the first byte of the desired<b>CHPX</b>/<b>PAPX.</b>
<p><b>bin table</b>
<p>Each <b>FKP</b> can be viewed as bucket or <b>bin</b> that contains
the properties of a certain range of <b>FC</b>s in the Word file. In Word
files, a <b>PLC</b>,<b> </b>the <b>plcfbte </b>(<b>PL</b>ex of F<b>C</b>s
containing <b>B</b>in <b>T</b>able <b>E</b>ntries) is maintained. Itrecords
the association between a particular range of <b>FC</b>s and the <b>PN
</b>(<b>P</b>age
<b>N</b>umber)
of the <b>FKP </b>that contains the properties for that
<b>FC</b> range
in the file. In a <b>complex (fast-saved)</b> Word document,<b> FKP </b>pages
are intermingled with pages of textin a random pattern which reflects the
history of past fast saves. In a complex document, a <b>plcfbteChpx</b>
which records the location of every <b>CHPX FKP</b> must be stored and
a <b>plcfbtePapx</b> which records the location of every <b>PAPX FKP </b>must
be stored<b>. </b>In a <b>non-complex, full-saved</b> document, all of
the <b>CHPX FKPS </b>are recorded in consecutive 512-byte pages with the
<b>FKP</b>s
recorded in ascending <b>FC </b>order, as are all of the <b>PAPX FKPS</b>.
A plcfbteLvcx serves the same purpose for LVCX FKPS.
<p>In a full save document, the plcfbte's may not have been able to be
expanded during the save process due to a lack of RAM. In that situation,
the plcfbte's will be interspersed with the property pages in a linked
list of FBD pages.
<p><b>SEP(SEction Properties)</b>
<p>The data structure describing the properties of a particular section.
<p><b>SEPX(SEction Property EXceptions)</b>
<p>A data structure describing how the properties of a particular section
differ from a Word-defined standard <b>SEP</b>. As in the <b>PAPX</b>,
the differences between the <b>SEP</b> for a section and the standard <b>SEP</b>
are encoded as list of sprms that describe how the standard <b>SEP</b>
can be transformed into the section's <b>SEP</b>.<b> </b>By applying a
<b>SEPX</b>'s
sprms to the standard <b>SEP</b>, it is possible to reconstitute the <b>SEP</b>
for that section.
<p>The PLCFSED, a data structure stored in a Word file, records the locations
of all SEPXs stored in a Word file. The array of CPs in the plcfsed records
the boundaries of sections in the Word document . The second array in the
plcf, an array of SEDs (SEction Descriptors), is in 1-to-1 correspondence
to the array of CPs. Each SED stores the beginning FC of the SEPX that
records the properties for a section. If the FC stored in a SED is -1,
the section properties of the section are exactly equal to the standard
section properties.
<p>The SEP for a particular section may be constructed if a CP of a character
in that section is known. First search the array of CPs in the PLCSED for
the index of the largest CP that is less than or equal to the CP of the
character. Use this index to locate the SED in the plcfsed which describes
the section. The FC stored in the SED is the offset from the beginning
of the Word file at which the SEPX is stored. If the stored FC is equal
to 0xFFFFFFFF, then the SEP for the section is exactly equal to the standard
SEP (see SEP structure definition) Otherwise, read the SEPX into memory
and create a copy of the standard SEP. Finally, apply the sprms stored
in the SEPX to the standard SEP to produce the SEP for a section.
<p><b>DOP (DOcument Properties)</b>
<p>The data structure describing properties that apply to the document
as a whole.
<p><b>sub-document</b>
<p>A separate logical stream of text with properties for which correspondences
with the main document text are maintained. Word's headers/footers, footnotes,
endnotes,<b> </b>macro procedure text, annotation text, and text within
textboxes are kept in separate subdocuments. Each subdocument has its own
CP coordinate space. In other words, data structures are stored in Word
files that are components of these subdocuments. These data structures
contain CP coordinates whose 0 point is the beginning of the subdocument
text stream instead of the beginning of the main document text stream.
<p>In<b> full-saved documents</b>, a simple calculation with values stored
in the <b>FIB </b>produces<b> </b>the file offset of the beginning of the
subdocument text streams (if they exist). The length of these streams is
also stored.
<p>In <b>fast-saved documents</b>, the <b>piece tables</b> of subdocuments
are concatenated to the end of the main document piece table. In this case,
to identify the beginning of subdocument text , you must sum the length
of the main document text stream with the lengths of any subdocument text
streams stored ahead of the subdocument (information stored in the <b>FIB</b>)
and treat this sum as a <b>CP</b> coordinate. To retrieve the text of the
subdocument, you must do lookups in the piece table, starting with the
piece that contains the beginning <b>CP</b> coordinate, to find the physical
location of each piece of the subdocument text stream.
<p><b>field</b>
<p>A field is a two-part structure that may be recorded in the CP stream
of a document. The first part of the structure contains <b>field codes</b>
which instruct Window's Word to insert text into the second part of the
structure, the <b>field result</b>. Fields in Window's Word are used to
insert text from an external file or to quote another part of a document,
to mark index and table of contents entries and produce indexes and tables
of contents, maintain DDE links to other programs, to produce dates, times,
page numbers, sequence numbers, etc. There are 91 different field types.
<p>A <b>field begin mark</b> delimits the beginning of a field and precedes
any of the field codes stored in the field. The end of the field codes
and the beginning of the field result is marked with the <b>field separator</b>
and the field result and the field itself are terminated by a <b>field
end mark.</b>
<p>The CP locations of the field begin mark, field separator, and field
end mark are recorded in <b>plcfld</b> data structures that are maintained
for the main document and all of the subdocuments of the main document
whenever a field is inserted or edited. A field can be <b>dead</b>, in
which case it has no field separator, no field result, and no entry in
the <b>plcfld</b>. (See the definition of the FLD structure for a list
of possible dead field code strings.) An array of two-byte <b>FLD</b> structures
is stored in the <b>plcfld</b> in one-to-one correspondence with the CP
entries recorded. An <b>FLD</b> associated with a <b>field begin mark</b>
records the type of the field. An <b>FLD</b> associated with the <b>field
end mark</b> records the current status of the field (i.e. whether the
result is dirty or has been edited, whether the result has been locked,
etc.)
<p>Fields may be nested. 20 levels of nesting are permitted.
<p><b>bookmark</b>
<p>A <b>bookmark</b> associates a user definable name with a range of text
within a document. A bookmark is frequently used as an operand in <b>field
code</b> instructions within a field. In Window's Word a bookmark is represented
by three parallel data structures, the <b>sttbBkmk</b>, the <b>plcbkf</b>
and the <b>plcbkl</b>. The <b>sttbBkmk </b>is a string table which contains
the name of each bookmark that is defined. The <b>plcbkf</b> records the
beginning CP position of each bookmark. The <b>plcbkl </b>records the limit
CP position that delimits the end of a bookmark. Since bookmarks may be
nested within one another to any level, the <b>BKF</b> structure stored
in the <b>plcbkf</b> consists of a single index which specifies which <b>plcbkl
</b>marks
the end of the bookmark. The <b>BKL</b> structure is not written to the
file, and the plcbkl contains only CPs.
<p><b>picture</b>
<p>A picture is represented in the document text stream as a special character,
an ASCII 1 whose CHP has the fSpec bit set to 1. The file location of the
picture in the Word binary file is stored in the character's CHP in chp.fcPic.
The fcPic is a byte offset into the data stream. Beginning at the position
recorded in chp.fcPic, a header data structure, the PIC, will be stored.
If the picture is a reference to a TIFF file, a Picture file or an Office
shape file, the name of the file will be recorded immediately following
the PIC in a Pascal style string. If the picture is an Office shape, a
Window's metafile or a bitmap, the shape, metafile or bitmap will immediately
follow the PIC. Pictures that are a reference to an Office shape file will
include both the filename and the shape in that order. Pictures inserted
with Word97 are in the new Office shape format (documented elsewhere).
However, pictures can be copied from older files into newer ones and their
old format will persist until the picture is edited or displayed<b>.</b>
<p>Some files (including all files created by Word for the Macintosh) may
store Macintosh PICT pictures as well. In this case, the PIC structure
is immediately followed by a standard Windows metafile depicting a large
"x", so that older readers expecting only a metafile after the PIC will
just display this "x". If a reader detects this standard "x" metafile,
it can extract the sizes of the standard "x" metafile and the Macintosh
PICT picture that follows it from an early portion of this "x" metafile.
Please see Appendix B for a discussion of this technique.
<p><b>embedded object</b>
<p>The native data for Embedded objects (OBJs) is stored similarly to pictures
(PICs).<b> </b>To locate the native data for Embedded objects, scan the
plc of field codes for the mother, header, footnote and annotation, textbox
and header textbox documents (fib.PlcffldMom/Hdr/Ftn/Atn/Txbx/HdrTxbx).For
each separator field, get the chp.
<p>If chp.fSpec=1 and chp.fObj=1, then this separator field has an associated
embedded object. The file location of the object data is stored in chp.fcObj.
At the specified location an object header is stored followed by the native
data for the object. See the OBJHEADER structure.
<p>If chp.fOle2=1, then this separator field has an associated OLE2 object.
The fcPic will be a unique integer that specifies the name of the object's
sub-storage instead of an offset into the data stream.
<p><b>office art object</b>
<p>An office art object is represented in the document stream as a special
character, an ASCII 8, which has chp.fSpec set to 1 for the run of text
containing the character .<b> </b>Only main documents and header documents
contain office art objects.<b> </b>The native data for the office art object
may be obtained by taking the CP for the special character and using this
to find the corresponding entry in the <b>plcspa</b>.<b> </b>An entry in
this plc consists of a <b>FSPA</b> structure, which is described elsewhere
in this document.
<p>Office art objects can have text attached to them. Text for the textboxes
is stored separately in the textbox subdocument of the main or header document.The
textbox subdocument contains a <b>plctxbxs</b> where the text from CP n
to CP n+1 in the subdocument is the text which is contained in a textbox
as specified in the <b>TXBXS</b> structure for this n<sup>th</sup> entry
in the <b>plctxbxs</b>. Textboxes can be linked in chains of up to 32 textboxes.
Ordering of textboxes in the subdocument is completely unrelated to the
document structure due to the nature of textbox linking. To find the text
for a given office art object, the <b>TXID</b> property (a long: high word
is itxbxs+1, low word is the sequence number) must be fetched from the
office art data for the shape. This contains an index (itxbxs) into <b>plctxbxs</b>
and a sequence number in the chain of linked textboxes. The text for the
entire chain of linked textboxes is stored from the CP itxbxs to CP itxbxs+1
of plctxbxs. The <b>plctxbxBkd</b> describes the "page table" within textbox
stories (where the textboxes in each linked textbox chain are thought of
as "pages"). So, for each entry in the plctxbxs there is a corresponding
entry in the <b>plctxbxBkd</b> at the same CP, and there may be additional
entries in the <b>plctxbxBkd</b> to describe the breaks from one textbox
to the next in linked textbox chains.
<p>Note
<p>In this document, bit 0 is the low-order bit. Structures are described
as they would be declared in C for the Intel architecture. When numbering
bytes in a word from low offset towards high offset, two-byte integers
will have their least significant eight bits stored in byte 0 and most
significant eight bits in byte 1. If bit 31 is the most significant bit
in a four-byte integer, bits 31 through 24 will be stored in byte 3 of
a four-byte integer, bits 23 through 16 will be stored in byte 2, bits
15 through 8 will be stored in byte 1, and bits 7 through 0 will be stored
in byte 0.
<br><a NAME="03"></a>
<h2>
Naming Conventions</h2>
The names in Word data structures usually consist of a lower case sequence
of characters followed by an optional upper case modifier. The following
tags are used in the lower case parts of field names to document the data
type of a field:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>f</td>

<td>used to name a flag (a variable containing a Boolean value). Usually
the object referred to will contain either 1 (<i>fTrue</i>, <i>TRUE</i>)
or 0 (<i>fFalse</i>, <i>FALSE</i>). (e.g. fWidowControl, fShadow)</td>
</tr>

<tr>
<td>l</td>

<td>used to name a 4 byte integer value ( a long). (e.g. lcb)</td>
</tr>

<tr>
<td>w</td>

<td>used to name a 2 byte integer value (a short ).</td>
</tr>

<tr>
<td>b</td>

<td>used to name a 1 byte integer value</td>
</tr>

<tr>
<td>cp</td>

<td>used to name a variable that contains a character position within the
document. always a 4 byte quantity.</td>
</tr>

<tr>
<td>fc</td>

<td>used to name a variable that contains an offset from the beginning
of a file. always a 4 byte quantity.</td>
</tr>

<tr>
<td>xa</td>

<td>used to name a variable that contains a width of an object imaged on
screen or on hard copy that is measured in units of 1/1440 of an inch.
This unit which is one-twentieth of a point size (1/20 * 1/72") is called
a <b>twip</b> in this documentation. (e.g. xaPage is the width of a page).</td>
</tr>

<tr>
<td>ya</td>

<td>used to name a variable that contains a height of an object imaged
on screen or on hard copy that is measured in twips.</td>
</tr>

<tr>
<td>dxa</td>

<td>used to name a variable that contains the horizontal distance of an
object measured from some reference point expressed in twips. (e.g. pap.dxaLeft
is the distance of the left boundary of a paragraph measured from the left
margin of the page)</td>
</tr>

<tr>
<td>dya</td>

<td>used to name a variable that contains the vertical distance of an object
measured from some reference point expressed in twips. (e.g. pap.dyaAbs
is the vertical distance of the top of a paragraph from a reference frame
declared in the pap).</td>
</tr>

<tr>
<td>dxp</td>

<td>used to name a variable that contains the horizontal distance of an
object measured from some reference point expressed in Macintosh pixel
units (1/72"). (e.g. dxpSpace)</td>
</tr>

<tr>
<td>dyp</td>

<td>used to name a variable that contains the vertical distance of an object
measured from some reference point expressed in Macintosh pixel units (1/72").</td>
</tr>

<tr>
<td>rg</td>

<td>prefix used to signify that the data structure being defined is an
array. (e.g. rgb (an array of bytes), rgcp (an array of CPs), rgfc (an
array of FCs), rgfoo (an array of foos).</td>
</tr>

<tr>
<td>i</td>

<td>prefix used to signify that an integer value is used as an index into
an array. (e.g. itbd is an index into rgtbd, itc is an index into rgtc.)</td>
</tr>

<tr>
<td>c</td>

<td>prefix used to signify that an integer value is a count of some number
of objects. (e.g. a cb is a count of bytes, a cl is a count of lines, ccol
is a count of columns, a cpe is a count of picture elements.)</td>
</tr>

<tr>
<td>grp</td>

<td>prefix used to name an array of bytes that contains one or more copies
of a variable length data structure with the instances of the data structure
stored one after the other in the array. (e.g. a grpprl is a array of bytes
that stores a group of prls.)</td>
</tr>

<tr>
<td>grpf</td>

<td>prefix used to name an integer or byte value whose bits are used as
flags. (e.g. grpfIhdt is a group of flags that records the types of headers
that are stored for a particular section of a document).</td>
</tr>
</table>

<p>The two following modifiers are used occasionally in this documentation:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>First</td>

<td>Means that variable marks the first of a range of objects. For example,
cpFirst would mark the first character position of a range of characters
in a document. fcFirst would mark the file offset of the first byte of
a range of bytes stored in a file.</td>
</tr>

<tr>
<td>Lim</td>

<td>Means the variable marks the limit of a range of objects (i.e. is the
index of the last object in a range plus 1). For example, cpLim would be
the limit CP of a range of characters in a document. fcLim would be the
limit file offset of a range of bytes stored in a file.</td>
</tr>
</table>
<a NAME="04"></a>
<h2>
Format of the Summary Info Stream in a Word File</h2>
The summary information for a Word document is stored in two structured
storage streams, SummaryInformation and DocumentSummaryInformation. Information
on the layout of the SummaryInformation stream can be found in Appendix
B of the OLE 2 Programmers Reference.
<h2>
Format of the Main Stream</h2>
<a NAME="05"></a>
<h3>
Non-Complex File</h3>
The main stream of a Word docfile (non-complex format) consists of the
Word file header (FIB), the text, and the formatting information.
<blockquote>
<dl>
<dt>
<b>FIB</b></dt>

<dd>
Stored at beginning of page 0 of the file. fib.fComplex will be set to
zero.</dd>

<dt>
<b>text of body, footnotes, headers</b></dt>

<dd>
Text begins at the position recorded in fib.fcMin.</dd>

<dt>
<b>FKPs for CHPs, PAPs and LVCs</b></dt>

<dd>
The first FKP begins at a 512-byte boundary after the last byte text written..
The remaining FKPs are recorded in the 512-byte pages that immediately
follow. The FKPs for CHPs PAPs and LVCs are interleaved. Previous versions
of Word wrote them in contiguous chunks. The hplcfbte's of the three flavors
(CHP, PAP and LVC) are used to find the relevant FKP of the appropriate
type.</dd>

<dt>
<b>group of SEPXs</b></dt>

<dd>
SEPXs immediately follow the FKPs and are concatenated one after the other.
SEPXs are no longer guaranteed to start on a page boundary if it would
span a boundary if placed immediately after the preceding SEPX.</dd>
</dl>
</blockquote>
<a NAME="06"></a>
<h3>
Complex File</h3>
The main stream of a Word binary file (complex format) consists of the
Word file header (FIB), the text, and the formatting information.
<blockquote>
<dl>
<dt>
<b>FIB</b></dt>

<dt>
<b>Text of body, footnotes, headers stored during last full save</b></dt>

<dd>
Text begins at the position recorded in fib.fcMin.</dd>

<dt>
<b>FKPs for CHPs, PAPs and LVCs</b></dt>

<dd>
The first FKP begins at a 512-byte boundary after the last byte text written..
The remaining FKPs are recorded in the 512-byte pages that immediately
follow. The FKPs for CHPs PAPs and LVCs are interleaved. Previous versions
of Word wrote them in contiguous chunks. The hplcfbte's of the three flavors
(CHP, PAP and LVC) are used to find the relevant FKP of the appropriate
type.</dd>

<dt>
<b>Group of SEPXs stored during last full save</b></dt>

<dt>
Any text, stored during first fast save</dt>

<dt>
Any FKPs stored during first fast save</dt>

<dt>
Any SEPXs stored during first fast save</dt>

<dt>
Any text, stored during second fast save</dt>

<dt>
Any FKPs stored during second fast save</dt>

<dt>
Any SEPXs stored during second fast save</dt>

<dt>
...</dt>

<dt>
Any text, stored during nth fast save</dt>

<dt>
Any FKPs stored during nth fast save</dt>

<dt>
Any SEPXs stored during nth fast save</dt>
</dl>
</blockquote>
<a NAME="07"></a>
<h2>
Format of the Table Stream</h2>
Word stores various plcfs and tables with the stream named either "0Table"
or "1Table". Ordinarily a file will contain only one table stream. However,
in some unusual circumstances (e.g. crash during file save) a file might
have two table streams. In that case the bit field fWhichTblStm in the
FIB should be used to determine which table stream to read. If fWhichTblStm
is 0, then the FIB refers to the stream named "0Table", and if fWhichTblStm
is 1, then the FIB refers to the stream name "1Table".
<blockquote>
<dl>
<dt>
<b>sttbfUssr</b></dt>

<dd>
Undocumented undo / versioning data</dd>

<dt>
<b>plcupcRgbuse</b></dt>

<dd>
Undocumented undo / versioning data</dd>

<dt>
<b>plcupcUsp</b></dt>

<dd>
Undocumented undo / versioning data</dd>

<dt>
<b>uskf</b></dt>

<dd>
Undocumented undo / versioning data</dd>

<dt>
<b>stsh (style sheet)</b></dt>

<dd>
Written immediately after the preivous table. This is recorded in all Word
documents.</dd>

<dt>
<b>plcffndRef (footnote reference position table)</b></dt>

<dd>
Written immediately after the <b>stsh</b> if the document contains footnotes</dd>

<dt>
<b>plcffndTxt (footnote text position table)</b></dt>

<dd>
Written immediately after the <b>plcffndRef</b> if the document contains
footnotes</dd>

<dt>
<b>pgdFtn (footnote text page description table)</b></dt>

<dd>
Written immediately after the <b>plcffndTxt</b> if the document contains
footnotes</dd>

<dt>
<b>bkdFtn (footnote text break descriptor table)</b></dt>

<dd>
Written immediately after the <b>pgdFtn</b> if the document contains footnotes.</dd>

<dt>
<b>plcfendRef (endnote reference position table)</b></dt>

<dd>
Written immediately after the previously recorded table if the document
contains endnotes</dd>

<dt>
<b>plcfendTxt (endnote text position table)</b></dt>

<dd>
Written immediately after the <b>plcfendRef</b> if the document contains
endnotes</dd>

<dt>
<b>pgdEdn (endnote text page description table)</b></dt>

<dd>
Written immediately after the <b>plcfendTxt</b> if the document contains
endnotes</dd>

<dt>
<b>bkdEdn (endnote text break descriptor table)</b></dt>

<dd>
Written immediately after the <b>pgdEdn</b> if the document contains endnotes</dd>

<dt>
<b>plcftxbxTxt (text box link table)</b></dt>

<dd>
Written immediately after the previously recorded table if the document
contains textboxes</dd>

<dt>
<b>plcftxbxBkd (text box break descriptor table)</b></dt>

<dd>
Written immediately after the <b>plcftxbxTxt</b> if the document contains
textboxes</dd>

<dt>
<b>plcfHdrtxbxTxt (header text box link table)</b></dt>

<dd>
Written immediately after the previously recorded table if the header subdocument
contains textboxes</dd>

<dt>
<b>plcfHdrtxbxBkd (header text box break descriptor table)</b></dt>

<dd>
Written immediately after the <b>plcfHdrtxbxTxt</b> if the header subdocument
contains textboxes.</dd>

<dt>
<b>grpXstAtnOwners (annotation owner table)</b></dt>

<dd>
Written immediately after the previously recorded table if the document
contains annotations.</dd>

<dt>
<b>plcfandRef (annotation reference position table)</b></dt>

<dd>
Written immediately after the <b>grpXstAtnOwners</b> if the document contains
annotations</dd>

<dt>
<b>plcfandTxt (annotation text position table)</b></dt>

<dd>
Written immediately after the <b>plcfandRef</b> if the document contains
annotations.</dd>

<dt>
<b>plcfsed (section table)</b></dt>

<dd>
Written immediately after the previously recorded table. Recorded in all
Word documents</dd>

<dt>
<b>pgdMother (page description table)</b></dt>

<dd>
Written immediately after the <b>plcfsed</b> in all Word documents</dd>

<dt>
<b>bkdMother (break descriptor table)</b></dt>

<dd>
Written immediately after the<b> pgdMother</b> in all Word documents</dd>

<dt>
<b>plcfphe (paragraph height table)</b></dt>

<dd>
Written after the previously recorded table, if paragraph heights have
been recorded. Only written during a fast save.</dd>

<dt>
<b>plcfsea (private)</b></dt>

<dd>
PLCF reserved for private use by Word.</dd>

<dt>
<b>plcflvc (list and outline level table)</b></dt>

<dd>
Written immediately after the previously recorded table during fast save
only.</dd>

<dt>
<b>plcasumy (AutoSummary analysis)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
stored is in AutoSummary view mode.</dd>

<dt>
<b>sttbGlsy (glossary name string table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
stored is a glossary.</dd>

<dt>
<b>sttbGlsyStyle (glossary style name string table)</b></dt>

<dd>
Written immediately after <b>sttbGlsy</b>, if the document stored is a
glossary.</dd>

<dt>
<b>plcfglsy (glossary entry text position table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
stored is a glossary.</dd>

<dt>
<b>plcfhdd (header text position table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains headers or footers.</dd>

<dt>
<b>plcfbteChpx (bin table for CHP FKPs)</b></dt>

<dd>
Written immediately after the previously recorded table. This is recorded
in all Word documents.</dd>

<dt>
<b>plcfbtePapx (bin table for PAP FKPs)</b></dt>

<dd>
Written immediately after the <b>plcfbteChpx</b>. This is recorded in all
Word documents.</dd>

<dt>
<b>plcfbteLvc (bin table for LVC FKPs)</b></dt>

<dd>
Written immediately after the <b>plcfbtePapx</b>. This is recorded in all
Word documents.</dd>

<dt>
<b>sttbfRMark (revision mark author string table)</b></dt>

<dd>
Written immediately after <b>plcfbteLvc</b>, if the document contains revision
marks.</dd>

<dt>
<b>PlcffldMom (table of field positions and statuses for main document)</b></dt>

<dd>
Written immediately after the previously recorded table if the main document
contains fields.</dd>

<dt>
<b>PlcffldHdr (table of field positions and statuses for header subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the header
subdocument contains fields.</dd>

<dt>
<b>PlcffldFtn (table of field positions and statuses for footnote subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the footnote
subdocument contains fields.</dd>

<dt>
<b>PlcffldAtn (table of field positions and statuses for annotation subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the annotation
subdocument contains fields.</dd>

<dt>
<b>PlcffldEdn (table of field positions and statuses for endnote subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the endnote
subdocument contains fields.</dd>

<dt>
<b>PlcffldTxbx (table of field positions and statuses for textbox subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the textbox
subdocument contains fields.</dd>

<dt>
<b>plcOcx (ocx position table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains ole controls. Undocumented.</dd>

<dt>
<b>PlcffldHdrTxbx (table of field positions and statuses for textbox subdocument
of header subdocument)</b></dt>

<dd>
Written immediately after the previously recorded table, if the textbox
subdocument of the header subdocument contains fields.</dd>

<dt>
<b>dggInfo (office drawing information)</b></dt>

<dd>
Written immediately after the previously recorded table. Format is described
in the Office drawing group format document.</dd>

<dt>
<b>plcspaMom (office drawing table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains office drawings.</dd>

<dt>
<b>plcspaHdr (header office drawing table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the header
subdocument contains office drawings.</dd>

<dt>
<b>sttbfBkmk (table of bookmark name strings)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains bookmarks.</dd>

<dt>
<b>plcfBkmkf (table recording beginning CPs of bookmarks)</b></dt>

<dd>
Written immediately after the <b>sttbfBkmk</b>, if the document contains
bookmarks.</dd>

<dt>
<b>plcfBkmkl (table recording limit CPs of bookmarks)</b></dt>

<dd>
Written immediately after the <b>plcfBkmkf</b>, if the document contains
bookmarks.</dd>

<dt>
<b>sttbfAtnBkmk (table of annotation bookmark string names)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains annotations with bookmarks.</dd>

<dt>
<b>plcfAtnbkf (table recording beginning CPs of bookmarks in the annotation
subdocument)</b></dt>

<dd>
Written immediately after the <b>sttbfAtnBkmk</b> previously recorded table,
if the document contains annotations with bookmarks.</dd>

<dt>
<b>plcfAtnbkl (table recording limit CPs of bookmarks in the annotation
subdocument)</b></dt>

<dd>
Written immediately after the <b>plcfAtnbkf</b> previously recorded table,
if the document contains anotations with bookmarks.</dd>

<dt>
<b>plcfspl (spelling state table)</b></dt>

<dd>
Written immediately after the previously recorded table. Records state
of spell checking in a PLCF of SPLS structures.</dd>

<dt>
<b>plcfgram (grammar state table)</b></dt>

<dd>
Written immediately after the previously recorded table. Records state
of grammar checking in a PLCF of SPLS structures.</dd>

<dt>
<b>plcfwkb (work book document partition table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
is a master document.</dd>

<dt>
<b>formFldSttbs (form field dropdown string tables)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains form field dropdown controls.</dd>

<dt>
<b>sttbCaption (caption title string table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains captions.</dd>

<dt>
<b>sttbAutoCaption (auto caption string table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
contains auto captions.</dd>

<dt>
<b>sttbFnm (filename reference string table)</b></dt>

<dd>
Written immediately after the previously recorded table, if the document
references other documents.</dd>

<dt>
<b>sttbSavedBy (last saved by string table)</b></dt>

<dd>
Written immediately after the previously recorded table.</dd>

<dt>
<b>plcflst (list formats) [ATTENTION: Claim to be a plcf, but is a "short" plf (short count only)! (Werner)]</b></dt>

<dd>
Written immediately after the end of the previously recorded, if there
are any lists defined in the document. This begins with a short count of
LSTF structures followed by those LSTF structures.</dd>

<dd>
This is immediately followed by the allocated data hanging off the LSTFs.
This data consists of the array of LVLs for each LSTF. (Each LVL consists
of an LVLF followed by two grpprls and an XST.)</dd>

<dt>
<b>plflfo (more list formats)</b></dt>

<dd>
Written immediately after the end of the <b>plcflst</b> and its accompanying
data, if there are any lists defined in the document. This consists first
of a PL of LFO records, followed by the allocated data (if any) hanging
off the LFOs. The allocated data consists of the array of LFOLVLFs for
each LFO (and each LFOLVLF is immediately followed by some LVLs).</dd>

<dt>
<b>sttbfListNames (more list formats)</b></dt>

<dd>
Written immediately after the end of the plflfo and its accompanying data,
if there are any lists defined in the document. This is a string table
containg the list names for each list. It is parallel with the <b>plcflst</b>,
and may contain null strings if the corresponding LST does not have a list
name.</dd>

<dt>
<b>hplgosl (grammar option settings)</b></dt>

<dd>
Written immediately after the previously recorded table. This undocumented
structure maps LID and grammar checker type to grammar checking options.</dd>

<dt>
<b>stwUser (macro user storage)</b></dt>

<dt>
<b>routeSlip (mailer routing slip)</b></dt>

<dd>
Written immediately after the previously recorded table, if this document
has a mailer routing slip.</dd>

<dt>
<b>cmds</b> (recording of command data structures)</dt>

<dd>
Written immediately after the previously recorded table, if special commands
are linked to this document.</dd>

<dt>
<b>prDrvr (printer driver information)</b></dt>

<dd>
Written immediately after the previously recorded table, if a print environment
is recorded for the document.</dd>

<dt>
<b>prEnvPort (print environment in portrait mode)</b></dt>

<dd>
Written immediately after the previously recorded table, if a portrait
mode print environment is recorded for this document.</dd>

<dt>
<b>prEnvLand (print environment in landscape mode)</b></dt>

<dd>
Written immediately after the previously recorded table, if a landscape
mode print environment is recorded for this document.</dd>

<dt>
<b>wss (window state structure)</b></dt>

<dd>
Written immediately after the end of previously recorded structure, if
the document was saved while a window was open.</dd>

<dt>
<b>pms (print merge state)</b></dt>

<dd>
Written immediately after the previously recorded table, if information
about the print / mail merge state is recorded for the document</dd>

<dt>
<b>clx (encoding of the sprm lists for a complex file and piece table for
a any file)</b></dt>

<dd>
Written immediately after the end of previously recorded structure. This
is recorded in all Word documents.</dd>

<dt>
<b>sttbfffn (table of font name strings)</b></dt>

<dd>
Written immediately after the <b>clx</b>. This is recorded in all Word
documents. The <b>sttbfffn</b> is an sttbf where each string is instead
an FFN structure (note that just as for a pascal-style string, the first
byte in the FFN records the total number of bytes not counting the count
byte itself). The names of the fonts correspond to the ftc codes in the
CHP structure. For example, the first font name listed corresponds is the
name for ftc = 0.</dd>

<dt>
<b>sttbttmbd (true type font embedding string table)</b></dt>

<dd>
Written immediately after the end of previously recorded structure if document
contains embedded true type fonts.</dd>

<dt>
<b>dop (document properties record)</b></dt>

<dd>
Written immediately after the end of previously recorded structure. This
is recorded in all Word documents</dd>

<dt>
<b>sttbfAssoc (table of associated strings)</b></dt>

<dt>
<b>autosaveSource (name of original)</b></dt>

<dd>
Written immediately after the <b>sttbfAssoc</b> table. This field only
appears in autosave files. These files are normal Word documents in every
other way. Also, autosaved files are typically in the complex file format
except that we don't overwrite the tables (plcf*, etc.). I.e., an autosaved
file is typically longer than the equivalent Word document.</dd>
</dl>
</blockquote>
<a NAME="08"></a>
<h2>
Format of the Data Stream</h2>

<blockquote>
<dl>
<dt>
<b>pictures</b></dt>

<dd>
Word picture structures are concatenated one after the other if the document
contains pictures.</dd>

<dt>
<b>embedded objects-native data</b></dt>

<dd>
Word embedded object structures are concatenated one after the other if
the document contains embedded objects.</dd>

<dt>
<b>huge PAPXs</b></dt>

<dd>
The grpprls from PAPXs which are too large to fit in an FKP are concatenated
one after the other as necessary.</dd>
</dl>
</blockquote>
<a NAME="09"></a>
<h2>
FIB</h2>
The FIB contains a "magic word" and pointers to the various other parts
of the file, as well as information about the length of the file. The FIB
starts at the beginning of the file. The FIB is <a href="#57">defined</a>
in the structure definition section of this document.
<br><a NAME="10"></a>
<h2>
Text</h2>
The text of the file starts at fib.fcMin. fib.fcMin is usually set to the
next 128 byte boundary after the end of the FIB. The text in a Word document
is ASCII text with the following restrictions (ASCII codes given in decimal):\
<ul>
<li>
<b>Paragraph ends</b> are stored as a single Carriage Return character
(ASCII 13). No other occurrences of this character sequence are allowed.</li>

<li>
<b>Hard line breaks</b> which are not paragraph ends are stored as ASCII
11. Other line break or word wrap information is not stored.</li>

<li>
<b>Breaking hyphens</b> are stored as ASCII 45 (normal hyphen code); <b>Non-required
hyphens</b> are ASCII 31. <b>Non-breaking hyphens</b> are stored as ASCII
30.</li>

<li>
<b>Non-breaking spaces</b> are stored as 160. Normal <b>spaces</b> are
ASCII 32.</li>

<li>
<b>Page breaks</b> and <b>Section marks</b> are ASCII 12 (normal form feed);
if there's an entry in the section table, it's a section mark, otherwise
it's a page break.</li>

<li>
<b>Column breaks</b> are stored as ASCII 14.</li>

<li>
<b>Tab</b> characters are ASCII 9 (normal).</li>

<li>
The <b>field begin mark</b> which delimits the beginning of a field is
ASCII 19. The <b>field end mark</b> which delimits the end of a field is
ASCII 21. The <b>field separator</b> ,which marks the boundary between
the preceding field code text and following field expansion text within
a field, is ASCII 20. The <b>field escape character</b> is the '\' character
which also serves as the <b>formula mark</b>.</li>

<li>
The <b>cell mark</b> which delimits the end of a cell in a table row is
stored as ASCII 7 and has the fInTable paragraph property set to fTrue
(pap.fInTable == 1).</li>

<li>
The <b>row mark</b> which delimits the end of a table row is stored as
ASCII 7 and has the fInTable paragraph property and fTtp paragraph property
set to fTrue (pap.fInTable == 1 &amp;&amp; pap.fTtp == 1).</li>
</ul>
The following ASCII codes are treated as "special" characters when they
have the character property <i>special</i> on (chp.fSpec == 1):
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<th VALIGN=TOP>ASCII Code</th>

<th VALIGN=TOP>Special Character</th>
</tr>

<tr>
<td>0</td>

<td>Current page number</td>
</tr>

<tr>
<td>1</td>

<td>Picture</td>
</tr>

<tr>
<td>2</td>

<td>Autonumbered footnote reference.</td>
</tr>

<tr>
<td>3</td>

<td>Footnote separator character</td>
</tr>

<tr>
<td>4</td>

<td>Footnote continuation character</td>
</tr>

<tr>
<td>5</td>

<td>Annotation reference</td>
</tr>

<tr>
<td>6</td>

<td>Line number</td>
</tr>

<tr>
<td>7</td>

<td>Hand Annotation picture (Generated in Pen Windows)</td>
</tr>

<tr>
<td>8</td>

<td>Drawn object</td>
</tr>

<tr>
<td>10</td>

<td>Abbreviated date (e.g. "Wed, Dec 1, 1993")</td>
</tr>

<tr>
<td>11</td>

<td>Time in hours:minutes:seconds</td>
</tr>

<tr>
<td>12</td>

<td>Current section number</td>
</tr>

<tr>
<td>14</td>

<td>Abbreviated day of week (e.g. "Thu" for "Thursday")</td>
</tr>

<tr>
<td>15</td>

<td>Day of week (e.g. "Thursday")</td>
</tr>

<tr>
<td>16</td>

<td>Day short (e.g. "9" for the ninth day of the month)</td>
</tr>

<tr>
<td>22</td>

<td>Hour of current time with no leading zero</td>
</tr>

<tr>
<td>23</td>

<td>Hour of current time (two digit with leading zero when necessary)</td>
</tr>

<tr>
<td>24</td>

<td>Minute of current time with no leading zero</td>
</tr>

<tr>
<td>25</td>

<td>Minute of current time(two digit with leading zero when necessary)</td>
</tr>

<tr>
<td>26</td>

<td>Seconds of current time</td>
</tr>

<tr>
<td>27</td>

<td>AM/PM for current time</td>
</tr>

<tr>
<td>28</td>

<td>Current time in hours:minutes:seconds in old format</td>
</tr>

<tr>
<td>29</td>

<td>Date M (e.g. "December 2, 1993")</td>
</tr>

<tr>
<td>30</td>

<td>Short Date (e.g. "12/2/93")</td>
</tr>

<tr>
<td>33</td>

<td>Short Month (e.g. "12" to represent "December")</td>
</tr>

<tr>
<td>34</td>

<td>Long Year (e.g. "1993")</td>
</tr>

<tr>
<td>35</td>

<td>Short Year (e.g. "93")</td>
</tr>

<tr>
<td>36</td>

<td>Abbreviated month (e.g. "Dec" to represent "December")</td>
</tr>

<tr>
<td>37</td>

<td>Long month (e.g. "December")</td>
</tr>

<tr>
<td>38</td>

<td>Current time in hours:minutes (e.g. "2:01")</td>
</tr>

<tr>
<td>39</td>

<td>Long date (e.g. "Thursday, December 2, 1993")</td>
</tr>

<tr>
<td>41</td>

<td>Print Merge Helper field</td>
</tr>
</table>

<h4>
Note</h4>
The end of a section is also the end of a paragraph. The last character
of a section is a section mark which stands in place of the paragraph mark
normally required to end a paragraph. An exception is made for the last
character of a document which is always a paragraph mark although the end
of a document is always an implicit end of section.
<p>If !fib.fComplex, the document text stream is represented by the text
beginning at fib.fcMin up to (but not including) fib.fcMac. Otherwise,
the document is represented by the piece table stored in the file in the
data beginning at .fib.fcClx.
<p>The document text stream includes text that is part of the main document,
plus any text that exists for the footnote, header, macro, or annotation
subdocuments. The sizes of the main document and the header, footnote,
macro and annotation subdocuments are stored in the fib, in variables fib.ccpText,
fib.ccpFtn, fib.ccpHdr, fib.ccpMcr, fib.ccpEdn, fib.ccpTxbx, fib.ccpHdrTxbox
and fib.ccpAtn respectively. In a non-complex file, this means that the
text of the main document begins at fib.fcMin in the file and continues
through fib.fcMin + fib.ccpText; that the text of the footnote subdocument
begins at fib.fcMin + fib.ccpText and extends to fib.fcMin + fib.ccpText
+ fib.ccpFtn; that the text of the header subdocument begins at fib.fcMin
+ fib.ccpText + fib.ccpFtn and extends to fib.fcMin + fib.ccpText + fib.ccpFtn
+ fib.ccpHdr; that the text of the annotation subdocument begins at .fib.fcMin
+ fib.ccpText + fib.ccpFtn + fib.ccpHdr and extends to fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr + ccpAtn; that the text of the endnote subdocument
begins at .fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr +ccpAtn and
extends to fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn;
that the text of the textbox subdocument begins at .fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr +fib.ccpAtn + fib.ccpEdn and extends to fib.fcMin
+ fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn + fib.ccpTxbx and
that the text of the header textbox subdocument begins at .fib.fcMin +
fib.ccpText + fib.ccpFtn + fib.ccpHdr +fib.ccpAtn + fib.ccpEdn + fib.ccpTxbx
and extends to fib.fcMin + fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpEdn
+ fib.ccpTxbx + fib.ccpHdrTxbx.
<p>In a complex, fast-saved file, the main document text must be located
by examining the piece table entries from the 0th piece table entry through
the piece table entry that describes cp = fib.ccpText.
<p>A footnote subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText through
the entry that describes cp = fib.ccpText + fib.ccpFtn.
<p>A header subdocument's text must be located by examining the piece table
entries beginning with the one that describes cp=fib.ccpText + ccpFtn through
the entry that describes cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr.
<p>An annotation subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr through the entry that describes cp = fib.ccpText +fib.ccpFtn
+ fib.ccpHdr +fib.ccpAtn.
<p>An endnote subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr + fib.ccpAtn through the entry that describes cp = fib.ccpText
+fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+ fib.ccpEdn
<p>A textbox subdocument's text must be located by examining the piece
table entries beginning with the one that describes cp=fib.ccpText + ccpFtn
+ fib.ccpHdr + fib.ccpAtn + fib.ccpEdn through the entry that describes
cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+ fib.ccpEdn + fib.ccpTxbx
<p>A header textbox subdocument's text must be located by examining the
piece table entries beginning with the one that describes cp=fib.ccpText
+ ccpFtn + fib.ccpHdr + fib.ccpAtn + fib.ccpEdn + fib.ccpTxbx through the
entry that describes cp = fib.ccpText +fib.ccpFtn + fib.ccpHdr +fib.ccpAtn.+
fib.ccpEdn + fib.ccpTxbx+ fib.ccpHdrTxbx
<br><a NAME="11"></a>
<h2>
Character and Paragraph Formatting Properties</h2>
Character and paragraph properties in Word documents are stored in a compressed
format. The information that is stored on disk is not the actual properties
of a particular sequence of text but the difference of the properties of
a sequence from some reference property.
<p>The <b>PAP</b> is a data structure that holds uncompressed paragraph
property information; the <b>CHP</b> (pronounced like "chip") is a structure
that holds uncompressed character property information. Each paragraph
in a Word document inherits a default set of paragraph and character properties
from one of the <b>paragraph styles</b> recorded in the style sheet data
structure (<b>STSH</b>).
<p>A particular <b>PAP</b> is converted into its compressed form, the <b>PAPX</b>,
by first comparing the pap for a paragraph with the pap stored in the style
sheet for the paragraph's style. Any properties in the paragraph's <b>PAP</b>
that are different from those stored in the style sheet <b>PAP</b> are
encoded as a list of <b>sprms</b> (<b>grpprl</b>). <b>sprms</b> express
how the content of the style sheet <b>PAP</b> should be transformed to
create the properties for the paragraph. A <b>PAPX</b> is a variable-length
data structure that begins with a count of words that encodes the PAPX
length. It contains a <b>istd</b> (index to style descriptor) which specifies
which style entry in the style sheet contains the default paragraph and
character properties for the paragraph, paragraph height information, and
the list of difference sprms. If the only difference between the paragraph's
<b>PAP</b>
and the style's <b>PAP</b> were in the justification code field, which
is one byte long, one two-byte sprm, sprmPJc, would be generated to express
that difference; thus the total <b>PAPX</b> size would be 5 bytes. This
is better than 54-1 compression since the total size of a <b>PAP</b> is
274 bytes.
<p>To convert a <b>CHP</b> for a sequence of characters contained within
a single paragraph into its compressed form, the <b>CHPX</b>, it's first
necessary to know the <b>paragraph style</b> that is assigned to the paragraph
containing those characters and any character style that may be tagging
the character run. The character properties inherited from the paragraph
style are moved into a buffer. If the chp.istd of the chp to be compressed
is not istdNormalChar, the changes recorded for that character style are
applied to buffer. Then the character properties of the character sequence
are compared with the character properties generated using the paragraph's
style and the run's character style. Any properties in the paragraph's
<b>CHP</b>
that are different from those stored in the generated CHP are encoded as
a list of <b>sprms</b> (<b>grpprl</b>). The <b>sprms</b> express how the
content of the CHP generated from the paragraph and character styles should
be transformed to create the character properties for the text run. A <b>CHPX</b>
is a variable-length data structure that begins with a count of words that
encodes the CHPX length followed by the list of difference sprms.
<p>If one of the bit fields in the CHP to be compressed such as fBold is
different from the reference CHP, you would build a difference sprm using
sprmCFBold in the first byte and the bytes pattern 0x81 in the second byte
which signifies that the value of the bit in the CHP to be compressed is
of opposite value from the value stored in the reference CHP. If there
was no difference, sprmCFBold would not be recorded in the grrprl to be
generated. If there were difference in a field larger than a single bit
such as the chp.hps, a sprmCHps would be generated to record the value
of chp.hps in the chp to be compressed. If the chp.hps were equal in both
the chp to be compressed and the reference CHP, sprmCHps would not be recorded
in the grrprl that is generated. If a sequence of characters has the same
character properties and the sequence spans more than one paragraph, it's
necessary to examine each paragraph's properties and to generate a different
<b>CHPX</b>
every time there is a change of style.
<p>In Word documents, the fundamental unit of text for which character
exception information is kept is the <b>run of exception text</b>, a contiguous
sequence of characters stored on disk that all have the same exception
properties with respect to their underlying style character properties.
Each run would have an entry recorded in a <b>CHPX FKP</b>. If a user never
changed the character properties inherited from the styles used in his
document and did a complete save of his document, although each of those
styles may have different properties, the entire document stream would
be one large <b>run of exception text</b> and one <b>CHPX</b> would suffice
to describe the character properties of the entire document.
<p>The fundamental unit of text for which paragraph properties are recorded
is the <b>paragraph</b>. Every paragraph has an entry recorded in a <b>PAPX
FKP.</b>
<p>The<b> CHPX FKP</b> and the <b>PAPX FKP</b> have similar physical structures.
An <b>FKP</b> is a 512-byte data structure that is stored in one page of
a Word file. At offset 511 is a 1-byte count named <b>crun</b>, which is
a count of runs of exception text for <b>CHPX FKP</b>s and which is a count
of paragraphs in <b>PAPX FKP</b>s. Beginning at offset 0 of the <b>FKP</b>
is an array of <b>crun+1 FC</b>s, named <b>rgfc</b>, which records the
beginning and limit <b>FC</b>s of <b>crun</b> runs of exception text or
paragraphs.
<p>For CHPX FKPs, immediately following fkp.<b>rgfc</b> is a byte array
of <b>crun</b> word offsets to <b>CHPX</b>s from the beginning of the <b>FKP.</b>
This byte array, named <b>rgb</b>, is in 1-to-1 correspondence with the
<b>rgfc</b>.
The <b>ith</b> <b>rgb</b> gives the word offset of the exception property
that belongs to the run\paragraph whose beginning
<p>For <b>PAPX FKPSs</b>, immediately following the <b>fkp.rgfc</b> is
an array of 13 byte entries called <b>BXs</b>. This array called the <b>rgbx</b>
is in 1-to-1 correspondence with the <b>rgfc</b>. The first byte of the
<b>ith
BX</b> entry contains a single byte field which gives the word offset of
the <b>PAPX</b> that belongs to the paragraph whose beginning in <b>FC</b>
space is <b>rgfc</b>[i] and whose limit is <b>rgfc[i+1]</b> in <b>FC</b>
space. The last 12 bytes of the<b> ith BX</b> entry contain a <b>PHE</b>
structure that stores the current paragraph height of the paragraph whose
beginning in <b>FC</b> space is <b>rgfc</b>[i] and whose limit is <b>rgfc[i+1]</b>
in <b>FC</b> space.
<p>The fact that the offset to property stored in the <b>rgb</b> or <b>rgbx</b>
is a word offset implies that<b> CHPX</b>s and <b>PAPX</b>s are stored
in <b>FKP</b>s beginning on word boundaries. Since the values stored in
the <b>rgb/rgbx</b> allow random access throughout the <b>FKP,</b> space
within an <b>FKP</b> can be conserved by storing the offset of the same
physical <b>CHPX/PAPX</b> in <b>rgb/rgbx</b> entries when several runs
or paragraphs in the FKP have the same properties. Word uses this optimization.
<p>An <b>rgb or rgbx[].b</b> value of 0 is used in another optimization.
When a <b>rgb</b> or <b>rgbx[].b</b> value of 0 is stored in an <b>FKP,</b>
it means that instead of referring to a particular CHPX/PAPX in the FKP
the 0 value is a signal that the reader should construct for itself a commonly
encountered predefined set of properties.
<p>For <b>CHPX FKP</b>s a 0 <b>rgb</b> value means that the properties
of the run of text were exactly equal to the character properties inherited
from the style of the paragraph it was in. For <b>PAPX FKP</b>s, a 0 <b>rgbx[].b</b>
value means that the paragraph's properties were exactly equal to the paragraph
properties of the Normal style (stc == 0) and the paragraph contained 1
line of 240 pixels, with a column width of 7980 dxas.
<p>When new entries are added to an <b>FKP</b>, there must be unallocated
space in the middle of the <b>FKP</b> equal to 5 bytes for CHPXs (size
of an <b>FC</b> plus size of one-byte word offset) or 11 bytes for PAPXs
(size of an <b>FC</b> plus the size of a seven byte BX entry), plus the
size of the new <b>CHPX</b> or <b>PAPX</b> if the property being added
is not already recorded in the <b>FKP</b> and is not the property coded
with a 0 <b>rgb/rgbx[].b</b> value. To add a new property in a CHPX FKP,
existing <b>rgb</b> entries are moved four bytes to the right in the <b>FKP</b>.
. To add a new property in a PAPX FKP, existing <b>rgbx</b> entries are
moved four bytes to the right in the <b>FKP</b>. The new <b>FC</b> is added
at the end of the <b>rgfc</b>. The new <b>CHPX</b> or <b>PAPX</b> is recorded
on a 2-byte boundary before the previously recorded properties stored at
the end of the block. The word offset of the beginning of the <b>CHPX</b>
or <b>PAPX</b> is stored as the last entry of the relocated <b>rgb/rgbx[].b,</b>
and finally, the <b>crun</b> stored at offset 511 is incremented. In Word
'97, PAPXs can be generated which are too large to fit in an FKP. In such
a case, the grpprl of the PAPX is written to the data stream and a PAPX
is stored in an FKP with that grpprl replaced by a sprmPHugePapx.
<br><a NAME="12"></a>
<h2>
Bin Tables</h2>
A bin table (<b>plcfbte</b>) partitions the total extent of the Word file
that contains text characters into a set of contiguous intervals marked
by a fcFirst and an fcLim. The fcFirst for the <b>nth</b> interval would
be plcfbte.rgfc[<b>n</b>] and the fcLim for the <b>nth</b> interval would
be plcfbte.rgfc[<b>n+1</b>]. Associated with each interval is a <b>BTE.</b>
A <b>BTE</b> holds a four-byte <b>PN</b> (page number) which identifies
the <b>FKP</b> page in the file which contains the formatting information
for that interval. A <b>CHPX</b> <b>FKP</b> further partitions an interval
into runs of exception text. A <b>PAPX FKP</b> in a non-complex, full-saved
file, partitions the text within intervals into paragraphs. If a file is
in complex format (has been fast-saved), the <b>PAPX FKP</b> only records
the FCs within the text that are preceded by a paragraph mark. Even though
a sequence of text may be physically located between two paragraph end
marks, it may reside in a paragraph different from the one defined by the
following paragraph end mark, because the text may have been moved by the
user into a different paragraph. In the logical text stream represented
by the document's piece table, the paragraph mark that follows the moved
text is stored in a non-adjacent physical location in the file.
<br><a NAME="13"></a>
<h2>
Stylesheet</h2>
A stylesheet is a collection of styles. In Word, each document has its
own stylesheet.
<p>A style is a set of formatting information collected together and given
a name. Word 6.0 supports paragraph and character styles, previous versions
supported only paragraph styles. Character styles have just character formatting,
paragraph styles have both character and paragraph formatting. The style
sheet establishes a correspondence between a style code and a style definition.
<p>Note that the storage and behavior of styles has changed radically since
Word 2 for Windows, beginning with nFib 63. Some of the differences are:
<ul>
<li>
Character styles are supported.</li>

<li>
The style code is called an istd, rather than an stc.</li>

<li>
The istd is a short, where the stc was a byte.</li>

<li>
The range of the istd is 0-4095, where 4095 is the null style. The range
of the stc was 0-256, with 222 as the null style.</li>

<li>
PAPX's have a short istd at the beginning, rather than a byte stc.</li>

<li>
CHPX's are a grpprl, not a CHP.</li>

<li>
Many other changes...</li>
</ul>
This document describes only the final Word 6.0 version of the stylesheet,
not the Word 2.x version.
<p>The styles for a document (both paragraph and character styles) are
stored in an array in each document. When new styles are created, they
are added to the end of the array. The array can have unused slots. Some
slots at the beginning of the array are reserved for specific styles, whether
they have been created yet or not. Paragraph and character styles are stored
in the same array. Each document has a separate array, so the same style
will usually have a different istd in two different documents. Thus style
matching between documents must be done by name (or by sti if the styles
are built-in.)
<p>Styles are usually referred to using an istd. The istd is an index into
an array of STD's (STyle Descriptions). A (doc, istd) pair uniquely identifies
a style because it tells which style in which array.
<p>Parts of a style (for more information, see the STD structure below):
<ul>
<li>
sti: A style identifier. Built-in styles have an sti that indicates which
built-in style they are. User-defined styles all have stiUser.</li>

<li>
sgc: The type of style, either paragraph or character.</li>

<li>
istdBase: The style that this style is based on.</li>

<li>
istdNext: The style that should be applied after this one.</li>

<li>
stzName: The name of a style, unique within its stylesheet.</li>

<li>
UPX: The difference between this style and the one it is based on.</li>

<li>
UPE: The properties of this style (a PAP, CHP, and/or grpprl).</li>
</ul>
Every paragraph has a paragraph style. Every character has a character
style. The default paragraph style is Normal (stiNormal, istdNormal). The
default character style is Default Paragraph Font (stiNormalChar, istdNormalChar).
<p>The formatting of a paragraph (the PAP) and a character (the CHP) depend
on the paragraph and character styles applied to them, as well as any additional
formatting stored in the FKPs. The PAP and CHP are constructed in a layered
fashion:
<p>For a PAP:
<ul>
<li>
An initial PAP is determined by getting the PAP from the paragraph's style.</li>

<li>
Any paragraph formatting stored in the file (the FKP papx's) is then applied
to that PAP.</li>
</ul>
For a CHP:
<ul>
<li>
An initial CHP is determined by getting the CHP from the paragraph's style.</li>

<li>
Properties from the character's style (the UPX.chpx.grpprl) are then applied
to that CHP.</li>

<li>
Any character formatting stored in the file (the FKP chpx's) is the applied
to that CHP.</li>
</ul>
Note that the resulting PAP and CHP have fields that indicate what style
was applied: PAP.istd, CHP.istd.
<p><b>Stylesheet File Format</b>
<p>The style sheet (STSH) is stored in the file in two parts, a <a href="#14">STSHI</a>
and then an array of <a href="#15">STD</a>s. The STSHI contains general
information about the following stylesheet, including how many styles are
in it. After the STSHI, each style is written as an STD. Both the STSHI
and each STD are preceded by a ushort that indicates their length.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>cbStshi</td>

<td>2 bytes</td>

<td>size of the following STSHI structure</td>
</tr>

<tr>
<td>STSHI</td>

<td>(cbStshi)</td>

<td>Stylesheet Information</td>
</tr>

<tr>
<td>Then for each style in the stylesheet (stshi.cstd), the following is
stored:</td>
</tr>

<tr>
<td>cbStd</td>

<td>2 bytes</td>

<td>size of the following STD structure</td>
</tr>

<tr>
<td>STD</td>

<td>(cbStd)</td>

<td>the style description</td>
</tr>
</table>
x
<br><a NAME="16"></a>
<h2>
List Tables</h2>
Word 97 stores its paragraph numbering information very differently from
Word 6.0. In Word 6.0, all information for a paragraph was stored in that
paragraph's pap.anld. In Word 97, the pap only contains two values: a short
ilfo and a byte ilvl, which indicate which list the paragraph belongs to
and which level of that list it should be, respectively. The ilfo is actually
an index into one of the the document's list tables: the pllfo, and the
paragraph gets most of its information about appearance from the list tables.
<p>There are three list tables in a word document: the rglst, the hpllfo,
and the hsttbListNames. They will be described below in greater detail,
and the precise formats of several of these structures (the LSTF, LVLF,
LFO, and LFOLVL) are listed in the appendix.
<br><a NAME="17"></a>
<h3>
LST records and the rglst</h3>
The LST structure is where most of the list appearance data is stored.
An LST consists of two main parts: (1) an LSTF, which is stored on disk
and contains formatting properties which apply to the entire list, such
as whether the list is simple or multilevel, the list's unique list index
and template code, the istd's (see Stylesheet above) of the styles (if
any) that each level in the list is linked to, and a number of Word 6 compatilibity
option; (2) an array of LVL structures, which describe the appearance of
each individual level in the LST.
<p>A LVL structure contains two parts to it: (1) an LVLF, which stores
all static data such as the start-at value for the list level, the numbering
type (arabic or roman), the alignment (left, right or centered) of the
number, and several Word 6.0 compatibility options; and (2) a set of pointers
to variable length data: (a) a grpprlChpx, which gives character formatting
to the paragraph number text itself, (b) a grpprlPapx, which gives paragraph
formatting to the paragraph containing the number, such as indenting and
tab information, and (c) the number text itself.
<p>Word writes out the rglst as the <b>plcflst</b> by writing out, first,
a short integer containing the number of LST structures to be written.
It then enumerates through the rglst, writing out each LSTF structure.
It then enumerates through the rglst again, deciding, for each LST, whether
it has one level (LSTF.fSimpleList) or nine levels (!LSTF.fSimpleList).
It then writes the appropriate number of LVL structures as described below.
<p>When Word writes out an LVL structure, it first writes out the LVLF,
followed by the grpprlPapx (of LVLF.cbGrpprlPapx bytes in length), followed
by the grpprlChpx (of length LVLF.cbGrpprlChpx), and an XCHAR string with
the number text, preceded by an XCHAR containing the string's length.
<br><a NAME="18"></a>
<h3>
List Names and the sttbListNames</h3>
The string table containing the List Names is by far the least significant
of the three list tables. Most lists do not have names, and the names are
only useful to users of the macro language. If this list has a name, however,
it will be in this table: the table is a parallel array with the <b>rglst</b>
above, and will contain an empty string for any list which does not have
a list name.
<br><a NAME="19"></a>
<h3>
LFO records and the pllfo</h3>
The LFO structure serves primarily as a level of indirection between the
paragraph and the LST, but also can be used to override certain features
of the list formats (LFO stands for List Format Override). An LFO consists
of two main parts: (1) the List ID of the list (LST record) to which this
LFO belongs, and an array of overrides to the formatting in that LST. For
the vast majority of LFOs, there are no overrides, but if there are any,
they reside in an array of LFOLVL structures -- one LFOLVL per level of
the LST to be overridden. An LFOLVL contains a set of flags to indicate
whether just the start-at value of the LST is overridden, or whether just
the formatting is overrridden, or both, as well as either a start-at value
or a pointer to a LVL record, depending upon the values of the flags. Note
that if the LFOLVL says the start-at value should be overridden, what that
means is that the FIRST paragraph in the document with this LFO should
have a number equal exactly to that start-at value, but any subsequent
paragraphs should just follow the previous paragraph in the sequence. Also,
if LFOLVL.fFormatting and LFOLVL.fStartAt are <i>both</i> true (rare) then
LFOLVL.iStartAt should be ignored in favor of the iStartAt value from the
corresponding LVL.
<p>Word writes out the pllfo first by writing out a PL of LFO structures.
It then enumerates through each LFO to figure out how many LFOLVLs each
one has (LFO.clfolvl), and writes out, in order, each LFOLVL structure
followed by its corresponding LVL structure (if LFOLVL.fFormatting is set).
<br><a NAME="20"></a>
<h3>
Paragraph List Formatting</h3>
Given a paragraph and its corresponding PAP, the following process must
be followed to find out the paragraph's list information:
<ul>
<li>
Using the pap.ilfo, look up the LFO record in the pllfo with that (1-based)
index.</li>

<li>
Using the LFO, and the pap.ilvl, check to see if there are any overrides
for this particular level. If so, and if the override pertains to both
formatting and start-at value, use the LVL record from the correct LFOLVL
in the LFO, and skip to step 5.</li>

<li>
If the override does not pertain to either formatting or start-at value,
we must look up the LST for this list. Using the LFO's List ID, search
the rglst for the LST with that List ID.</li>

<li>
Now, take from this LST any information (formatting or start-at value)
we still need after consulting the LFO.</li>

<li>
Once we've got the correct LVL record, apply the lvl.grpprlPapx to the
PAP. It may adjust the indents and tab settings for the paragraph.</li>

<li>
Use the other information in the LVL, such as the start at, number text,
and grpprlChpx, to determine the appearance of the actual paragraph number
text.</li>
</ul>
<a NAME="21"></a>
<h2>
SPRM Definitions</h2>
A <b>sprm</b> is an instruction to modify one or more properties within
one of the property defining data structures (<b>CHP</b>, <b>PAP</b>, <b>TAP</b>,
<b>SEP,
or PIC</b>). A <b>sprm</b> is a two-byte opcode at offset 0 which identifies
the operation to be performed. If necessary information for the operation
can always be expressed with a fixed length parameter, the fixed length
parameter is recorded immediately after the opcode beginning at offset
2. The length of a fixed length sprm is always 2 plus the size of the sprm's
parameter. If the parameter for the sprm is variable length, the count
of bytes of the following parameter is stored in the byte at offset 2,
followed by the parameter at offset 3.
<p>Three sprms -- sprmPChgTabs , sprmTDefTable, and sprmTDefTable10 --
can be longer than 256 bytes. The method for calculating the length of
sprmPChgTabs is recorded below with the description of the sprm. For sprmTDefTable
and sprmTDefTable10, the length of the parameter plus 1 is recorded in
the two bytes beginning at offset 2.
<p>For all other variable length sprms, the total length of the sprm is
the count recorded at offset 2 plus three (2 for the sprm + 1 for the count
byte). The parameter immediately follows the count.
<p>The sprm value encodes information on the size of the operand, the type
of sprm (PAP, CHP, etc), and whether the sprm requires special handling
(in cases where a property value isn't simply replaced).
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Sprm bits (0 = low)</td>

<td>Value</td>

<td>Details</td>
</tr>

<tr>
<td>0-8</td>

<td>ispmd</td>

<td>unique identifier within sgc group</td>
</tr>

<tr>
<td>9</td>

<td>fSpec</td>

<td>sprm requires special handling</td>
</tr>

<tr>
<td>10-12</td>

<td>sgc</td>

<td>sprm group; type of sprm (PAP, CHP, etc)</td>
</tr>

<tr>
<td>13-15</td>

<td>spra</td>

<td>size of sprm argument (see following table for values)</td>
</tr>
</table>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>sgc value</td>

<td>type of sprm</td>
</tr>

<tr>
<td>1</td>

<td>PAP</td>
</tr>

<tr>
<td>2</td>

<td>CHP</td>
</tr>

<tr>
<td>3</td>

<td>PIC</td>
</tr>

<tr>
<td>4</td>

<td>SEP</td>
</tr>

<tr>
<td>5</td>

<td>TAP</td>
</tr>
</table>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>spra value</td>

<td>operand size</td>
</tr>

<tr>
<td>0</td>

<td>1 byte (operand affects 1 bit)</td>
</tr>

<tr>
<td>1</td>

<td>1 byte</td>
</tr>

<tr>
<td>2</td>

<td>2 bytes</td>
</tr>

<tr>
<td>3</td>

<td>4 bytes</td>
</tr>

<tr>
<td>4</td>

<td>2 bytes</td>
</tr>

<tr>
<td>5</td>

<td>2 bytes</td>
</tr>

<tr>
<td>6</td>

<td>variable length -- following byte is size of operand</td>
</tr>

<tr>
<td>7</td>

<td>3 bytes</td>
</tr>
</table>

<p>When parsing a grpprl, you can use the sprm's spra value to determine
how many bytes are used by that sprm; it also enables you to skip over
sprms you don't handle.
<p>Unless otherwise noted, when a sprm is applied to a property the sprm's
parameter changes the old value of the property in question to the value
stored in the sprm parameter.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Name</td>

<td>sprm</td>

<td>Property Modified</td>

<td>Parameter</td>

<td>Parameter size</td>
</tr>

<tr>
<td>sprmPIstd</td>

<td>0x4600</td>

<td>pap.istd</td>

<td>istd (style code)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPIstdPermute</td>

<td>0xC601</td>

<td>pap.istd</td>

<td>permutation vector (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPIncLvl</td>

<td>0x2602</td>

<td>pap.istd, pap.lvl</td>

<td>difference between istd of base PAP and istd of PAP to be produced
(see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPJc</td>

<td>0x2403</td>

<td>pap.jc</td>

<td>jc (justification)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFSideBySide</td>

<td>0x2404</td>

<td>pap.fSideBySide</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFKeep</td>

<td>0x2405</td>

<td>pap.fKeep</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFKeepFollow</td>

<td>0x2406</td>

<td>pap.fKeepFollow</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFPageBreakBefore</td>

<td>0x2407</td>

<td>pap.fPageBreakBefore</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPBrcl</td>

<td>0x2408</td>

<td>pap.brcl</td>

<td>brcl</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPBrcp</td>

<td>0x2409</td>

<td>pap.brcp</td>

<td>brcp</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPIlvl</td>

<td>0x260A</td>

<td>pap.ilvl</td>

<td>ilvl</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPIlfo</td>

<td>0x460B</td>

<td>pap.ilfo</td>

<td>ilfo (list index)&nbsp;</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFNoLineNumb</td>

<td>0x240C</td>

<td>pap.fNoLnn</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPChgTabsPapx</td>

<td>0xC60D</td>

<td>pap.itbdMac, pap.rgdxaTab, pap.rgtbd</td>

<td>complex - see below</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPDxaRight</td>

<td>0x840E</td>

<td>pap.dxaRight</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaLeft</td>

<td>0x840F</td>

<td>pap.dxaLeft</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPNest</td>

<td>0x4610</td>

<td>pap.dxaLeft</td>

<td>dxa-see below</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaLeft1</td>

<td>0x8411</td>

<td>pap.dxaLeft1</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaLine</td>

<td>0x6412</td>

<td>pap.lspd</td>

<td>an LSPD, a long word structure consisting of a short of dyaLine followed
by a short of fMultLinespace - see below</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPDyaBefore</td>

<td>0xA413</td>

<td>pap.dyaBefore</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaAfter</td>

<td>0xA414</td>

<td>pap.dyaAfter</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPChgTabs</td>

<td>0xC615</td>

<td>pap.itbdMac, pap.rgdxaTab, pap.rgtbd</td>

<td>complex - see below</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPFInTable</td>

<td>0x2416</td>

<td>pap.fInTable</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFTtp</td>

<td>0x2417</td>

<td>pap.fTtp</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPDxaAbs</td>

<td>0x8418</td>

<td>pap.dxaAbs</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaAbs</td>

<td>0x8419</td>

<td>pap.dyaAbs</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaWidth</td>

<td>0x841A</td>

<td>pap.dxaWidth</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPPc</td>

<td>0x261B</td>

<td>pap.pcHorz, pap.pcVert</td>

<td>complex - see below</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPBrcTop10</td>

<td>0x461C</td>

<td>pap.brcTop</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcLeft10</td>

<td>0x461D</td>

<td>pap.brcLeft</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBottom10</td>

<td>0x461E</td>

<td>pap.brcBottom</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcRight10</td>

<td>0x461F</td>

<td>pap.brcRight</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBetween10</td>

<td>0x4620</td>

<td>pap.brcBetween</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPBrcBar10</td>

<td>0x4621</td>

<td>pap.brcBar</td>

<td>BRC10</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaFromText10</td>

<td>0x4622</td>

<td>pap.dxaFromText</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPWr</td>

<td>0x2423</td>

<td>pap.wr</td>

<td>wr (see description of PAP for definition</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPBrcTop</td>

<td>0x6424</td>

<td>pap.brcTop</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPBrcLeft</td>

<td>0x6425</td>

<td>pap.brcLeft</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPBrcBottom</td>

<td>0x6426</td>

<td>pap.brcBottom</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPBrcRight</td>

<td>0x6427</td>

<td>pap.brcRight</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPBrcBetween</td>

<td>0x6428</td>

<td>pap.brcBetween</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPBrcBar</td>

<td>0x6629</td>

<td>pap.brcBar</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPFNoAutoHyph</td>

<td>0x242A</td>

<td>pap.fNoAutoHyph</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPWHeightAbs</td>

<td>0x442B</td>

<td>pap.wHeightAbs</td>

<td>w</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDcs</td>

<td>0x442C</td>

<td>pap.dcs</td>

<td>DCS</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPShd</td>

<td>0x442D</td>

<td>pap.shd</td>

<td>SHD</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDyaFromText</td>

<td>0x842E</td>

<td>pap.dyaFromText</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPDxaFromText</td>

<td>0x842F</td>

<td>pap.dxaFromText</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFLocked</td>

<td>0x2430</td>

<td>pap.fLocked</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFWidowControl</td>

<td>0x2431</td>

<td>pap.fWidowControl</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPRuler</td>

<td>0xC632</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPFKinsoku</td>

<td>0x2433</td>

<td>pap.fKinsoku</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFWordWrap</td>

<td>0x2434</td>

<td>pap.fWordWrap</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFOverflowPunct</td>

<td>0x2435</td>

<td>pap.fOverflowPunct</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFTopLinePunct</td>

<td>0x2436</td>

<td>pap.fTopLinePunct</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFAutoSpaceDE</td>

<td>0x2437</td>

<td>pap.fAutoSpaceDE</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFAutoSpaceDN</td>

<td>0x2438</td>

<td>pap.fAutoSpaceDN</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPWAlignFont</td>

<td>0x4439</td>

<td>pap.wAlignFont</td>

<td>iFa (see description of PAP for definition)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPFrameTextFlow</td>

<td>0x443A</td>

<td>pap.fVertical pap.fBackward pap.fRotateFont</td>

<td>complex (see description of PAP for definition)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmPISnapBaseLine</td>

<td>0x243B</td>

<td>obsolete: not applicable in Word97 and later versions</td>

<td>&nbsp;</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPAnld</td>

<td>0xC63E</td>

<td>pap.anld</td>

<td>&nbsp;</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPPropRMark</td>

<td>0xC63F</td>

<td>pap.fPropRMark</td>

<td>complex (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPOutLvl</td>

<td>0x2640</td>

<td>pap.lvl</td>

<td>has no effect if pap.istd is &lt; 1 or is > 9</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFBiDi</td>

<td>0x2441</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFNumRMIns</td>

<td>0x2443</td>

<td>pap.fNumRMIns</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmPCrLf</td>

<td>0x2444</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPNumRM</td>

<td>0xC645</td>

<td>pap.numrm</td>

<td>&nbsp;</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmPHugePapx</td>

<td>0x6645</td>

<td>see below</td>

<td>fc in the data stream to locate the huge grpprl (see below)</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPFUsePgsuSettings</td>

<td>0x2447</td>

<td>pap.fUsePgsuSettings</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPFAdjustRight</td>

<td>0x2448</td>

<td>pap.fAdjustRight</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFRMarkDel</td>

<td>0x0800</td>

<td>chp.fRMarkDel</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFRMark</td>

<td>0x0801</td>

<td>chp.fRMark</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFFldVanish</td>

<td>0x0802</td>

<td>chp.fFldVanish</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCPicLocation</td>

<td>0x6A03</td>

<td>chp.fcPic and chp.fSpec</td>

<td>see below</td>

<td>variable length, length recorded is always 4</td>
</tr>

<tr>
<td>sprmCIbstRMark</td>

<td>0x4804</td>

<td>chp.ibstRMark</td>

<td>index into sttbRMark</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCDttmRMark</td>

<td>0x6805</td>

<td>chp.dttmRMark</td>

<td>DTTM</td>

<td>S32</td>
</tr>

<tr>
<td>sprmCFData</td>

<td>0x0806</td>

<td>chp.fData</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCIdslRMark</td>

<td>0x4807</td>

<td>chp.idslRMReason</td>

<td>an index to a table of strings defined in Word 6.0 executables</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCChs</td>

<td>0xEA08</td>

<td>chp.fChsDiff and chp.chse</td>

<td>see below</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmCSymbol</td>

<td>0x6A09</td>

<td>chp.fSpec, chp.xchSym and chp.ftcSym</td>

<td>see below</td>

<td>variable length, length recorded is always 4</td>
</tr>

<tr>
<td>sprmCFOle2</td>

<td>0x080A</td>

<td>chp.fOle2</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCIdCharType</td>

<td>0x480B</td>

<td>obsolete: not applicable in Word97 and later versions</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCHighlight</td>

<td>0x2A0C</td>

<td>chp.fHighlight, chp.icoHighlight</td>

<td>ico (fHighlight is set to 1 iff ico is not 0)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCObjLocation</td>

<td>0x680E</td>

<td>chp.fcObj</td>

<td>FC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmCFFtcAsciSymb</td>

<td>0x2A10</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCIstd</td>

<td>0x4A30</td>

<td>chp.istd</td>

<td>istd, see stylesheet definition</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCIstdPermute</td>

<td>0xCA31</td>

<td>chp.istd</td>

<td>permutation vector (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCDefault</td>

<td>0x2A32</td>

<td>whole CHP (see below)</td>

<td>none</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCPlain</td>

<td>0x2A33</td>

<td>whole CHP (see below)</td>

<td>none</td>

<td>0</td>
</tr>

<tr>
<td>sprmCKcd</td>

<td>0x2A34</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFBold</td>

<td>0x0835</td>

<td>chp.fBold</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFItalic</td>

<td>0x0836</td>

<td>chp.fItalic</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFStrike</td>

<td>0x0837</td>

<td>chp.fStrike</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFOutline</td>

<td>0x0838</td>

<td>chp.fOutline</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFShadow</td>

<td>0x0839</td>

<td>chp.fShadow</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFSmallCaps</td>

<td>0x083A</td>

<td>chp.fSmallCaps</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFCaps</td>

<td>0x083B</td>

<td>chp.fCaps</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFVanish</td>

<td>0x083C</td>

<td>chp.fVanish</td>

<td>0,1, 128, or 129 (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFtcDefault</td>

<td>0x4A3D</td>

<td>&nbsp;</td>

<td>ftc, only used internally, never stored in file</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCKul</td>

<td>0x2A3E</td>

<td>chp.kul</td>

<td>kul</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCSizePos</td>

<td>0xEA3F</td>

<td>chp.hps, chp.hpsPos</td>

<td>(see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmCDxaSpace</td>

<td>0x8840</td>

<td>chp.dxaSpace</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCLid</td>

<td>0x4A41</td>

<td>&nbsp;</td>

<td>only used internally never stored</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCIco</td>

<td>0x2A42</td>

<td>chp.ico</td>

<td>ico</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCHps</td>

<td>0x4A43</td>

<td>chp.hps</td>

<td>hps</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCHpsInc</td>

<td>0x2A44</td>

<td>chp.hps</td>

<td>(see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCHpsPos</td>

<td>0x4845</td>

<td>chp.hpsPos</td>

<td>hps</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCHpsPosAdj</td>

<td>0x2A46</td>

<td>chp.hpsPos</td>

<td>hps (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCMajority</td>

<td>0xCA47</td>

<td>chp.fBold, chp.fItalic, chp.fSmallCaps, chp.fVanish, chp.fStrike, chp.fCaps,
chp.rgftc, chp.hps, chp.hpsPos, chp.kul, chp.dxaSpace, chp.ico, chp.rglid</td>

<td>complex (see below)</td>

<td>variable length, length byte plus size of following grpprl</td>
</tr>

<tr>
<td>sprmCIss</td>

<td>0x2A48</td>

<td>chp.iss</td>

<td>iss</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCHpsNew50</td>

<td>0xCA49</td>

<td>chp.hps</td>

<td>hps</td>

<td>variable width, length always recorded as 2</td>
</tr>

<tr>
<td>sprmCHpsInc1</td>

<td>0xCA4A</td>

<td>chp.hps</td>

<td>complex (see below)</td>

<td>variable width, length always recorded as 2</td>
</tr>

<tr>
<td>sprmCHpsKern</td>

<td>0x484B</td>

<td>chp.hpsKern</td>

<td>hps</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCMajority50</td>

<td>0xCA4C</td>

<td>chp.fBold, chp.fItalic, chp.fSmallCaps, chp.fVanish, chp.fStrike, chp.fCaps,
chp.ftc, chp.hps, chp.hpsPos, chp.kul, chp.dxaSpace, chp.ico,</td>

<td>complex (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmCHpsMul</td>

<td>0x4A4D</td>

<td>chp.hps</td>

<td>percentage to grow hps</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCYsri</td>

<td>0x484E</td>

<td>chp.ysri</td>

<td>ysri</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCRgFtc0</td>

<td>0x4A4F</td>

<td>chp.rgftc[0]</td>

<td>ftc for ASCII text (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCRgFtc1</td>

<td>0x4A50</td>

<td>chp.rgftc[1]</td>

<td>ftc for Far East text (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCRgFtc2</td>

<td>0x4A51</td>

<td>chp.rgftc[2]</td>

<td>ftc for non-Far East text (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCCharScale</td>

<td>0x4852</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFDStrike</td>

<td>0x2A53</td>

<td>chp.fDStrike</td>

<td>&nbsp;</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFImprint</td>

<td>0x0854</td>

<td>chp.fImprint</td>

<td>1 or 0 [or 128/129 like CFBold and so on]</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFSpec</td>

<td>0x0855</td>

<td>chp.fSpec&nbsp;</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCFObj</td>

<td>0x0856</td>

<td>chp.fObj</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCPropRMark</td>

<td>0xCA57</td>

<td>chp.fPropRMark, chp.ibstPropRMark, chp.dttmPropRMark</td>

<td>Complex (see below)</td>

<td>variable length always recorded as 7 bytes</td>
</tr>

<tr>
<td>sprmCFEmboss</td>

<td>0x0858</td>

<td>chp.fEmboss</td>

<td>1 or 0 [or 128/129 like CFBold and so on]</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCSfxText</td>

<td>0x2859</td>

<td>chp.sfxtText</td>

<td>text animation</td>

<td>S8</td>
</tr>

<tr>
<td>sprmCFBiDi</td>

<td>0x085A</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFDiacColor</td>

<td>0x085B</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFBoldBi</td>

<td>0x085C</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFItalicBi</td>

<td>0x085D</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCFtcBi</td>

<td>0x4A5E</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCLidBi</td>

<td>0x485F</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCIcoBi</td>

<td>0x4A60</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCHpsBi</td>

<td>0x4A61</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmCDispFldRMark</td>

<td>0xCA62</td>

<td>chp.fDispFldRMark, chp.ibstDispFldRMark, chp.dttmDispFldRMark&nbsp;</td>

<td>Complex (see below)</td>

<td>variable length always recorded as 39 bytes</td>
</tr>

<tr>
<td>sprmCIbstRMarkDel</td>

<td>0x4863</td>

<td>chp.ibstRMarkDel</td>

<td>index into sttbRMark</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCDttmRMarkDel</td>

<td>0x6864</td>

<td>chp.dttmRMarkDel</td>

<td>DTTM</td>

<td>S32</td>
</tr>

<tr>
<td>sprmCBrc</td>

<td>0x6865</td>

<td>chp.brc</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmCShd</td>

<td>0x4866</td>

<td>chp.shd</td>

<td>SHD</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCIdslRMarkDel</td>

<td>0x4867</td>

<td>chp.idslRMReasonDel</td>

<td>an index to a table of strings defined in Word 6.0 executables</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCFUsePgsuSettings</td>

<td>0x0868</td>

<td>chp.fUsePgsuSettings</td>

<td>1 or 0</td>

<td>bit</td>
</tr>

<tr>
<td>sprmCCpg</td>

<td>0x486B</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCRgLid0</td>

<td>0x486D</td>

<td>chp.rglid[0]</td>

<td>LID: for non-Far East text</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCRgLid1</td>

<td>0x486E</td>

<td>chp.rglid[1]</td>

<td>LID: for Far East text</td>

<td>S16</td>
</tr>

<tr>
<td>sprmCIdctHint</td>

<td>0x286F</td>

<td>chp.idctHint</td>

<td>IDCT: (see below)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPicBrcl</td>

<td>0x2E00</td>

<td>pic.brcl</td>

<td>brcl (see PIC structure definition)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmPicScale</td>

<td>0xCE01</td>

<td>pic.mx, pic.my, pic.dxaCropleft, pic.dyaCropTop pic.dxaCropRight, pic.dyaCropBottom</td>

<td>Complex (see below)</td>

<td>length byte plus 12 bytes</td>
</tr>

<tr>
<td>sprmPicBrcTop</td>

<td>0x6C02</td>

<td>pic.brcTop</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPicBrcLeft</td>

<td>0x6C03</td>

<td>pic.brcLeft</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPicBrcBottom</td>

<td>0x6C04</td>

<td>pic.brcBottom</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmPicBrcRight</td>

<td>0x6C05</td>

<td>pic.brcRight</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmScnsPgn</td>

<td>0x3000</td>

<td>sep.cnsPgn</td>

<td>cns</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSiHeadingPgn</td>

<td>0x3001</td>

<td>sep.iHeadingPgn</td>

<td>heading number level</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSOlstAnm</td>

<td>0xD202</td>

<td>sep.olstAnm</td>

<td>OLST</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmSDxaColWidth</td>

<td>0xF203</td>

<td>sep.rgdxaColWidthSpacing</td>

<td>complex (see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmSDxaColSpacing</td>

<td>0xF204</td>

<td>sep.rgdxaColWidthSpacing</td>

<td>complex (see below)</td>

<td>3 bytes</td>
</tr>

<tr>
<td>sprmSFEvenlySpaced</td>

<td>0x3005</td>

<td>sep.fEvenlySpaced</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSFProtected</td>

<td>0x3006</td>

<td>sep.fUnlocked</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSDmBinFirst</td>

<td>0x5007</td>

<td>sep.dmBinFirst</td>

<td>&nbsp;</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDmBinOther</td>

<td>0x5008</td>

<td>sep.dmBinOther</td>

<td>&nbsp;</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSBkc</td>

<td>0x3009</td>

<td>sep.bkc</td>

<td>bkc</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSFTitlePage</td>

<td>0x300A</td>

<td>sep.fTitlePage</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSCcolumns</td>

<td>0x500B</td>

<td>sep.ccolM1</td>

<td># of cols - 1</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaColumns</td>

<td>0x900C</td>

<td>sep.dxaColumns</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSFAutoPgn</td>

<td>0x300D</td>

<td>sep.fAutoPgn</td>

<td>obsolete</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSNfcPgn</td>

<td>0x300E</td>

<td>sep.nfcPgn</td>

<td>nfc</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSDyaPgn</td>

<td>0xB00F</td>

<td>sep.dyaPgn</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaPgn</td>

<td>0xB010</td>

<td>sep.dxaPgn</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSFPgnRestart</td>

<td>0x3011</td>

<td>sep.fPgnRestart</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSFEndnote</td>

<td>0x3012</td>

<td>sep.fEndnote</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSLnc</td>

<td>0x3013</td>

<td>sep.lnc</td>

<td>lnc</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSGprfIhdt</td>

<td>0x3014</td>

<td>sep.grpfIhdt</td>

<td>grpfihdt (see Headers and Footers topic)</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSNLnnMod</td>

<td>0x5015</td>

<td>sep.nLnnMod</td>

<td>non-neg int.</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaLnn</td>

<td>0x9016</td>

<td>sep.dxaLnn</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaHdrTop</td>

<td>0xB017</td>

<td>sep.dyaHdrTop</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaHdrBottom</td>

<td>0xB018</td>

<td>sep.dyaHdrBottom</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSLBetween</td>

<td>0x3019</td>

<td>sep.fLBetween</td>

<td>0 or 1</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSVjc</td>

<td>0x301A</td>

<td>sep.vjc</td>

<td>vjc</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSLnnMin</td>

<td>0x501B</td>

<td>sep.lnnMin</td>

<td>lnn</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSPgnStart</td>

<td>0x501C</td>

<td>sep.pgnStart</td>

<td>pgn</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSBOrientation</td>

<td>0x301D</td>

<td>sep.dmOrientPage</td>

<td>dm</td>

<td>S8</td>
</tr>

<tr>
<td>sprmSBCustomize</td>

<td>0x301E</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmSXaPage</td>

<td>0xB01F</td>

<td>sep.xaPage</td>

<td>xa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSYaPage</td>

<td>0xB020</td>

<td>sep.yaPage</td>

<td>ya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaLeft</td>

<td>0xB021</td>

<td>sep.dxaLeft</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxaRight</td>

<td>0xB022</td>

<td>sep.dxaRight</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaTop</td>

<td>0x9023</td>

<td>sep.dyaTop</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDyaBottom</td>

<td>0x9024</td>

<td>sep.dyaBottom</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDzaGutter</td>

<td>0xB025</td>

<td>sep.dzaGutter</td>

<td>dza</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDmPaperReq</td>

<td>0x5026</td>

<td>sep.dmPaperReq</td>

<td>dm</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSPropRMark</td>

<td>0xD227</td>

<td>sep.fPropRMark, sep.ibstPropRMark, sep.dttmPropRMark&nbsp;</td>

<td>complex (see below)</td>

<td>variable length always recorded as 7 bytes</td>
</tr>

<tr>
<td>sprmSFBiDi</td>

<td>0x3228</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmSFFacingCol</td>

<td>0x3229</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmSFRTLGutter</td>

<td>0x322A</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmSBrcTop</td>

<td>0x702B</td>

<td>sep.brcTop</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSBrcLeft</td>

<td>0x702C</td>

<td>sep.brcLeft</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSBrcBottom</td>

<td>0x702D</td>

<td>sep.brcBottom</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSBrcRight</td>

<td>0x702E</td>

<td>sep.brcRight</td>

<td>BRC</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSPgbProp</td>

<td>0x522F</td>

<td>sep.pgbProp</td>

<td>&nbsp;</td>

<td>S16</td>
</tr>

<tr>
<td>sprmSDxtCharSpace</td>

<td>0x7030</td>

<td>sep.dxtCharSpace</td>

<td>dxt</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSDyaLinePitch</td>

<td>0x9031</td>

<td>sep.dyaLinePitch</td>

<td>dya</td>

<td>S32</td>
</tr>

<tr>
<td>sprmSClm</td>

<td>0x5032</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmSTextFlow</td>

<td>0x5033</td>

<td>sep.wTextFlow</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTJc</td>

<td>0x5400</td>

<td>tap.jc</td>

<td>jc</td>

<td>word (low order byte is significant)</td>
</tr>

<tr>
<td>sprmTDxaLeft</td>

<td>0x9601</td>

<td>tap.rgdxaCenter (see below)</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDxaGapHalf</td>

<td>0x9602</td>

<td>tap.dxaGapHalf, tap.rgdxaCenter (see below)</td>

<td>dxa</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTFCantSplit</td>

<td>0x3403</td>

<td>tap.fCantSplit</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmTTableHeader</td>

<td>0x3404</td>

<td>tap.fTableHeader</td>

<td>1 or 0</td>

<td>S8</td>
</tr>

<tr>
<td>sprmTTableBorders</td>

<td>0xD605</td>

<td>tap.rgbrcTable</td>

<td>complex(see below)</td>

<td>24 bytes</td>
</tr>

<tr>
<td>sprmTDefTable10</td>

<td>0xD606</td>

<td>tap.rgdxaCenter, tap.rgtc</td>

<td>complex (see below)</td>

<td>variable length</td>
</tr>

<tr>
<td>sprmTDyaRowHeight</td>

<td>0x9407</td>

<td>tap.dyaRowHeight</td>

<td>dya</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDefTable</td>

<td>0xD608</td>

<td>tap.rgtc</td>

<td>complex (see below)</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmTDefTableShd</td>

<td>0xD609</td>

<td>tap.rgshd</td>

<td>complex (see below)</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmTTlp</td>

<td>0x740A</td>

<td>tap.tlp</td>

<td>TLP</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTFBiDi</td>

<td>0x560B</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmTHTMLProps</td>

<td>0x740C</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmTSetBrc</td>

<td>0xD620</td>

<td>tap.rgtc[].rgbrc</td>

<td>complex (see below)</td>

<td>5 bytes</td>
</tr>

<tr>
<td>sprmTInsert</td>

<td>0x7621</td>

<td>tap.rgdxaCenter, tap.rgtc</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTDelete</td>

<td>0x5622</td>

<td>tap.rgdxaCenter, tap.rgtc</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDxaCol</td>

<td>0x7623</td>

<td>tap.rgdxaCenter</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTMerge</td>

<td>0x5624</td>

<td>tap.fFirstMerged, tap.fMerged</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTSplit</td>

<td>0x5625</td>

<td>tap.fFirstMerged, tap.fMerged</td>

<td>complex (see below)</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTSetBrc10</td>

<td>0xD626</td>

<td>tap.rgtc[].rgbrc</td>

<td>complex (see below)</td>

<td>5 bytes</td>
</tr>

<tr>
<td>sprmTSetShd</td>

<td>0x7627</td>

<td>tap.rgshd</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTSetShdOdd</td>

<td>0x7628</td>

<td>tap.rgshd</td>

<td>complex (see below)</td>

<td>4 bytes</td>
</tr>

<tr>
<td>sprmTTextFlow</td>

<td>0x7629</td>

<td>tap.rgtc[].fVertical
<br>tap.rgtc[].fBackward
<br>tap.rgtc[].fRotateFont</td>

<td>0 or 1
<br>0 or 1
<br>0 or 1</td>

<td>S16</td>
</tr>

<tr>
<td>sprmTDiagLine</td>

<td>0xD62A</td>

<td>&nbsp;</td>

<td>&nbsp;</td>

<td>&nbsp;</td>
</tr>

<tr>
<td>sprmTVertMerge</td>

<td>0xD62B</td>

<td>tap.rgtc[].vertMerge</td>

<td>complex (see below)</td>

<td>variable length always recorded as 2 bytes</td>
</tr>

<tr>
<td>sprmTVertAlign</td>

<td>0xD62C</td>

<td>tap.rgtc[].vertAlign</td>

<td>complex (see below)</td>

<td>variable length always recorded as 3 byte</td>
</tr>
</table>

<p>sprmPIstdPermute (opcode 0xC601) is a complex sprm which is applied
to a piece when the style codes of paragraphs within a piece must be mapped
to other style codes. It has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>sprm</td>

<td>S16</td>

<td>opcode( ==0xC601)</td>
</tr>

<tr>
<td>cch</td>

<td>S8</td>

<td>count of bytes (not including sprm and cch)</td>
</tr>

<tr>
<td>fLongg</td>

<td>S8</td>

<td>always 0</td>
</tr>

<tr>
<td>fSpare</td>

<td>S8</td>

<td>always 0</td>
</tr>

<tr>
<td>istdFirst</td>

<td>U16</td>

<td>index of first style in range to which permutation stored in rgistd
applies</td>
</tr>

<tr>
<td>istdLast</td>

<td>U16</td>

<td>index of last style in range to which permutation stored in rgistd
applies</td>
</tr>

<tr>
<td>rgistd[]</td>

<td>U16</td>

<td>array of istd entries that records the mapping of istds for text copied
from a source document to istds that exists in the destination document
after the text has been pasted</td>
</tr>
</table>

<p>To interpret sprmPIstdPermute, first check if pap.istd is greater than
the istdFirst recorded in the sprm and less than or equal to the istdLast
recorded in the sprm If not, the sprm has no effect. If it is, pap.istd
is set to rgistd[pap.istd - istdFirst]. sprmPIstdPermute is only stored
in <b>grpprls</b> linked to a piece table. It should never be recorded
in a PAPX.
<p>sprmPIncLvl (opcode 0x2602) is applied to pieces in the piece table
that contain paragraphs with style codes (istds) greater than or equal
to 1 and less than or equal to 9. These style codes identify heading levels
in a Word outline structure. The sprm causes a set of paragraphs to be
changed to a new heading level. The sprm is three bytes long and consists
of the sprm code and a one byte two's complement value.
<p>If pap.stc is &lt; 1 or > 9, sprmPIncLvl has no effect. Otherwise, if
the value stored in the byte has its highest order bit off, the value is
a positive difference which should be added to pap.istd and pap.lvl and
then pap.stc should be set to min(pap.istd, 9). If the byte value has its
highest order bit on, the value is a negative difference which should be
sign extended to a word and then subtracted from pap.istd and pap.lvl.
Then pap.stc should be set to max(1, pap.istd). sprmPIncLvl is only stored
in <b>grpprls</b> linked to a piece table.
<p>sprmPIlfo (opcode 0x460B) sets the pap.ilfo. Its argument, an ilfo,
is an index into the document's hpllfo, which contains the list data for
that paragraph, describing the appearance of the automatic number at the
beginning of the paragraph. A value of zero means that the paragraph is
not numbered, and a value of 2047 indicates that this paragraph came from
a pre-Word 97 file so the formatting information is still stored in the
pap.anld and the paragraph should be converted to Word 97 format.
<p>sprmPIlvl (opcode (0x260A) sets the pap.ilvl. It takes an index (0 through
8) which indicates which level of a multilevel list this paragraph belongs
to. For simple (one-level lists) or unnumbered paragraphs, this value should
always be zero.
<p>sprmPAnld (opcode ...) is currently only used for compatibility with
pre-Word 97 docs. It sets the pap.anld, which before Word 97 described
the automatic number at the beginning of any numbered paragraph. Now we
use it only long enough to put the data into the document's list table
(rglst) and set the pap.ilfo to point to the proper entry in the list table.
The pap.anld is only relavent if pap.ilfo is equal to 2047 (see sprmPIlfo
above).
<p>The sprmPChgTabsPapx (opcode 0xC60D) is a complex sprm that describes
changes in tab settings from the underlying style. It is only stored as
part of PAPXs stored in <b>FKPs</b> and in the <b>STSH</b>. It has the
following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>sprm</td>

<td>S16</td>

<td>opcode</td>
</tr>

<tr>
<td>cch</td>

<td>S8</td>

<td>count of bytes (not including sprm and cch)</td>
</tr>

<tr>
<td>itbdDelMax</td>

<td>S8</td>

<td>number of tabs to delete</td>
</tr>

<tr>
<td>rgdxaDel</td>

<td>int[itbdDelMax]</td>

<td>array of tab positions for which tabs should be deleted</td>
</tr>

<tr>
<td>itbdAddMax</td>

<td>S8</td>

<td>number of tabs to add</td>
</tr>

<tr>
<td>rgdxaAdd</td>

<td>int[itbdAddMax]</td>

<td>array of tab positions for which tabs should be added</td>
</tr>

<tr>
<td>rgtbdAdd</td>

<td>byte[itbdAddMax]</td>

<td>array of tab descriptors corresponding to rgdxaAdd</td>
</tr>
</table>

<p>When sprmPChgTabsPapx is interpreted, the rgdxaDel of the sprm is applied
first to the pap that is being transformed. This is done by deleting from
the pap the rgdxaTab entry and rgtbd entry of any tab whose rgdxaTab value
is equal to one of the rgdxaDel values in the sprm. It is guaranteed that
the entries in pap.rgdxaTab and the sprm's rgdxaDel and rgdxaAdd are recorded
in ascending dxa order.
<p>Then the rgdxaAdd and rgtbdAdd entries are merged into the pap's rgdxaTab
and rgtbd arrays so that the resulting pap rgdxaTab is sorted in ascending
order with no duplicates.
<p>sprmPNest (opcode 0x4610) causes its operand, a two-byte dxa value to
be added to pap.dxaLeft. If the result of the addition is less than 0,
0 is stored into pap.dxaLeft. It is used to shift the left indent of a
paragraph to the right or left. sprmPNest is only stored in <b>grpprls</b>
linked to a piece table.
<p>sprmPDyaLine (opcode 0x6412) moves a 4 byte LSPD structure into pap.lspd.
Two short fields are stored in this data structure. The first short in
the structure is named lspd.dyaLine and the second is named lspd.fMultLinespace.
When lspd.fMultLinespace is 0, the magnitude of lspd.dyaLine specifies
the amount of space that will be provided for lines in the paragraph in
twips. When lspd.dyaLine is positive, Word will ensure that AT LEAST the
magnitude of lspd.dyaLine will be reserved on the page for each line displayed
in the paragraph. If the height of a line becomes greater than lspd.dyaLine,
the size calculated for that line will be reserved on the page. When lspd.dyaLine
is negative, Word will ensure that EXACTLY the magnitude of lspd.dyaLine
(-lspd.dyaLine) will be reserved on the page for each line displayed in
the paragraph. When lspd.fMultLinespace is 1, Word will reserve for each
line the (maximal height of the line*lspd.dyaLine)/240.
<p>The sprmPChgTabs (opcode 0xC615) is a complex sprm which describes changes
tab settings for any paragraph within a piece. It is only stored as part
of a <b>grpprl</b> linked to a piece table. It has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>sprm</td>

<td>S16</td>

<td>opcode</td>
</tr>

<tr>
<td>cch</td>

<td>S8</td>

<td>count of bytes (not including sprm and cch)</td>
</tr>

<tr>
<td>itbdDelMax</td>

<td>S8</td>

<td>number of tabs to delete</td>
</tr>

<tr>
<td>rgdxaDel</td>

<td>int[itbdDelMax]</td>

<td>array of tab positions for which tabs should be deleted</td>
</tr>

<tr>
<td>rgdxaClose</td>

<td>int[itbdDelMax]</td>

<td>array of tolerances corresponding to rgdxaDel where each tolerance
defines an interval around corresponding rgdxaDel entry within which all
tabs should be removed</td>
</tr>

<tr>
<td>itbdAddMax</td>

<td>S8</td>

<td>number of tabs to add</td>
</tr>

<tr>
<td>rgdxaAdd</td>

<td>int[itbdAddMax]</td>

<td>array of tab positions for which tabs should be added</td>
</tr>

<tr>
<td>rgtbdAdd</td>

<td>byte[itbdAddMax]</td>

<td>array of tab descriptors corresponding to rgdxaAdd</td>
</tr>
</table>

<p>itbdDelMax and itbdAddMax are defined to be equal to 50. This means
that the largest possible instance of sprmPChgTabs is 354. When the length
of the sprm is greater than or equal to 255, the cch field will be set
equal to 255. When cch == 255, the actual length of the sprm can be calculated
as follows: length = 2 + itbdDelMax * 4 + itbdAddMax * 3.
<p>When sprmPChgTabs is interpreted, the rgdxaDel of the sprm is applied
first to the pap that is being transformed. This is done by deleting from
the pap the rgdxaTab entry and rgtbd entry of any tab whose rgdxaTab value
is within the interval [rgdxaDel[i] - rgdxaClose[i], rgdxaDel[i] + rgdxaClose[i]]
It is guaranteed that the entries in pap.rgdxaTab and the sprm's rgdxaDel
and rgdxaAdd are recorded in ascending dxa order.
<p>Then the rgdxaAdd and rgtbdAdd entries are merged into the pap's rgdxaTab
and rgtbd arrays so that the resulting pap rgdxaTab is sorted in ascending
order with no duplicates.
<p>The sprmPPc (opcode 0x261B) is a complex sprm which describes changes
in the pap.pcHorz and pap.pcVert. It is able to change both fields' contents
in parallel. It has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>S16</td>

<td></td>

<td></td>

<td>opcode</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td></td>

<td>S16</td>

<td>:4</td>

<td>F0</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcVert</td>

<td>S16</td>

<td>:2</td>

<td>0C</td>

<td>if pcVert ==3, pap.pcVert should not be changed. Otherwise, contains
new value of pap.pcVert.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcHorz</td>

<td>S16</td>

<td>:2</td>

<td>03</td>

<td>if pcHorz==3, pap.pcHorz should not be changed. Otherwise, contains
new value of pap.pcHorz.</td>
</tr>
</table>

<p>Length of sprmPPc is three bytes.
<p>sprmPPc is interpreted by moving pcVert to pap.pcVert if pcVert != 3
and by moving pcHorz to pap.pcHorz if pcHorz != 3. sprmPPc is stored in
PAPX FKPs and also in <b>grpprls</b> linked to piece table entries.
<p>sprmPPropRMark (opcode 0xC63F) is interpreted by moving the first parameter
byte to pap.fPropRMark, the next two bytes to pap.ibstPropRMark, and the
remaining four bytes to pap.dttmPropRMark.
<p>sprmPHugePapx is stored in PAPX FKPs in place of the grpprl of a PAPX
which would otherwise be too big to fit in an FKP (as of this writing,
488 bytes is the size of the largest PAPX which can fit in an FKP). The
parameter fc gives the location of the grpprl in the data stream. The first
word at that fc counts the number of bytes in the grpprl (not including
the byte count itself). A sprmPHugePapx should therefore only be found
in a PAPX FKP and should be the only sprm in that PAPX's grpprl.
<p>sprmCPicLocation (opcode 0x6A03) is used ONLY IN CHPX FKPs. This sprm
moves the 4-byte operand of the sprm into the chp.fcPic field. It simultaneously
sets chp.fSpec to 1. This sprm is also when the chp.lTagObj field that
is unioned with chp.fcPic is to be set for OLE objects.
<p>sprmCChs (opcode 0xEA08) is used to record a character set id for text
that was pasted into the Word document that used a character set different
than Word's default character set. When chp.fChsDiff is 0, the character
set used for a run of text is the default character set for the version
of Word that last saved the document. When chp.fChsDiff is 1, chp.chse
specifies the character set used for this run of text. This sprm's operand
is 3 bytes. When this sprm is interpreted, the first byte of the operand
is moved to chp.fChsDiff and the remaining word is moved to chp.chse.
<p>sprmCSymbol (opcode 0x6A09) is used to specify the font and the character
that will be used within that font to display a symbol character in Word.
This sprm's operand is 4 bytes. The first 2 hold the font code; the last
2 hold a character specifier. When this sprm is interpreted, the font code
is moved to chp.ftcSym and the character specifier is moved to chp.xchSym
and chp.fSpec is set to 1.
<p>sprmCIstdPermute (opcode 0xCA31) (which has the same format as sprmPIstdPermute
(opcode 0xC601)) is a complex sprm which is applied to a piece when the
style codes for character styles tagging character runs within a piece
must be mapped to other style codes. It has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>sprm</td>

<td>S16</td>

<td>opcode( ==0xCA31)</td>
</tr>

<tr>
<td>cch</td>

<td>S8</td>

<td>count of bytes (not including sprm and cch)</td>
</tr>

<tr>
<td>fLongg</td>

<td>S8</td>

<td>always 0</td>
</tr>

<tr>
<td>fSpare</td>

<td>S8</td>

<td>always 0</td>
</tr>

<tr>
<td>istdFirst</td>

<td>U16</td>

<td>index of first style in range to which permutation stored in rgistd
applies</td>
</tr>

<tr>
<td>istdLast</td>

<td>U16</td>

<td>index of last style in range to which permutation stored in rgistd
applies</td>
</tr>

<tr>
<td>rgistd[]</td>

<td>U16</td>

<td>array of istd entries that records the mapping of istds for text copied
from a source document to istds that exists in the destination document
after the text has been pasted</td>
</tr>
</table>

<p>To interpret sprmCIstdPermute, first check if chp.istd is greater than
the istdFirst recorded in the sprm and less than or equal to the istdLast
recorded in the sprm If not, the sprm has no effect. If it is, chp.istd
is set to rgstd[chp.istd - istdFirst] and any chpx stored in that rgstd
entry is applied to the chp. sprmCIstdPermute is only stored in <b>grpprls</b>
linked to a piece table. It should never be recorded in a CHPX.
<p>Note that it is possible that an istd may be recorded in the rgistd
that refers to a paragraph style. This will no harmful consequences since
the istd for a paragraph style should never be recorded in chp.istd.
<p>sprmCDefault (opcode 0x2A32) clears the fBold, fItalic, fOutline, fStrike,
fShadow, fSmallCaps, fCaps, fVanish, kul and ico fields of the chp to 0.
It was first defined for Word 3.01 and had to be backward compatible with
Word 3.00 so it is a variable length sprm whose count of bytes is 0. It
consists of the sprmCDefault opcode followed by a byte of 0. sprmCDefault
is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmCPlain (opcode 0x2A33) is used to make the character properties
of runs of text equal to the style character properties of the paragraph
that contains the text. When Word interprets this sprm, the style sheet
CHP is copied over the original CHP preserving the fSpec setting from the
original CHP. sprmCPlain is stored only in <b>grpprls</b> linked to piece
table entries.
<p>sprms 0x0835 through 0x083C (sprmCFBold through sprmCFVanish) set single
bit properties in the CHP. When the parameter of the sprm is set to 0 or
1, then the CHP property is set to the parameter value.
<p>When the parameter of the sprm is 128, then the CHP property is set
to the value that is stored for the property in the style sheet. CHP When
the parameter of the sprm is 129, the CHP property is set to the negation
of the value that is stored for the property in the style sheet CHP. sprmCFBold
through sprmCFVanish are stored only in <b>grpprls</b> linked to piece
table entries.
<p>sprmCSizePos (opcode 0xEA3F) is a five-byte sprm consisting of the sprm
opcode and a three byte parameter. The sprm has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>S16</td>

<td></td>

<td></td>

<td>opcode</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>hpsSize</td>

<td>S16</td>

<td>:8</td>

<td>FF</td>

<td>when != 0, contains new size of chp.hps</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>cInc</td>

<td>S16</td>

<td>:7</td>

<td>FE</td>

<td>contains the number of font levels to increase or decrease size of
chp.hps as a twos complement value.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAdjust</td>

<td>S16</td>

<td>:1</td>

<td>01</td>

<td>when == 1, means that chp.hps should be adjusted up/down by one font
level for super/subscripting change</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>hpsPos</td>

<td>S16</td>

<td>:8</td>

<td>FF</td>

<td>when != 128, contains super/subscript position as a twos complement
number</td>
</tr>
</table>

<p>When Word interprets this sprm, if hpsSize != 0 then chp.hps is set
to hpsSize. If cInc is != 0, the cInc is interpreted as a 7 bit twos complement
number and the procedure described below for interpreting sprmCHpsInc is
followed to increase or decrease the chp.hps by the specified number of
levels. If hpsPos is != 128, then chp.hpsPos is set equal to hpsPos. If
fAdjust is on , hpsPos != 128 and hpsPos != 0 and the previous value of
chp.hpsPos == 0, then chp.hps is reduced by one level following the method
described for sprmCHpsInc. If fAdjust is on, hpsPos == 0 and the previous
value of chp.hpsPos != 0, then the chp.hps value is increased by one level
using the method described below for sprmCHpsInc.
<p>sprmCHpsInc(opcode 0x2A44) is a three-byte sprm consisting of the sprm
opcode and a one-byte parameter. Word keeps an ordered array of the font
sizes that are defined for the fonts recorded in the system file with each
font size transformed into an hps. The parameter is a one-byte twos complement
number. Word uses this number to calculate an index in the font size array
to determine the new hps for a run. When Word interprets this sprm and
the parameter is positive, it searches the array of font sizes to find
the index of the smallest entry in the font size table that is greater
than the current chp.hps.It then adds the parameter minus 1 to the index
and maxes this with the index of the last array entry. It uses the result
as an index into the font size array and assigns that entry of the array
to chp.hps.
<p>When the parameter is negative, Word searches the array of font sizes
to find the index of the entry that is less than or equal to the current
chp.hps. It then adds the negative parameter to the index and does a min
of the result with 0. The result of the min function is used as an index
into the font size array and that entry of the array is assigned to chp.hps.
sprmCHpsInc is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmCHpsPosAdj (opcode 0x2A46) causes the hps of a run to be reduced
the first time text is superscripted or subscripted and causes the hps
of a run to be increased when superscripting/subscripting is removed from
a run. The one byte parameter of this sprm is the new hpsPos value that
is to be stored in chp.hpsPos. If the new hpsPos is not equal 0 (meaning
that the text is to be super/subscripted), Word first examines the current
value of chp.hpsPos to see if it is equal to 0. If so, Word uses the algorithm
described for sprmCHpsInc to decrease chp.hps by one level. If the new
hpsPos == 0 (meaning the text is not super/subscripted), Word examines
the current chp.hpsPos to see if it is not equal to 0. If it is not (which
means text is being restored to normal position), Word uses the sprmCHpsInc
algorithm to increase chp.hps by one level. After chp.hps is adjusted,
the parameter value is stored in chp.hpsPos. sprmCHpsPosAdj is stored only
in <b>grpprls</b> linked to piece table entries.
<p>The parameter of sprmCMajority (opcode 0xCA47) is itself a list of character
sprms which encodes a criterion under which certain fields of the chp are
to be set equal to the values stored in a style's CHP. Bytes 0 and 1 of
sprmCMajority contains the opcode, byte 2 contains the length of the following
list of character sprms. . Word begins interpretation of this sprm by applying
the stored character sprm list to a standard chp. That chp has chp.istd
= istdNormalChar. chp.hps=20, chp.lid=0x0400 and chp.ftc = 4. Word then
compares fBold, fItalic, fStrike, fOutline, fShadow, fSmallCaps, fCaps,
ftc, hps, hpsPos, kul, qpsSpace and ico in the original CHP with the values
recorded for these fields in the generated CHP.. If a field in the original
CHP has the same value as the field stored in the generated CHP, then that
field is reset to the value stored in the style's CHP. If the two copies
differ, then the original CHP value is left unchanged. sprmCMajority is
stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmCHpsInc1 (opcode 0xCA4A) is used to increase or decrease chp.hps
by increments of 1. This sprm is interpreted by adding the two byte increment
stored as the opcode of the sprm to chp.hps. If this result is less than
8, the chp.hps is set to 8. If the result is greater than 32766, the chp.hps
is set to 32766.
<p>sprmCMajority50 (opcode 0xCA4C) has the same format as sprmCMajority
and is interpreted in the same way.
<p>sprmCPropRMark (opcode 0xCA57) is interpreted by moving the first parameter
byte to chp.fPropRMark, the next two bytes to chp.ibstPropRMark, and the
remaining four bytes to chp.dttmPropRMark.
<p>sprmCDispFldRMark (opcode 0xCA62) is interpreted by moving the first
parameter byte to chp.fDispFldRMark, the next two bytes to chp.ibstDispFldRMark,
the next four bytes to chp.dttmDispFldRMark, and the remaining 32 bytes
to chp.xstDispFldRMark.
<p>sprmCRgftc0 (opcode 0x4A4F), sprmcCRgftc1(opcode 0x4A50), and sprmCRgftc2
(opcode 0x4A4F) are used to specify the fonts that are available for use
with text. Rgftc0 specifies the font used for characters from U+0000 ->
U+007F. Rgftc1 specifies the font to be used for Far East characters, and
Rgftc2 specifies the font to be used for all other text. See appendix C
for details on how the font is calculated.
<p>sprmCRglid0 (opcode 0x486D) and sprmCRglid1 (opcode 0x486E) are used
to specify the languages that are available for use with the text in this
run. sprmCRglid1 specifies the language for Far East text, sprmCRglid0
specifies the language for all other text. See Appendix C for details on
the language is calculated.
<p>sprmCIdctHint (opcode 0x286F) specifies a script bias for the text in
the run. For Unicode characters that are shared between Far East and non-Far
East scripts, this property determines what font and language the character
will use. When this value is 0, text properties bias towards non-Far East
properties. When this value is 1, text properties bias towards Far East
properties. See Appendix C for details on the calculation of font and language
properties.
<p>sprmPicScale (opcode 0xCE01) is used to scale the x and y dimensions
of a Word picture and to set the cropping for each side of the picture.
The sprm begins with the two-byte opcode, followed by the length of the
parameter (always 12) stored in a byte. The 12-byte long operand consists
of an array of 6 two-byte integer fields. The 0th integer contains the
new setting for pic.mx. The 1st integer contains the new setting for pic.my.
The 2nd integer contains the new setting for pic.dxaCropLeft. The 3rd integer
contains the new setting for pic.dyaCropTop. The 4th integer contains the
new setting for pic.dxaCropRight. The 5th integer contains the new setting
of pic.dxaCropBottom. sprmPicScale is stored only in <b>grpprls</b> linked
to piece table entries.
<p>sprmSPropRMark (opcode 0xD227) is interpreted by moving the first parameter
byte to sep.fPropRMark, the next two bytes to sep.ibstPropRMark, and the
remaining four bytes to sep.dttmPropRMark.
<p>sprmSTextFlow (opcode 0x5033) represents the textflow to be applied
to this section. Possible values are:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>0</td>

<td>horizontal, <b>non-@font</b></td>
</tr>

<tr>
<td>1</td>

<td>top to bottom, @font</td>
</tr>

<tr>
<td>2</td>

<td>bottom to top,<b> non-@font</b></td>
</tr>

<tr>
<td>3</td>

<td>top to botton, <b>non-@font</b></td>
</tr>

<tr>
<td>4</td>

<td>horizontal, @-font</td>
</tr>
</table>

<p>sprmTDxaLeft (opcode 0x9601) is called to adjust the x position within
a column which marks the left boundary of text within the first cell of
a table row. This sprm causes a whole table row to be shifted left or right
within its column leaving the horizontal width and vertical height of cells
in the row unchanged. Bytes 0-1 of the sprm contains the opcode, and the
new dxa position, call it dxaNew, is stored as an integer in bytes 2 and
3. Word interprets this sprm by addingdxaNew - (rgdxaCenter[0] + tap.dxaGapHalf)
to every entry of tap.rgdxaCenter whose index is less than tap.itcMac.
sprmTDxaLeft is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmTDxaGapHalf (opcode 0x9602) adjusts the white space that is maintained
between columns by changing tap.dxaGapHalf. Because we want the left boundary
of text within the leftmost cell to be at the same location after the sprm
is applied, Word also adjusts tap.rgdxCenter[0] by the amount that tap.dxaGapHalf
changes. Bytes 0-1 of the sprm contains the opcode, and the new dxaGapHalf,
call it dxaGapHalfNew, is stored in bytes 2 and 3. When the sprm is interpreted,
the change between the old and new dxaGapHalf values, tap.dxaGapHalf -
dxaGapHalfNew, is added to tap.rgdxaCenter[0] and then dxaGapHalfNew is
moved to tap.dxaGapHalf. sprmTDxaGapHalf is stored in PAPXs and also in
<b>grpprls</b>
linked to piece table entries.
<p>sprmTTableBorders (opcode 0xD605) sets the tap.rgbrcTable. The sprm
is interpreted by moving the 24 bytes of the sprm's operand to tap.rgbrcTable.
<font color="#FF0000">Note that the 3rd byte is the length byte, beginning from
byte 4(!) the 6 BRCs are located.</font>
<p>sprmTDefTable10 (opcode0xD606) is an obsolete version of sprmTDefTable
(opcode 0xD608) that was used in WinWord 1.x. Its contents are identical
to those in sprmTDefTable, except that the TC structures contain the obsolete
structures BRC10s.
<p>sprmTDefTable (opcode 0xD608) defines the boundaries of table cells
(tap.rgdxaCenter) and the properties of each cell in a table (tap.rgtc).
Bytes 0 and 1 of the sprm contain its opcode. Bytes 2 and 3 store a two-byte
length of the following parameter. Byte 4 contains the number of cells
that are to be defined by the sprm, call it itcMac. When the sprm is interpreted,
itcMac is moved to tap.itcMac. itcMac cannot be larger than 32. In bytes
5 through 5+2*(itcMac + 1) -1 , is stored an array of integer dxa values
sorted in ascending order which will be moved to tap.rgdxaCenter. In bytes
5+ 2*(itcMac + 1) through byte 5+2*(itcMac + 1) + 10*itcMac - 1 is stored
an array of TC entries corresponding to the stored tap.rgdxaCenter. This
array is moved to tap.rgtc. sprmTDefTable is only stored in PAPXs.
<font color="#FF0000">Take care: First of all they don't always store the TCs (check
the length of the sprm), in this case we just add itcMac default TCs like OOo does.
Additionally the TC's size is not 10 anymore (Word 6), but 20.</font>
<p>sprmTDefTableShd (opcode 0xD609) is similar to sprmTDefTable, and compliments
it by defining the shading of each cell in a table (tap.rgshd). Bytes 0
and 1 of the sprm contain its opcode. Bytes 2 and 3 store a two-byte length
of the following parameter. Byte 4 contains the number of cells that are
to be defined by the sprm, call it itcMac. itcMac cannot be larger than
32. In bytes 5 through 5+2*(itcMac + 1) -1 , is stored an array of SHDs.
This array is moved to tap.rgshd. sprmTDefTable is only stored in PAPXs.
<font color="#FF0000">The above description is pure crap. Byte 3 is a length
count of the remaining sprm data, followed by a number of SHDs.</font>
<p>sprmTSetBrc (opcode 0xD620) allows the border definitions(BRCs) within
TCs to be set to new values. It has the following format:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sprm</td>

<td>S16</td>

<td></td>

<td></td>

<td>opcode 0xD620</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>count</td>

<td>S8</td>

<td></td>

<td></td>

<td>number of bytes for operand</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>itcFirst</td>

<td>S8</td>

<td></td>

<td></td>

<td>the index of the first cell that is to have its borders changed.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>itcLim</td>

<td>S8</td>

<td></td>

<td></td>

<td>index of the cell that follows the last cell to have its borders changed</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td></td>

<td>S16</td>

<td>:4</td>

<td>F0</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeRight</td>

<td>S16</td>

<td>:1</td>

<td>08</td>

<td>=1 when tap.rgtc[].brcRight is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeBottom</td>

<td>S16</td>

<td>:1</td>

<td>04</td>

<td>=1 when tap.rgtc[].brcBottom is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeLeft</td>

<td>S16</td>

<td>:1</td>

<td>02</td>

<td>=1 when tap.rgtc[].brcLeft is to be changed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChangeTop</td>

<td>S16</td>

<td>:1</td>

<td>01</td>

<td>=1 when tap.rgtc[].brcTop is to be changed</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>brc</td>

<td>BRC</td>

<td></td>

<td></td>

<td>new BRC value to be stored in TCs.</td>
</tr>
</table>

<p>This sprm changes the brc fields selected by the fChange* flags in the
sprm to the brc value stored in the sprm, for every tap.rgtc entry whose
index is greater than or equal to itcFirst and less than itcLim.sprmTSetBrc
is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmTInsert (opcode 0x7621) inserts new cell definitions in an existing
table's cell structure. Bytes 0 and 1 of the sprm contain the opcode. Byte
2 is the index within tap.rgdxaCenter and tap.rgtc at which the new dxaCenter
and tc values will be inserted. Call this index itcInsert. Byte 3 contains
a count of the cell definitions to be added to the tap, call it ctc. Bytes
4 and 5 contain the width of the cells that will be added, call it dxaCol.
If there are already cells defined at the index where cells are to be inserted,
tap.rgdxaCenter entries at or above this index must be moved to the entry
ctc higher and must be adjusted by adding ctc*dxaCol to the value stored.
The contents of tap.rgtc at or above the index must be moved 10*ctc bytes
higher in tap.rgtc. If itcInsert is greater than the original tap.itcMac,
itcInsert - tap.ctc columns beginning with index tap.itcMac must be added
of width dxaCol (loop from itcMac to itcMac+itcInsert-tap.ctc adding dxaCol
to the rgdxaCenter value of the previous entry and storing sum as dxaCenter
of new entry), whose TC entries are cleared to zeros. Beginning with index
itcInsert, ctc columns of width dxaCol must be added by constructing new
tap.rgdxaCenter and tap.rgtc entries with the newly defined rgtc entries
cleared to zeros. Finally, the number of cells that were added to the tap
is added to tap.itcMac. sprmTInsert is stored only in <b>grpprls</b> linked
to piece table entries.
<p>sprmTDelete (opcode 0x5622) deletes cell definitions from an existing
table's cell structure. Bytes 0 and 1of the sprm contain the opcode. Byte
2 contains the index of the first cell to delete, call it itcFirst. Byte
3 contains the index of the cell that follows the last cell to be deleted,
call it itcLim. sprmTDelete causes any rgdxaCenter and rgtc entries whose
index is greater than or equal to itcLim to be moved to the entry that
is itcLim - itcFirst lower, and causes tap.itcMac to be decreased by the
number of cells deleted. sprmTDelete is stored only in <b>grpprls</b> linked
to piece table entries.
<p>sprmTDxaCol (opcode 0x7623) changes the width of cells whose index is
within a certain range to be a certain value. Bytes 0 and 1of the sprm
contain the opcode. Byte 2 contains the index of the first cell whose width
is to be changed, call it itcFirst. Byte 3 contains the index of the cell
that follows the last cell whose width is to be changed, call it itcLim.
Bytes 4 and 5 contain the new width of the cell, call it dxaCol. This sprm
causes the itcLim - itcFirst entries of tap.rgdxaCenter to be adjusted
so that tap.rgdxaCenter[i+1] = tap.rgdxaCenter[i] + dxaCol. Any tap.rgdxaCenter
entries that exist beyond itcLim are adjusted to take into account the
amount added to or removed from the previous columns.sprmTDxaCol is stored
only in <b>grpprls</b> linked to piece table entries.
<p>sprmTMerge (opcode 0x5624) merges the display areas of cells within
a specified range. Bytes 0 and 1 of the sprm contain the opcode. Byte 2
contains the index of the first cell that is to be merged, call it itcFirst.
Byte 3 contains the index of the cell that follows the last cell to be
merged, call it itcLim. This sprm causes tap.rgtc[itcFirst].fFirstMerged
to be set to 1. Cells in the range whose index is greater than itcFirst
and less than itcLim have tap.rgtc[].fMerged set to 1. sprmTMerge is stored
only in <b>grpprls</b> linked to piece table entries.
<p>sprmTSplit (opcode 0x5625) splits the display areas of merged cells
into their originally assigned display areas. Bytes 0 and 1 of the sprm
contain the opcode. Byte 2 contains the index of the first cell that is
to be split, call it itcFirst. Byte 3 contains the index of the cell that
follows the last cell to be split, call it itcLim. This sprm clears tap.rgtc[].fFirstMerged
and tap.rgtc[].fMerged for all rgtc entries >= itcFirst and &lt; itcLim.
sprmTSplit is stored only in <b>grpprls</b> linked to piece table entries.
<p>SprmTSetBrc10 (opcode 0xD626) has the same format as SprmTSetBrc but
uses the old BRC10 structure.
<p>sprmTSetShd (opcode 0x7627) allows the shading definitions(SHDs) within
a tap to be set to new values. Bytes 0 and 1 of the sprm contain the opcode.
Byte 2 contains the index of the first cell whose shading is to be changed,
call it itcFirst. Byte 3 contains the index of the cell that follows the
last cell whose shading is to be changed, call it itcLim. Bytes 4 and 5
contain the SHD structure, call it shd. This sprm causes the itcLim - itcFirst
entries of tap.rgshd to be set to shd. sprmTSetShd is stored only in <b>grpprls</b>
linked to piece table entries.
<p>sprmTSetShdOdd (opcode 0x7628) is identical to sprmTSetShd, but it only
changes the rgshd for odd indices between itcFirst and. sprmTSetShdOdd
is stored only in <b>grpprls</b> linked to piece table entries.
<p>sprmTVertMerge (opcode 0xD62B) changes the vertical cell merge properties
for a cell in the tap.rgtc[]. Bytes 0 and 1 of the sprm contain the opcode.
Byte 2 contains the index of the cell whose vertical cell merge properties
are to be changed. Byte 3 codes the new vertical cell merge properties
for the cell, a 0 clears both fVertMerge and fVertRestart, a 1 sets fVertMerge
and clears fVertRestart, and a 3 sets both flags. sprmTVertMerge is stored
only in <b>grpprls</b> linked to piece table entries.
<p>sprmTVertAlign (opcode 0xD62C) changes the vertical alignment property
in the tap.rgtc[]. Bytes 0 and 1 of the sprm contain the opcode. Byte 2
contains the index of the first cell whose shading is to be changed, call
it itcFirst. Byte 3 contains the index of the cell that follows the last
cell whose shading is to be changed, call it itcLim. This sprm causes the
vertAlign properties of the itcLim - itcFirst entries of tap.rgtc[] to
be set to the new vertical alignment property contained in Byte 4. sprmTVertAlign
is stored only in <b>grpprls</b> linked to piece table entries.
<br><a NAME="22"></a>
<h2>
Complex File Format</h2>
There are some differences between the file format of a full saved document
and that of a fast saved document. In previous versions of Word, one of
the differences was the necessity of the "complex" table information. In
Word '97 and later, the fcClx always indicates the location of the "complex"
table information and it is always necessary to determine the location
and contents of text and properties. This arises due to unicode and unicode
compression.
<p>fcClx is the fc where the complex part of the file begins, and cbClx
is the size (in bytes) of the complex part. The complex part of the file
contains a group of <b>grpprl</b>s that encode formatting changes made
by the user and a piece table (<b>plcfpcd</b>). The piece table is needed
because the text of the document is not stored contiguously in the file
after a fast save.
<p>The complex part of a file (<b>CLX</b>) is composed of a number of variable-sized
blocks of data. Recorded first are any <b>grpprls</b> that may be referenced
by the <b>plcfpcd</b> (if the <b>plcfpcd</b> has no <b>grpprl</b> references,
no <b>grpprls</b> will be recorded) followed by the <b>plcfpcd</b>. Each
block in the complex part is prefaced by a <b>clxt</b> (<b>clx t</b>ype),
which is a 1-byte code, either 1 (meaning the block contains a <b>grpprl</b>)
or 2 (meaning this is the <b>plcfpcd</b>). A <b>clxtGrpprl (1)</b> is followed
by a 2-byte cb which is the count of bytes of the <b>grpprl. A clxtPlcfpcd
(2) is followed by a 4-byte lcb which is the count of bytes of</b> the
piece table. A full saved file will have no clxtGrpprl's. So the formats
of the two types of blocks are:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>clxt = 1</td>

<td>clxtGrpprl</td>
</tr>

<tr>
<td>cb</td>

<td>count of bytes in grpprl</td>
</tr>

<tr>
<td>grpprl</td>

<td>see "<b>Definitions</b>" for description of grpprl; a grpprl can contain
sprms modifying character, paragraph, table, section or picture properties</td>
</tr>
</table>

<p>or
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>clxt = 2</td>

<td>clxtPlcfpcd</td>
</tr>

<tr>
<td>lcb</td>

<td>count of bytes in piece table</td>
</tr>

<tr>
<td>plcfpcd</td>

<td>piece table</td>
</tr>
</table>

<p>The entire CLX would look like this, depending on the number of grpprl's:
<p>clxtGrpprl
<br>cb
<br>grpprl (0th grpprl)
<br>clxtGrpprl
<br>cb
<br>grpprl (1st grpprl)
<br>...
<br>clxtPlcfpcd
<br>cb
<br>plcfpcd
<p>When the <b>prm</b> in <b>pcd</b>s stored in the <b>plcfpcd</b>, contains
an igrpprl (index to a grpprl), the index stored is the order in which
that grpprl was stored in the <b>CLX</b>.
<br><a NAME="23"></a>
<h3>
Algorithm to determine the bounds of a paragraph containing a certain character
in a complex file</h3>
When a document is recorded in non-complex format, the bounds of the paragraph
that contains a particular character can be found by calculating the <b>FC</b>
coordinate of the character, searching the bin table to find an FKP page
that describes that <b>FC</b>, fetching that FKP, and then searching the
FKP to find the interval in the <b>rgfc</b> that encloses the character.
The bounds of the interval are the fcFirst and fcLim of the containing
paragraph. Every character greater than or equal to fcFirst and less than
fcLim is part of the containing paragraph.
<p>When a document is recorded in complex format, a piece that was originally
part of one paragraph can be copied or moved within a different paragraph.
To find the beginning of the paragraph containing a character in a complex
document, it's first necessary to search for the piece containing the character
in the piece table. Then calculate the <b>FC</b> in the file that stores
the character from the piece table information. Using the <b>FC</b>, search
the FCs FKP for the largest FC less than the character's FC, call it fcTest.
If the character at fcTest-1 is contained in the current piece, then the
character corresponding to that FC in the piece is the first character
of the paragraph. If that FC is before or marks the beginning of the piece,
scan a piece at a time towards the beginning of the piece table until a
piece is found that contains a paragraph mark. This can be done by using
the end of the piece FC, finding the largest FC in its FKP that is less
than or equal to the end of piece FC, and checking to see if the character
in front of the FKP FC (which must mark a paragraph end) is within the
piece. When such an FKP FC is found, the FC marks the first byte of paragraph
text.
<p>To find the end of a paragraph for a character in a complex format file,
again it is necessary to know the piece that contains the character and
the FC assigned to the character. Using the FC of the character, first
search the FKP that describes the character to find the smallest FC in
the rgfc that is larger than the character FC. If the FC found in the FKP
is less than or equal to the limit FC of the piece, the end of the paragraph
that contains the character is at the FKP FC minus 1. If the FKP FC that
was found was greater than the FC of the end of the piece, scan piece by
piece toward the end of the document until a piece is found that contains
a paragraph end mark. It's possible to check if a piece contains a paragraph
mark by using the FC of the beginning of the piece to search in the FKPs
for the smallest FC in the FKP rgfc that is greater than the FC of the
beginning of the piece. If the FC found is less than or equal to the limit
FC of the piece, then the character that ends the paragraph is the character
immediately before the FKP FC.
<p>A special procedure must be followed to locate the last paragraph of
the main document text when footnote or header/footer text is saved in
a Word file (i.e. when fib.ccpFtn != 0 or fib.ccpHdr != 0).
<p>In this case the CP of that paragraph mark is fib.ccpText + fib.ccpFtn
+ fib.ccpHdr + fib.ccpMcr + fib.ccpAtn and the limit CP of the entire plcfpcd
is fib.ccpText + fib.ccpFtn + fib.ccpHdr + fib.ccpMcr + fib.ccpAtn + 1.
<br><a NAME="24"></a>
<h3>
Algorithm to determine paragraph properties for a paragraph in a complex
file</h3>
Having found the index <b>i</b> of the FC in an FKP that marks the character
stored in the file immediately after the paragraph's paragraph mark, it
is necessary to use the word offset stored in the first byte of the fkp.rgbx[<b>i
- 1</b>] to find the PAPX for the paragraph. Using papx.istd to index into
the properties stored for the style sheet , the paragraph properties of
the style are copied to a local PAP. Then the grpprl stored in the PAPX
is applied to the local PAP, and papx.istd along with fkp.rgbx.phe are
moved into the local PAP. The process thus far has created a PAP that describes
what the paragraph properties of the paragraph were at the last full save.
Now it's necessary to apply any paragraph sprms that were linked to the
piece that contains the paragraph's paragraph mark. If pcd.prm.fComplex
is 0, pcd.prm contains 1 sprm which should only be applied to the local
PAP if it is a paragraph sprm. If pcd.prm.fComplex is 1, pcd.prm.igrpprl
is the index of a grpprl in the CLX. If that grpprl contains any paragraph
sprms, they should be applied to the local PAP. After applying all of the
sprms for the piece, the local PAP contains the correct paragraph property
values.
<br><a NAME="25"></a>
<h3>
Algorithm to determine table properties for a table row in a complex file</h3>
To determine the table properties for a table row in a complex file, scan
paragraph-by-paragraph toward the end of the table row, until a paragraph
is found that has pap.fTtp set to 1. This paragraph consists of a single
row end character. This row end character is linked to the table properties
of the row. To create the TAP for the table row, clear a local TAP to zeros.
Then the PAPX for the row end character must be fetched from an FKP, and
the table sprms that are stored in this PAPX must be applied to the local
TAP. The process thus far has created a TAP that describes what the table
properties of the table row were at the last full save. Now apply any table
sprms that were linked to the piece that contains the table row's row end
character. If pcd.prm.fComplex is 0, pcd.prm contains 1 sprm which should
be applied to the local TAP if it is a table sprm. If pcd.prm.fComplex
is 1, pcd.prm.igrpprl is the index of a grpprl in the CLX. If that grpprl
contains any table sprms, apply them to the local TAP. After all of the
sprms for the piece are applied, the local TAP contains the correct table
property values for the table row.
<br><a NAME="26"></a>
<h3>
Algorithm to determine the character properties of a character in a complex
file</h3>
It is first necessary to fetch the paragraph properties of the paragraph
that contains the character. The pap.istd of the fetched properties specifies
which style sheet entry provides the default character properties for the
character. The character properties recorded in the style sheet for that
style are copied into a local CHP. Then, the piece containing the character
is located in the piece table (plcfpcd) and the fc of the character is
calculated. Using the character's FC, the page number of the CHPX FKP that
describes the character is found by searching the bin table (hplcfbteChpx).
The CHPX FKP stored in that page is fetched and then the rgfc in the FKP
is searched to locate the bounds of the run of exception text that encompasses
the character. The CHPX for that run is then located within the FKP, and
the CHPX is applied to the contents of the local CHP. The process thus
far has created a CHP that describes what the character properties of the
character were at the last full save. Now apply any character sprms that
were linked to the piece that contains the character. If pcd.prm.fComplex
is 0, pcd.prm contains 1 sprm which should be applied to the local CHP
if it is a character sprm. If pcd.prm.fComplex is 1, pcd.prm.igrpprl is
the index of a grpprl in the CLX. If that grpprl contains any character
sprms, apply them to the local CHP. After applying all of the sprms for
the piece, the local CHP contains the correct properties for the character.
<p>Characters that are within the same piece, same paragraph, and same
run of exception text are guaranteed to have the same properties. This
fact can be used to construct a scanner that can return the limit CPs and
properties of a sequence of characters that all have the same properties.
<br><a NAME="27"></a>
<h3>
Algorithm to determine the section properties of a section in a complex
file</h3>
To determine which section a character belongs to and what its section
properties are, it is necessary to use the CP of the character to search
the <b>plcfsed</b> for the index <b>i</b> of the largest CP that is less
than or equal to the character's CP. plcfsed.rgcp[<b>i</b>] is the CP of
the first character of the section and plcfsed.rgcp[<b>i+1</b>] is the
CP of the character following the section mark that terminates the section
(call it cpLim). Then retrieve plcfsed.rgsed[<b>i</b>]. The FC in this
SED gives the location where the SEPX for the section is stored. Then create
a local SEP with default section properties. If the sed.fc != 0xFFFFFFFF,
then the sprms within the SEPX that is stored at offset sed.fc must be
applied to the local SEP. The process thus far has created a SEP that describes
what the section properties of the section at the last full save. Now apply
any section sprms that were linked to the piece that contains the section's
section mark. If pcd.prm.fComplex is 0, pcd.prm contains 1 sprm which should
be applied to the local SEP if it is a section sprm. If pcd.prm.fComplex
is 1, pcd.prm.igrpprl is the index of a grpprl in the CLX. If that grpprl
contains any section sprms, they should be applied to the local SEP. After
applying all of the section sprms for the piece , the local SEP contains
the correct section properties.
<br><a NAME="28"></a>
<h3>
Algorithm to determine the pic of a picture in a complex file.</h3>
The picture sprms contained in the prm's grpprl apply to any picture characters
within the piece that have their chp.fSpec character == fTrue. The picture
properties for a picture (the PIC described in the Structure Definitions)
are derived by fetching the PIC stored with the picture and applying to
that PIC any picture sprms linked to the piece containing the picture special
character.
<br><a NAME="29"></a>
<h2>
Footnotes &amp; Endnotes</h2>
In Word the text of footnotes and endnotes is anchored to a particular
position within the document's main text , the location of its footnote/endnote
reference. The following discussion only describes footnotes, with endnotes
being handled identically except that the endnote data structures contain
the "edn" abbreviation where footnote data structures contain the "fnd"
abbreviation. There is a structure referenced by the fib, the plcffndRef,
which records the locations of the footnote references within the main
text address space and another structure referenced by the fib, the plcffndTxt,
which records the beginning locations of corresponding footnote text within
the footnote text address space . The footnote text characters in a full
saved file begin at offset fib.fcMin + fib.ccpText and extends till fib.fcMin
+ fib.ccpText + fib.ccpFtn. In a complex fast-saved document , the footnote
text begins at CP fib.ccpText and extends till fib.ccpText + fib.ccpFtn.
To find the location of the <b>ith</b> footnote reference in the main text
address space, look up the <b>ith</b> entry in the plcffndRef and find
the location of the text corresponding to the reference within the footnote
text address space by looking up the <b>ith</b> entry in the plcffndTxt.
<p>When there are <b>n</b> footnotes, the plcffndTxt structure consists
of <b>n+2</b> CP entries. The CP entries mark the beginning character position
within the footnote text address space of the footnote text for the footnotes
defined for the file. The beginning CP of the text of the <b>ith</b> footnote
is the <b>ith</b> CP within the plcffndTxt. The limit CP of the text of
the <b>ith</b> footnote is the <b>i+1st</b> CP within the plcffndTxt.
<p>The last character of footnote text for a footnote (i.e. the character
at limit CP - 1) is always a paragraph end(ASCII 13). If there are <b>n</b>
footnotes, the <b>n+2nd</b> CP entry value is always 1 greater than the
<b>n+1st</b>
CP entry value. A paragraph end (ASCII 13) is always stored at the file
position marked by the <b>n+1st</b> CP value.
<p>When there are <b>n</b> footnotes, the plcffndRef structure consists
of <b>n+1</b> CP entries followed by <b>n</b> integer flags, named fAuto.
The <b>ith</b> CP in the plcffndRef corresponds to the <b>ith</b> fAuto
flag. The CP entries give the locations of footnote references within the
main text address space. The <b>n+1th</b> CP entry contains the value fib.ccpText
+ fib.ccpFtn + fib.ccpHdr + 1. The fAuto flag contains 1 whenever the footnote
reference name is auto-generated by Word.
<p>When a footnote reference name is automatically generated by Word, Word
generates the name by adding 1 to the index number of the reference in
the plcffndRef and translating that number to ASCII text. When the footnote
reference is auto generated, the character at the main text CP position
for the footnote reference should be a footnote reference character (ASCII
5) which has a chp recorded with chp.fSpec = 1.
<p>The number of footnotes stored in a Word binary file can be found by
dividing fib.cbPlcffndTxt by 4 and subtracting 1.
<font color="#ff0000">
<p>Now the real stuff, because all the documentation above seems to be outdated.
Footnotes (and endnotes, I'll only talk about footnotes here) apparently follow the
following additional rules:</p>
<ul>
<li>The DOP contains valuable information about the position and apperarance of footnotes.
    The interesting fields are fpc (0x00), rncFtn (0x02), nFtn (0x02) and also rncEdn (0x34),
    nEdn (0x34), epc (0x35), nfcFtnRef (0x36), nfcEdnRef (0x36), and nfcFtnRef2 (0x1ec),
    and nfcEdnRef2 (0x1ee). Most of these fields care about autonumbered footnotes only!</li>
<li>Apart from autonumbered footnotes you can also have footnotes with custom labels. This
    turns out to be a nasty hack inside Word, but well. The first character of the label
    is recorded in the plcffndRef and the character style of the text gets changed for the
    whole label. Inside the footnote the character style also changes, but it's not easy to
    figure out the boundaries of such a label, as the user may change the text and the formatting.
    Due to that wv2 doesn't even try to do that and leaves it up to the consumer.</li>
</ul></font>
<a NAME="30"></a>
<h2>
Headers and Footers</h2>
The header and footer text characters in a full saved file begin at offset
fib.fcMin + fib.ccpText + fib.ccpFtn and extend till fib.fcMin + fib.ccpText
+ fib.ccpFtn + fib.ccpHdr. In a complex fast-saved document , the footnote
text begins at CP fib.ccpText + fib.ccpFtn and extends till fib.ccpText
+ fib.ccpFtn + fib.ccpHdr. The <b>plcfhdd</b>, a table whose location and
length within the file is stored in fib.fcPlcfhdd and fib.cbPlcfhdd, describes
where the text of each header/footer begins. If there are <b>n</b> headers/footers
stored in the Word file, the plcfhdd consists of <b>n + 2</b> CP entries.
The beginning CP of the <b>ith</b> header/footer is the <b>ith</b> CP in
the plcfhdd. The limit CP (the CP of character 1 position past the end
of a header/footer) of the <b>ith</b> header/footer is the <b>i + 1 st</b>
CP in the plcfhdd. Note that at the limit CP - 1, Word always places a
chEop as a placeholder which is never displayed as part of the header/footer.
This allows Word to change an existing header/footer to be empty.
<p>If there are <b>n</b> header/footers, the <b>n+2nd</b> CP entry value
is always 1 greater than the <b>n+1st</b> CP entry value. A paragraph end
(ASCII 13) is always stored at the file position marked by the <b>n+1st</b>
CP value.
<p>The transformation in a full saved file from a header/footer CP to an
offset from the beginning of a file (fc) is fc = fib.fcMin + ccpText +
ccpFtn + cp.
<p>In Word, headers/footers can be defined for a document that:
<ul>
<li>
will act as a separator between main text and footnote text</li>

<li>
will print below footnote text on a page when footnote text must be continued
on a succeeding page (continuation separator)</li>

<li>
will print above footnote text on a page when the text must be continued
from a previous page (continuation notice)</li>

<li>
will act as a separator between main text and endnote text</li>

<li>
will print below endnote text on a page when endnote text must be continued
on a succeeding page (continuation separator)</li>

<li>
will print above endnote text on a page when the text must be continued
from a previous page (continuation notice)</li>
</ul>
Also for each section defined for the document, distinct headers can be
defined for printing on odd-numbered/right facing pages, even-numbered
/left facing pages and the first page of a section. Similarly for each
document section, distinct footers can be defined for printing on odd-numbered/right
facing pages, even-numbered/left facing pages and the first page of a section.
<p>The <b>plcfhdd</b> contains an entry for each kind of header or footer.
(The <b>grpfIhdt</b> is no longer used to find entries in the <b>plcfhdd</b>.)
Indices in the <b>plcfhdd</b> are as follows:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>0</td>

<td>header for even pages</td>
</tr>

<tr>
<td>1</td>

<td>header for odd pages</td>
</tr>

<tr>
<td>2</td>

<td>footer for even pages</td>
</tr>

<tr>
<td>3</td>

<td>footer for odd pages</td>
</tr>

<tr>
<td>4</td>

<td>header for first page of section</td>
</tr>

<tr>
<td>5</td>

<td>footer for first page of section</td>
</tr>

<tr>
<td>6</td>

<td>footnote separator</td>
</tr>

<tr>
<td>7</td>

<td>footnote continuation separator</td>
</tr>

<tr>
<td>8</td>

<td>footnote continuation notice</td>
</tr>

<tr>
<td>9</td>

<td>endnote separator</td>
</tr>

<tr>
<td>10</td>

<td>endnote continuation separator</td>
</tr>

<tr>
<td>11</td>

<td>endnote continuation notice</td>
</tr>
</table>
<a NAME="31"></a>
<h2>
Page Table</h2>
Page table information is optional data which is not always stored in a
Word binary file. It may be stored for the main text, footnote text and
endnote text. The fib contains three FCPGD structures (fcpgdMother, fcpgdFtn,
fcpgdEdn) which point to where the data is stored. Each fcpgd points to
a PLF of PGD structures and a PLCF of BKD structures. The PLF of PGD descriptors
contains n entries where n is the number of pages in the associated text
stream. The PLC of BKDs contains >= n entries where each entry describes
a single break (page break or otherwise) within the text stream. Each BKD
is associated with a PGD and contains an ipgd which is an index into the
PLF of PGDs. To find the CP range of a given page, traverse the BKDs searching
for the first and last BKD which refer to the given page. The CP range
of these BKDs is the CP range of the page.
<p>Third-party creators of Word files should not attempt to create fcpgd
structures. They can only be created properly using Word's page layout
routines. If a Word document is edited in any way, the fcpgds in the fib
should be filled with 0s.
<br><a NAME="32"></a>
<h2>
Glossary Files</h2>
A Word glossary file is a normal Word binary file with two supplemental
files, the <b>sttbfglsy,</b> the<b> sttbglsystyle</b> and the<b> plcfglsy</b>,
also stored in the file. The <b>sttbfglsy</b> contains a list of the names
of glossary entries, the <b>sttbglsystyle</b> contains a list of the stylenames
for every autotext entry, and the <b>plcfglsy</b> contains a table of beginning
positions within the text address space of the file of the text of glossary
entries.
<p>The <b>sttbfglsy</b> begins with an integer count of bytes of the size
of the sttbfglsy (includes the size of the integer count of bytes). If
there are <b>n</b> glossary entries defined, there will follow <b>n</b>
Pascal-type strings (string preceded by length byte) concatenated one after
the other which store glossary entry names. The glossary entry names must
be sorted in case-insensitive ascending order. (i.e. <b>a</b> and <b>A</b>
are treated as equal). Also the names <b>date</b> and<b> time</b> must
be included in the list of names. The name of the <b>ith</b> glossary entry
is the <b>ith</b> name defined in the <b>sttbfglsy. </b>The extra field
in each entry contains an index on the <b>sttbglsystyle</b> that indicates
the stylename of the first paragraph in <b>plcfglsy</b>.
<p>The <b>sttbglsystyle</b> is not sorted and has no duplicates. Each entry
has an extra field indicating how many autotext entries have that style.
<p>If there are <b>n</b> glossary entries, the <b>plcfglsy</b>, will consist
of <b>n+2</b> CP entries. The <b>ith</b> CP entry will contain the location
of the beginning of the text for the <b>ith</b> glossary entry. The <b>i+1st</b>
CP entry will contain the limit CP of the <b>ith</b> glossary entry. The
character at a CP position of limit CP - 1 is always a paragraph mark.
The <b>n+2nd</b> CP entry always contains fib.ccpText + fib.ccpFtn + fib.ccpHdr
+ 1 if there are headers, footers or footnotes stored in the glossary and
contains fib.ccpText + fib.ccpFtn + fib.ccpHdr otherwise. The <b>n+1st</b>
CP entry is always 1 less than the value of the <b>n+2nd</b> entry.
<p>The text for the <b>time</b> and <b>date</b> entries will always be
a single paragraph mark (ASCII 13).
<br><a NAME="33"></a>
<h2>
Routing Slip</h2>
A routing slip is stored in the main document stream as an RS (Routing
Slip) structure followed by a set of variable length data. After the RS
are 4 null terminated strings. Each string is preceded by a short containing
the string length (including the null terminator). The strings are: the
subject, the message text, status and title. Following these strings are
a variable number (rs.cRecip) of Routing Recipient (RR) records. Each RR
is immediately followed by a variable number (rr.cb) of bytescontaining
private data, which is in turn followed by a null terminated string containing
the recipient name.
<br><a NAME="34"></a>
<h2>
Autosummary</h2>
For a document for which AutoSummary View is active (specified in the ASUMYI),
the plcfasumy records the result of the last AutoSummary analysis. Each
ASUMY in the PLCF gives the AutoSummary level for the text starting at
the corresponding CP. The level must be non-negative and no greater than
the upper bound specified in the ASUMYI. The ASUMYI specifies the current
summary view level. In emphasize view mode, all text at and below the current
summary view level is highlighted. In reduce view mode, all text above
the current summary view level is hidden.
<br><a NAME="35"></a>
<h2>
STTBFASSOC (Table of Associated Strings)</h2>
The following are indices into a table of associated strings:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>ibst</td>

<td>index</td>

<td>description</td>
</tr>

<tr>
<td>ibstAssocFileNext</td>

<td>0</td>

<td>unused</td>
</tr>

<tr>
<td>ibstAssocDot</td>

<td>1</td>

<td>filename of associated template</td>
</tr>

<tr>
<td>ibstAssocTitle</td>

<td>2</td>

<td>title of document</td>
</tr>

<tr>
<td>ibstAssocSubject</td>

<td>3</td>

<td>subject of document</td>
</tr>

<tr>
<td>ibstAssocKeyWords</td>

<td>4</td>

<td>keywords of document</td>
</tr>

<tr>
<td>ibstAssocComments</td>

<td>5</td>

<td>comments of document</td>
</tr>

<tr>
<td>ibstAssocAuthor</td>

<td>6</td>

<td>author of document</td>
</tr>

<tr>
<td>ibstAssocLastRevBy</td>

<td>7</td>

<td>name of person who last revised the document</td>
</tr>

<tr>
<td>ibstAssocDataDoc</td>

<td>8</td>

<td>filename of data document</td>
</tr>

<tr>
<td>ibstAssocHeaderDoc</td>

<td>9</td>

<td>filename of header document</td>
</tr>

<tr>
<td>ibstAssocCriteria1</td>

<td>10</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria2</td>

<td>11</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria3</td>

<td>12</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria4</td>

<td>13</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria5</td>

<td>14</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria6</td>

<td>15</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocCriteria7</td>

<td>16</td>

<td>packed string used by print merge record selection</td>
</tr>

<tr>
<td>ibstAssocMax</td>

<td>17</td>

<td>maximum number of strings in string table</td>
</tr>
</table>

<p>The format of the ibstAssocCriteriaX strings are as follows:
<pre>int&nbsp;&nbsp; cbIbstAssoc:8;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BYTE 0&nbsp; size of ibstAssocCriteriaX string
int&nbsp;&nbsp; fCompOr:1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BYTE 1&nbsp; set if cond is an or cond
int&nbsp;&nbsp; iCompOp:7;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // BYTE 1&nbsp; index of Comparison Operator
char&nbsp; stMergeField[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // Name of MergeField
char&nbsp; stCompInfo[];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; // User Supplied Comparison Information</pre>
Both stMergeField and stCompInfo are variable length character arrays preceded
by a length byte.
<br><a NAME="36"></a>
<h2>
Structure Definitions</h2>
<a NAME="37"></a>
<h3>
Autonumbered List Data Descriptor (ANLD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>nfc</td>

<td>U8</td>

<td></td>

<td></td>

<td>number format code
<br>0 Arabic numbering (1, 2, 3, ...)
<br>1 Upper case Roman (I, II, III, ...)
<br>2 Lower case Roman (i, ii, iii, ...)
<br>3 Upper case Letter (A, B, C, ...)
<br>4 Lower case letter (a, b, c, ...)
<br>5 Ordinal (1., 2., 3., ...)
<br>6 Numbered (One, Two, Three, ...)
<br>7 Ordinal (text) (First, Second, Third, ...)
<br>22 Leading Zero (01, 02,..., 09, 10, 11,..., 99, 100, 101,...)
<br>23 Bullet (check the character code in the text)</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>cxchTextBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>offset into anld.rgxch that is the limit of the text that will be displayed
as the prefix of the autonumber text</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cxchTextAfter</td>

<td>U8</td>

<td></td>

<td></td>

<td>anld.cxchTextBefore will be the beginning offset of the text in the
anld.rgxch that will be displayed as the suffix of an autonumber. The sum
of anld.cxchTextBefore + anld.cxchTextAfter will be the limit of the autonumber
suffix in anld.rgch</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>jc</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>justification code
<br>0 left justify
<br>1 center
<br>2 right justify
<br>3 left and right justify</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrev</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, number generated will include previous levels (used for legal
numbering)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHang</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>when ==1, number will be displayed using a hanging indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetBold</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>when ==1, boldness of number will be determined by anld.fBold.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetItalic</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>when ==1, italicness of number will be determined by anld.fItalic</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>when ==1, anld.fSmallCaps will determine whether number will be displayed
in small caps or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetCaps</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>when ==1, anld.fCaps will determine whether number will be displayed
capitalized or not</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fSetStrike</td>

<td>U8</td>

<td>:1</td>

<td>01</td>

<td>when ==1, anld.fStrike will determine whether the number will be displayed
using strikethrough or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetKul</td>

<td>U8</td>

<td>:1</td>

<td>02</td>

<td>when ==1, anld.kul will determine the underlining state of the autonumber.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrevSpace</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, autonumber will be displayed with a single prefixing space
character</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>determines boldness of autonumber when anld.fSetBold == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>determines italicness of autonumber when anld.fSetItalic == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>determines whether autonumber will be displayed using small caps when
anld.fSetSmallCaps == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetCaps
== 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetStrike
== 1.</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>kul</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>determines whether autonumber will be displayed with underlining when
anld.fSetKul == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>F1</td>

<td>color of autonumber</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>ftc</td>

<td>S16</td>

<td></td>

<td></td>

<td>font code of autonumber</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>hps</td>

<td>U16</td>

<td></td>

<td></td>

<td>font half point size (or 0=auto)</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iStartAt</td>

<td>U16</td>

<td></td>

<td></td>

<td>starting value (0 to 65535)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>dxaIndent</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of prefix text (same as indent)</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaSpace</td>

<td>U16</td>

<td></td>

<td></td>

<td>minimum space between number and paragraph</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>fNumber1</td>

<td>U8</td>

<td></td>

<td></td>

<td>number only 1 item per table cell</td>
</tr>

<tr>
<td>17</td>

<td>11</td>

<td>fNumberAcross</td>

<td>U8</td>

<td></td>

<td></td>

<td>number across cells in table rows(instead of down)</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>fRestartHdn</td>

<td>U8</td>

<td></td>

<td></td>

<td>restart heading number on section boundary</td>
</tr>

<tr>
<td>19</td>

<td>13</td>

<td>fSpareX</td>

<td>U8</td>

<td></td>

<td></td>

<td>unused( should be 0)</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>rgxch</td>

<td>XCHAR[32]</td>

<td></td>

<td></td>

<td>characters displayed before/after autonumber</td>
</tr>
</table>

<p>cbANLD (count of bytes of ANLD) is 84 (decimal), 54(hex).
<p><a NAME="39"></a>
<h3>
Autonumber Level Descriptor (ANLV)</h3>
<!-- sizeOf="16" -->

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>nfc</td>

<td>U8</td>

<td></td>

<td></td>

<td>number format code
<br>0 Arabic numbering
<br>1 Upper case Roman
<br>2 Lower case Roman
<br>3 Upper case Letter
<br>4 Lower case letter
<br>5 Ordinal</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>cxchTextBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>offset into anld.rgxch that is the limit of the text that will be displayed
as the prefix of the autonumber text</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cxchTextAfter</td>

<td>U8</td>

<td></td>

<td></td>

<td>anld.cxchTextBefore will be the beginning offset of the text in the
anld.rgxch that will be displayed as the suffix of an autonumber. The sum
of anld.cxchTextBefore + anld.cxchTextAfter will be the limit of the autonumber
suffix in anld.rgxch</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>jc</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>justification code
<br>0 left justify
<br>1 center
<br>2 right justify
<br>3 left and right justify</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrev</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, number generated will include previous levels (used for legal
numbering)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHang</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>when ==1, number will be displayed using a hanging indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetBold</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>when ==1, boldness of number will be determined by anld.fBold.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetItalic</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>when ==1, italicness of number will be determined by anld.fItalic</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>when ==1, anld.fSmallCaps will determine whether number will be displayed
in small caps or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetCaps</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>when ==1, anld.fCaps will determine whether number will be displayed
capitalized or not</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fSetStrike</td>

<td>U8</td>

<td>:1</td>

<td>01</td>

<td>when ==1, anld.fStrike will determine whether the number will be displayed
using strikethrough or not.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSetKul</td>

<td>U8</td>

<td>:1</td>

<td>02</td>

<td>when ==1, anld.kul will determine the underlining state of the autonumber.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrevSpace</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when ==1, autonumber will be displayed with a single prefixing space
character</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>determines boldness of autonumber when anld.fSetBold == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>10</td>

<td>determines italicness of autonumber when anld.fSetItalic == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>20</td>

<td>determines whether autonumber will be displayed using small caps when
anld.fSetSmallCaps == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>40</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetCaps
== 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>determines whether autonumber will be displayed using caps when anld.fSetStrike
== 1.</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>kul</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>determines whether autonumber will be displayed with underlining when
anld.fSetKul == 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>F1</td>

<td>color of autonumber</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>ftc</td>

<td>S16</td>

<td></td>

<td></td>

<td>font code of autonumber</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>hps</td>

<td>U16</td>

<td></td>

<td></td>

<td>font half point size (or 0=auto)</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iStartAt</td>

<td>U16</td>

<td></td>

<td></td>

<td>starting value (0 to 65535)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>dxaIndent</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of prefix text (same as indent)</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaSpace</td>

<td>U16</td>

<td></td>

<td></td>

<td>minimum space between number and paragraph</td>
</tr>
</table>

<p>cbANLV (count of bytes of ANLV) is 16 bytes (decimal), 10 bytes (hex).
<br><a NAME="40"></a>
<h3>
AutoSummary Analysis (ASUMY)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>lLevel</td>

<td>S32</td>

<td></td>

<td></td>

<td>AutoSummary level</td>
</tr>
</table>

<p>cbASUMY (count of bytes of ASUMY) is 4 bytes.
<br><a NAME="41"></a>
<h3>
AutoSummary Info (ASUMYI)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fValid</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>true iff the ASUMYI is valid</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fView</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>true iff AutoSummary View is active</td>
</tr>

<tr>
<td></td>

<td></td>

<td>iViewBy</td>

<td>U16</td>

<td>:2</td>

<td>000C</td>

<td>Display method for AutoSummary View:
<br>0 = Emphasize in current doc
<br>1 = Reduce doc to summary
<br>2 = Insert into doc
<br>3 = Show in new document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUpdateProps</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>true if we should update File Properties summary information after
the next summarization</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_5</td>

<td>U16</td>

<td>:11</td>

<td>FFE0</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>wDlgLevel</td>

<td>S16</td>

<td></td>

<td></td>

<td>Dialog summary level</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>lHighestLevel</td>

<td>S32</td>

<td></td>

<td></td>

<td>upper bound for lLevel for sentences in this document</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>lCurrentLevel</td>

<td>S32</td>

<td></td>

<td></td>

<td>show document sentences at or below this level</td>
</tr>
</table>

<p>cbASUMYI (count of bytes of ASUMYI) is 12 bytes (decimal), C bytes (hex).
<br><a NAME="38"></a>
<h3>
AnnoTation Reference Descriptor (ATRD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>xstUsrInitl</td>

<td>XCHAR[10]</td>

<td></td>

<td></td>

<td>pascal-style string holding initials of annotation author</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>ibst</td>

<td>S16</td>

<td></td>

<td></td>

<td>index into GrpXstAtnOwners</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>ak</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>unused</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused22_2</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>unused</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>grfbmc</td>

<td>U16</td>

<td></td>

<td></td>

<td>unused</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>lTagBkmk</td>

<td>S32</td>

<td></td>

<td></td>

<td>when not -1, this tag identifies the annotation bookmark that locates
the range of CPs in the main document which this annotation references.</td>
</tr>
</table>

<p>cbATRD (count of bytes of ATRD) is 30 (decimal), 1E(hex).
<br><a NAME="43"></a>
<h3>
BreaK Descriptor (BKD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ipgd</td>

<td>S16</td>

<td></td>

<td></td>

<td>except in textbox BKD, index to <b>PGD</b> in <b>plfpgd</b> that describes
the page this break is on. Note: different behavior in textboxes! Check
Version 1.9 or earlier for the "original" version (werner)</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>dcpDepend</td>

<td>S16</td>

<td></td>

<td></td>

<td>number of cp's considered for this break; note that the CP's described
by cpDepend in this break reside in the next BKD</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>icol</td>

<td>U16</td>

<td>:8</td>

<td>00FF</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTableBreak</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>when 1, this indicates that this is a table break.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColumnBreak</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>when 1, this indicates that this is a column break.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMarked</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>used temporarily while word is running.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>in textbox BKD, when == 1 indicates cpLim of this textbox is not valid</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTextOverflow</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>in textbox BKD, when == 1 indicates that text overflows the end of
this textbox</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_13</td>

<td>U16</td>

<td>:3</td>

<td>E000</td>

<td></td>
</tr>
</table>

<p>cbBKD (count of bytes of BKD) is 6.
<br><a NAME="44"></a>
<h3>
BooKmark First descriptor (BKF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ibkl</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to <b>BKL</b> entry in <b>plcfbkl</b> that describes the ending
position of this bookmark in the <b>CP</b> stream.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>itcFirst</td>

<td>U16</td>

<td>:7</td>

<td>007F</td>

<td>when bkf.fCol is 1, this is the index to the first column of a table
column bookmark.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPub</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>when 1, this indicates that this bookmark is marking the range of a
Macintosh Publisher section.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>itcLim</td>

<td>U16</td>

<td>:7</td>

<td>7F00</td>

<td>when bkf.fCol is 1, this is the index to limit column of a table column
bookmark.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCol</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>when 1, this bookmark marks a range of columns in a table specified
by [bkf.itcFirst, bkf.itcLim).</td>
</tr>
</table>

<p>cbBKF (count of bytes of BKF) is 4.
<br><a NAME="45"></a>
<h3>
BooKmark Lim descriptor (BKL)</h3>
The <b>BKL</b> is no longer stored in the <b>plcfbkl</b> or <b>plcfatnbkl</b>,
and is instead reconstructed from the <b>plcfbkf</b> or <b>plcfatnbkf</b>
when the file is opened.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ibkf</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to <b>BKF</b> entry in <b>plcfbkf</b> that describes the beginning
position of this bookmark in the <b>CP</b> stream. If the bkl.ibkf is negative,
add on the number of bookmarks recorded in the hplcbkf to the bkl.ibkf
to calculate the index to the BKF that corresponds to this entry.</td>
</tr>
</table>

<p>cbBKL (count of bytes of BKL) is 2.
<br><a NAME="46"></a>
<h3>
Border Code (BRC)</h3>
<!-- sizeOf="4" -->
The <b>BRC</b> is a substructure of the <b>CHP, PAP, PIC, SEP, TAP</b>
and <b>TC.</b> See also the obsolete BRC10 structure.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dptLineWidth</td>

<td>U16</td>

<td>:8</td>

<td>00FF</td>

<td>width of a single line in 1/8 pt, max of 32 pt.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>brcType</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>border type code:
<br>0 none
<br>1 single
<br>2 thick
<br>3 double
<br>5 hairline
<br>6 dot
<br>7 dash large gap
<br>8 dot dash
<br>9 dot dot dash
<br>10 triple
<br>11 thin-thick small gap
<br>12 thick-thin small gap
<br>13 thin-thick-thin small gap
<br>14 thin-thick medium gap
<br>15 thick-thin medium gap
<br>16 thin-thick-thin medium gap
<br>17 thin-thick large gap
<br>18 thick-thin large gap
<br>19 thin-thick-thin large gap
<br>20 wave
<br>21 double wave
<br>22 dash small gap
<br>23 dash dot stroked
<br>24 emboss 3D
<br>25 engrave 3D
<br>codes 64 - 230 represent border art types and are used only for page
borders.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>ico</td>

<td>U16</td>

<td>:8</td>

<td>00FF</td>

<td>color code (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dptSpace</td>

<td>U16</td>

<td>:5</td>

<td>1F00</td>

<td>width of space to maintain between border and text within border. Must
be 0 when BRC is a substructure of TC. Stored in points.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U16</td>

<td>:1</td>

<td>2000</td>

<td>when 1, border is drawn with shadow. Must be 0 when BRC is a substructure
of the TC</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFrame</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused2_15</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>reserved</td>
</tr>
</table>

<p>cbBRC (count of bytes of BRC) is 4.
<br><a NAME="47"></a>
<h3>
Border Code for Windows Word 1.0 (BRC10)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dxpLine2Width</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>width of second line of border in pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpSpaceBetween</td>

<td>U16</td>

<td>:3</td>

<td>0038</td>

<td>distance to maintain between both lines of border in pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpLine1Width</td>

<td>U16</td>

<td>:3</td>

<td>01C0</td>

<td>width of first border line in pixels</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxpSpace</td>

<td>U16</td>

<td>:5</td>

<td>3E00</td>

<td>width of space to maintain between border and text within border. Must
be 0 when BRC is a substructure of the TC.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>when 1, border is drawn with shadow. Must be 0 when BRC10 is a substructure
of the TC.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpare</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>reserved</td>
</tr>
</table>

<p>The seven types of border lines that Windows Word 1.0 supports are coded
with different sets of values for dxpLine1Width, dxpSpaceBetween, and dxpLine2
Width.
<p>The border lines and their brc10 settings follow:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>line type</td>

<td>dxpLine1Width</td>

<td>dxpSpaceBetween</td>

<td>dxpLine2Width</td>
</tr>

<tr>
<td>no border</td>

<td>0</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>single line border</td>

<td>1</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>two single line border</td>

<td>1</td>

<td>1</td>

<td>1</td>
</tr>

<tr>
<td>fat solid border</td>

<td>4</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>thick solid border</td>

<td>2</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>dotted border</td>

<td>6 (special value meaning dotted line)</td>

<td>0</td>

<td>0</td>
</tr>

<tr>
<td>hairline border</td>

<td>7(special value meaning hairline)</td>

<td>0</td>

<td>0</td>
</tr>
</table>

<p>When the <b>no border</b> settings are stored in the BRC, brc.fShadow
and brc.dxpSpace should be set to 0.
<p>cbBRC10 (count of bytes of BRC10) is 2.
<br><a NAME="42"></a>
<h3>
Bin Table Entry (BTE)</h3>
<!-- sizeOf="4" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>pn</td>

<td>U32</td>

<td></td>

<td></td>

<td>Page Number for FKP</td>
</tr>
</table>

<p>cbBTE (count of bytes of BTE) is 4 bytes.
<br><a NAME="48"></a>
<h3>
Character Properties (CHP)</h3>
The <b>CHP</b> is never stored in Word files. It is the result of decompression
operations applied to <b>CHPX</b>s
<p>The <b>CHPX</b> is stored in <b>CHPX</b> <b>FKPS</b> and within the
<b>STSH</b>
<h4>
Note</h4>
When a <b>CHPX</b> is stored in an <b>FKP</b> it is prefixed by a one-byte
count of bytes that records the size of the non-zero prefix of the <b>CHPX</b>.
Since the count of bytes must begin on an even boundary within the <b>FKP</b>
followed by the non-zero prefix, it's guaranteed that the int and FC fields
of the CHPX are aligned on an odd-byte boundary. Using normal integer or
long load instructions will cause address errors on a 68000. The best technique
for reconstituting the CHPX is to move the non-zero prefix to the beginning
of a local instance of a CHPX that has been cleared to zeros.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fBold</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>text is bold when 1 , and not bold when 0.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fItalic</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td>italic when 1, not italic when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMarkDel</td>

<td>U8</td>

<td>:1</td>

<td>0004</td>

<td>when 1, text has been deleted and will be displayed with strikethrough
when revision marked text is to be displayed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOutline</td>

<td>U8</td>

<td>:1</td>

<td>0008</td>

<td>outlined when 1, not outlined when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFldVanish</td>

<td>U8</td>

<td>:1</td>

<td>0010</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSmallCaps</td>

<td>U8</td>

<td>:1</td>

<td>0020</td>

<td>displayed with small caps when 1, no small caps when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCaps</td>

<td>U8</td>

<td>:1</td>

<td>0040</td>

<td>displayed with caps when 1, no caps when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVanish</td>

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td>when 1, text has "hidden" format, and is not displayed unless fPagHidden
is set in the DOP</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>fRMark</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, text is newly typed since the last time revision marks have
been accepted and will be displayed with an underline when revision marked
text is to be displayed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpec</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>character is a Word special character when 1, not a special character
when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStrike</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>displayed with strikethrough when 1, no strikethrough when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fObj</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>embedded object when 1, not an embedded object when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadow</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>character is drawn with a shadow when 1; drawn without shadow when
0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLowerCase</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td>character is displayed in lower case when 1. No case transformation
is performed when 0. This field may be set to 1 only when chp.fSmallCaps
is 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fData</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, chp.fcPic points to an FFDATA, the data structure binary data
used by Word to describe a form field. The bit chp.fData may only be 1
when chp.fSpec is also 1 and the special character in the document stream
that has this property is a chPicture (0x01).</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOle2</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, chp.lTagObj specifies a particular object in the object stream
that specifies the particular OLE object in the stream that should be displayed
when the chPicture fSpec character that is tagged with the fOle2 is encountered.
The bit chp.fOle2 may only be 1 when chp.fSpec is also 1 and the special
character in the document stream that has this property is a chPicture
(0x01).</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fEmboss</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>text is embossed when 1 and not embossed when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fImprint</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>text is engraved when 1 and not engraved when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDStrike</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>displayed with double strikethrough when 1, no double strikethrough
when 0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUsePgsuSettings</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused2_4</td>

<td>U16</td>

<td>:12</td>

<td>FFF0</td>

<td>Reserved</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>unused4</td>

<td>S32</td>

<td></td>

<td></td>

<td>Reserved</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>ftc</td>

<td>S16</td>

<td></td>

<td></td>

<td>no longer stored</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>ftcAscii</td>

<td>S16</td>

<td></td>

<td></td>

<td>(rgftc[0]) font for ASCII text</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>ftcFE</td>

<td>S16</td>

<td></td>

<td></td>

<td>(rgftc[1]) font for Far East text</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>ftcOther</td>

<td>S16</td>

<td></td>

<td></td>

<td>(rgftc[2]) font for non-Far East text</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>hps</td>
<!-- initial="20" -->

<td>U16</td>

<td></td>

<td></td>

<td>font size in half points</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>dxaSpace</td>

<td>S32</td>

<td></td>

<td></td>

<td>space following each character in the run expressed in twip units.</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>iss</td>

<td>U8</td>

<td>:3</td>

<td>0007</td>

<td>superscript/subscript indices
<br>0 means no super/subscripting
<br>1 means text in run is superscripted
<br>2 means text in run is subscripted</td>
</tr>

<tr>
<td></td>

<td></td>

<td>kul</td>

<td>U8</td>

<td>:4</td>

<td>0078</td>

<td>underline code:
<br>0 none
<br>1 single
<br>2 by word
<br>3 double
<br>4 dotted
<br>5 hidden
<br>6 thick
<br>7 dash
<br>8 dot (not used)
<br>9 dot dash
<br>10 dot dot dash
<br>11 wave</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpecSymbol</td>

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td>used by Word internally, not stored in file</td>
</tr>

<tr>
<td>23</td>

<td>17</td>

<td>ico</td>

<td>U8</td>

<td>:5</td>

<td>1F00</td>

<td>color of text:
<br>0 Auto
<br>1 Black
<br>2 Blue
<br>3 Cyan
<br>4 Green
<br>5 Magenta
<br>6 Red
<br>7 Yellow
<br>8 White
<br>9 DkBlue
<br>10 DkCyan
<br>11 DkGreen
<br>12 DkMagenta
<br>13 DkRed
<br>14 DkYellow
<br>15 DkGray
<br>16 LtGray</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused23_5</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSysVanish</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>used by Word internally, not stored in file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>hpScript</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>reserved</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>hpsPos</td>

<td>S16</td>

<td></td>

<td></td>

<td>super/subscript position in half points; positive means text is raised;
negative means text is lowered.</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>lid</td>
<!-- initial="0x0400" -->

<td>U16</td>

<td></td>

<td></td>

<td>LID language identification code (no longer stored here, see rglid
below):
<br>0x0400 No Proofing
<br>0x0401 Arabic
<br>0x0402 Bulgarian
<br>0x0403 Catalan
<br>0x0404 Traditional Chinese
<br>0x0804 Simplified Chinese
<br>0x0405 Czech
<br>0x0406 Danish
<br>0x0407 German
<br>0x0807 Swiss German
<br>0x0408 Greek
<br>0x0409 U.S. English
<br>0x0809 U.K. English
<br>0x0c09 Australian English
<br>0x040a Castilian Spanish
<br>0x080a Mexican Spanish
<br>0x040b Finnish
<br>0x040c French
<br>0x080c Belgian French
<br>0x0c0c Canadian French
<br>0x100c Swiss French
<br>0x040d Hebrew
<br>0x040e Hungarian
<br>0x040f Icelandic
<br>0x0410 Italian
<br>0x0810 Swiss Italian
<br>0x0411 Japanese
<br>0x0412 Korean
<br>0x0413 Dutch
<br>0x0813 Belgian Dutch
<br>0x0414 Norwegian - Bokmal
<br>0x0814 Norwegian - Nynorsk
<br>0x0415 Polish
<br>0x0416 Brazilian Portuguese
<br>0x0816 Portuguese
<br>0x0417 Rhaeto-Romanic
<br>0x0418 Romanian
<br>0x0419 Russian
<br>0x041a Croato-Serbian (Latin)
<br>0x081a Serbo-Croatian (Cyrillic)
<br>0x041b Slovak
<br>0x041c Albanian
<br>0x041d Swedish
<br>0x041e Thai
<br>0x041f Turkish
<br>0x0420 Urdu
<br>0x0421 Bahasa
<br>0x0422 Ukrainian
<br>0x0423 Byelorussian
<br>0x0424 Slovenian
<br>0x0425 Estonian
<br>0x0426 Latvian
<br>0x0427 Lithuanian
<br>0x0429 Farsi
<br>0x042D Basque
<br>0x042F Macedonian
<br>0x0436 Afrikaans
<br>0x043E Malaysian</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>lidDefault</td>
<!-- initial="0x0400" -->

<td>U16</td>

<td></td>

<td></td>

<td>(rglid[0]) LID language for non-Far East text</td>
</tr>

<tr>
<td>30</td>

<td>1E</td>

<td>lidFE</td>
<!-- initial="0x0400" -->

<td>U16</td>

<td></td>

<td></td>

<td>(rglid[1]) LID language for Far East text</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>idct</td>

<td>U8</td>

<td></td>

<td></td>

<td>not stored in file</td>
</tr>

<tr>
<td>33</td>

<td>21</td>

<td>idctHint</td>

<td>U8</td>

<td></td>

<td></td>

<td>Identifier of Characte type
<br>0 -> shared chars get non-FE props
<br>1 -> shared chars get FE props
<br>(see Appendix C)</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>wCharScale</td>
<!-- initial="100" -->

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>fcPic_fcObj_lTagObj</td>
<!-- initial="-1" -->

<td>S32</td>

<td></td>

<td></td>

<td>(fcPic) FC offset in data stream pointing to beginning of a picture
when character is a picture character (character is 0x01 and chp.fSpec
is 1)
<p>(fcObj) FC offset in data stream pointing to beginning of a picture
when character is an OLE1 object character (character is 0x20 and chp.fSpec
is 1, chp.fOle2 is 0)
<p>(lTagObj) long word tag that identifies an OLE2 object in the object
stream when the character is an OLE2 object character. (character is 0x01
and chp.fSpec is 1, chp.fOle2 is 1)</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>ibstRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when text in run was
newly typed when revision marking was enabled</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>ibstRMarkDel</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when text in run was
deleted when revision marking was enabled</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>dttmRMark</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which this run of text was entered/modified by the author.
(Only recorded when revision marking is on.)</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>dttmRMarkDel</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which this run of text was deleted by the author. (Only
recorded when revision marking is on.)</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>unused52</td>

<td>S16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>istd</td>
<!-- initial="10" -->

<td>U16</td>

<td></td>

<td></td>

<td>index to character style descriptor in the stylesheet that tags this
run of text When istd is istdNormalChar (10 decimal), characters in run
are not affected by a character style. If chp.istd contains any other value,
chpx of the specified character style are applied to CHP for this run before
any other exceptional properties are applied.</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>ftcSym</td>

<td>S16</td>

<td></td>

<td></td>

<td>when chp.fSpec is 1 and the character recorded for the run in the document
stream is chSymbol (0x28), chp.ftcSym identifies the font code of the symbol
font that will be used to display the symbol character recorded in chp.xchSym.
chp.ftcSym is an index into the rgffn structure.</td>
</tr>

<tr>
<td>58</td>

<td>3A</td>

<td>xchSym</td>

<td>XCHAR</td>

<td></td>

<td></td>

<td>when chp.fSpec is 1 and the character recorded for the run in the document
stream is chSymbol (0x28), the character stored chp.xchSym will be displayed
using the font specified in chp.ftcSym.</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>idslRMReason</td>

<td>S16</td>

<td></td>

<td></td>

<td>an index to strings displayed as reasons for actions taken by Word's
AutoFormat code</td>
</tr>

<tr>
<td>62</td>

<td>3E</td>

<td>idslRMReasonDel</td>

<td>S16</td>

<td></td>

<td></td>

<td>an index to strings displayed as reasons for actions taken by Word's
AutoFormat code</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>ysr</td>

<td>U8</td>

<td></td>

<td></td>

<td>hyphenation rule
<br>0 No hyphenation
<br>1 Normal hyphenation
<br>2 Add letter before hyphen
<br>3 Change letter before hyphen
<br>4 Delete letter before hyphen
<br>5 Change letter after hyphen
<br>6 Delete letter before the hyphen and change the letter preceding the
deleted character</td>
</tr>

<tr>
<td>65</td>

<td>41</td>

<td>chYsr</td>

<td>U8</td>

<td></td>

<td></td>

<td>the character that will be used to add or change a letter when chp.ysr
is 2,3, 5 or 6</td>
</tr>

<tr>
<td>66</td>

<td>42</td>

<td>chse</td>

<td>U16</td>

<td></td>

<td></td>

<td>extended character set id
<br>0 characters in run should be interpreted using the ANSI set used by
Windows&nbsp;
<br>256 characters in run should be interpreted using the Macintosh character
set.</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>hpsKern</td>

<td>U16</td>

<td></td>

<td></td>

<td>kerning distance for characters in run recorded in half points</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>icoHighlight</td>

<td>U16</td>

<td>:5</td>

<td>001F</td>

<td>highlight color (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHighlight</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>when 1, characters are highlighted with color specified by chp.icoHighlight.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>kcd</td>

<td>U16</td>

<td>:3</td>

<td>01C0</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNavHighlight</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fChsDiff</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMacChs</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFtcAsciSym</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>reserved_3</td>

<td>U16</td>

<td>:3</td>

<td>E000</td>

<td>Reserved</td>
</tr>

<tr>
<td>72</td>

<td>48</td>

<td>fPropMark</td>

<td>U16</td>

<td></td>

<td></td>

<td>when 1, properties have been changed with revision marking on</td>
</tr>

<tr>
<td>74</td>

<td>4A</td>

<td>ibstPropRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when properties have
been changed when revision marking was enabled</td>
</tr>

<tr>
<td>76</td>

<td>4C</td>

<td>dttmPropRMark</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which properties of this were changed for this run of
text by the author. (Only recorded when revision marking is on.)</td>
</tr>

<tr>
<td>80</td>

<td>50</td>

<td>sfxtText</td>

<td>U8</td>

<td></td>

<td></td>

<td>text animation:
<br>0 no animation
<br>1 Las Vegas lights
<br>2 background blink
<br>3 sparkle text
<br>4 marching ants
<br>5 marchine red ants
<br>6 shimmer</td>
</tr>

<tr>
<td>81</td>

<td>51</td>

<td>unused81</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>82</td>

<td>52</td>

<td>unused82</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>83</td>

<td>53</td>

<td>unused83</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>85</td>

<td>55</td>

<td>unused85</td>

<td>S16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>87</td>

<td>57</td>

<td>unused87</td>

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>91</td>

<td>5B</td>

<td>fDispFldRMark</td>

<td>S8</td>

<td></td>

<td></td>

<td>(Only valid for ListNum fields). When 1, the number for a ListNum field
is being tracked in xstDispFldRMark -- if that number is different from
the current value, the number has changed.</td>
</tr>

<tr>
<td>92</td>

<td>5C</td>

<td>ibstDispFldRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>Index to author IDs stored in hsttbfRMark. used when ListNum field
numbering has been changed when revision marking was enabled</td>
</tr>

<tr>
<td>94</td>

<td>5E</td>

<td>dttmDispFldRMark</td>

<td>U32</td>

<td></td>

<td></td>

<td>The date for the ListNum field number change</td>
</tr>

<tr>
<td>98</td>

<td>62</td>

<td>xstDispFldRMark</td>

<td>XCHAR[16]</td>

<td></td>

<td></td>

<td>The string value of the ListNum field when revision mark tracking began</td>
</tr>

<tr>
<td>130</td>

<td>82</td>

<td>shd</td>

<td>SHD</td>

<td></td>

<td></td>

<td>shading</td>
</tr>

<tr>
<td>132</td>

<td>84</td>

<td>brc</td>

<td>BRC</td>

<td></td>

<td></td>

<td>border</td>
</tr>
</table>

<p>cbCHP (count of bytes of CHP) is 136 (decimal), 88(hex).
<p>The standard CHP is all zeros except:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>hps</td>

<td>20 half-points</td>
</tr>

<tr>
<td>fcPic</td>

<td>-1</td>
</tr>

<tr>
<td>istd</td>

<td>10 (the standard character style)</td>
</tr>

<tr>
<td>lidDefault, lidFE</td>

<td>0x0400 (no proofing)</td>
</tr>

<tr>
<td>wCharScale</td>

<td>100</td>
</tr>

<tr>
<td>fUsePgsuSettings</td>

<td>-1</td>
</tr>
</table>
<a NAME="49"></a>
<h3>
Character Property Exceptions (CHPX)</h3>
The <b>CHPX</b> is stored within <b>Character FKPs</b> and within the <b>STSH</b>
in <b>STD</b>s for <b>paragraph style</b> and <b>character style</b> entries.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of bytes of following data in CHPX.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>grpprl</td>

<td>U8[cb]</td>
<!-- compareSizeLHS="lhs.cb" compareSizeRHS="rhs.cb" -->

<td></td>

<td></td>

<td>a list of the sprms that encode the differences between CHP for a run
of text and the CHP generated by the paragraph and character styles that
tag the run.</td>
</tr>
</table>
<a NAME="59"></a>
<h3>
Formatted Disk Page for CHPXs (CHPXFKP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>rgfc</td>

<td>FC[]</td>

<td></td>

<td></td>

<td>Each <b>FC</b> is the limit <b>FC</b> of a run of exception text.</td>
</tr>

<tr>
<td>4*(fkp.crun+1)</td>

<td></td>

<td>rgb</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>an array of bytes where each byte is the word offset of a<b> CHPX</b>.
If the byte stored is 0, there is no difference between run's character
properties and the style's character properties.</td>
</tr>

<tr>
<td>5*fkp.crun+4</td>

<td></td>

<td>unusedSpace</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>As new runs/paragraphs are recorded in the <b>FKP</b>, unused space
is reduced by 5 if CHPX is already recorded and is reduced by 5+sizeof(CHPX)
if property is not already recorded.</td>
</tr>

<tr>
<td>511-sizeof(grpchpx)</td>

<td></td>

<td>grpchpx</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>grpchpx consists of all of the <b>CHPX</b>s stored in <b>FKP</b> concatenated
end to end. Each <b>CHPX</b> is prefixed with a count of bytes which records
its length.</td>
</tr>

<tr>
<td>511</td>

<td></td>

<td>crun</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of runs for <b>CHPX FKP,</b></td>
</tr>
</table>

<p>The <b>CHP</b> is never stored in a Word file. It is derived by expanding
stored <b>CHPX</b>s.
<br><a NAME="51"></a>
<h3>
Drop Cap Specifier(DCS)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fdct</td>

<td>U8</td>

<td>:3</td>

<td>0007</td>

<td>default value 0
<br>drop cap type
<br>0 no drop cap
<br>1 normal drop cap
<br>2 drop cap in margin</td>
</tr>

<tr>
<td></td>

<td></td>

<td>lines</td>

<td>U8</td>

<td>:5</td>

<td>00F8</td>

<td>default value 0
<br>count of lines to drop</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>unused1</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>
</table>

<p>cbDCS (count of bytes of DCS) is 2.
<br><a NAME="52"></a>
<h3>
Drawing Object Grid (DOGRID)</h3>
The drawing object grid is Far East only, and it sets up a grid in which
Far Eastern characters are displayed (one character per grid square).
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>xaGrid</td>

<td>S16</td>

<td></td>

<td></td>

<td>x-coordinate of the upper left-hand corner of the grid</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>yaGrid</td>

<td>S16</td>

<td></td>

<td></td>

<td>y-coordinate of the upper left-hand corner of the grid</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dxaGrid</td>

<td>S16</td>

<td></td>

<td></td>

<td>width of each grid square</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>dyaGrid</td>

<td>S16</td>

<td></td>

<td></td>

<td>height of each grid square</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>dyGridDisplay</td>

<td>U16</td>

<td>:7</td>

<td>007F</td>

<td>the number of grid squares (in the y direction) between each gridline
drawn on the screen. 0 means don't display any gridlines in the y direction.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTurnItOff</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>suppress display of gridlines</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dxGridDisplay</td>

<td>U16</td>

<td>:7</td>

<td>7F00</td>

<td>the number of grid squares (in the x direction) between each gridline
drawn on the screen. 0 means don't display any gridlines in the y direction.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFollowMargins</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>if true, the grid will start at the left and top margins and ignore
xaGrid and yaGrid.</td>
</tr>
</table>

<p>cbDOGRID (count of bytes of DOGRID) is 10 bytes (decimal), A bytes (hex).
<br><a NAME="52a"></a>
<h3>
Document Properties (DOP)</h3>
Each version of Word, the DOP gets a little bit larger. Shown below are
three different versions of the DOP: for nFib values &lt; 103, for nFib
values between 103 and 105, and for nFib values > 105.. Winword 97 and
later products write files with nFib > 105. Word 6.0 for the Macintosh
writes files with nFib == 103 or 104. The compatibility options (copts)
section was grown (to add more compatibility options in the Tools/Options/Compatibility
dialog) and copied to the end of the DOP, so for files with nFib >= 103,
the first copts section should be ignored (and the analogous fields in
the new copts section used instead), whereas files with nFib &lt; 103 will
have DOP's without the new copts section. See below for the addition.
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fFacingPages</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 when facing pages should be printed.
<br>Default 0.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWidowControl</td>
<!-- initial="1" -->

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>1 when widow control is in effect. 0 when widow control disabled.
<br>Default 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPMHMainDoc</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>1 when doc is a main doc for Print Merge Helper, 0 when not; default=0</td>
</tr>

<tr>
<td></td>

<td></td>

<td>grfSuppression</td>

<td>U16</td>

<td>:2</td>

<td>0018</td>

<td>Default line suppression storage; 0= form letter line suppression;
1= no line suppression; default=0. No longer used.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fpc</td>
<!-- initial="1" -->

<td>U16</td>

<td>:2</td>

<td>0060</td>

<td>footnote position code&nbsp;
<br>0 print as endnotes
<br>1 print at bottom of page
<br>2 print immediately beneath text
<br>Default 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_7</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>unused. Default 0.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>grpfIhdt</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>No longer used. Default 0.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>rncFtn</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>restart index for footnotes&nbsp;
<br>0 don't restart note numbering
<br>1 restart for each section
<br>2 restart for each page
<br>Default 0.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nFtn</td>
<!-- initial="1" -->

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>initial footnote number for document. Default 1.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fOutlineDirtySave</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>when 1, indicates that information in the hplcpad should be refreshed
since outline has been dirtied</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_1</td>

<td>U8</td>

<td>:7</td>

<td>00FE</td>

<td>reserved</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>fOnlyMacPics</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, Word believes all pictures recorded in the document were created
on a Macintosh</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOnlyWinPics</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>when 1, Word believes all pictures recorded in the document were created
in Windows</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLabelDoc</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>when 1, document was created as a print merge labels document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHyphCapitals</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>when 1, Word is allowed to hyphenate words that are capitalized. When
0, capitalized may not be hyphenated</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAutoHyphen</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>when 1, Word will hyphenate newly typed text as a background task</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFormNoFields</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLinkStyles</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, Word will merge styles from its template</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRevMarking</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, Word will mark revisions as the document is edited</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fBackup</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td>always make backup when document saved when 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fExactCWords</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td>when 1, the results of the last Word Count execution (as recorded in
several DOP fields) are still exactly correct.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPagHidden</td>

<td>U8</td>

<td>:1</td>

<td>0004</td>

<td>when 1, hidden document contents are displayed.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPagResults</td>

<td>U8</td>

<td>:1</td>

<td>0008</td>

<td>when 1, field results are displayed, when 0 field codes are displayed.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLockAtn</td>

<td>U8</td>

<td>:1</td>

<td>0010</td>

<td>when 1, annotations are locked for editing</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMirrorMargins</td>

<td>U8</td>

<td>:1</td>

<td>0020</td>

<td>swap margins on left/right pages when 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused6_6</td>

<td>U8</td>

<td>:1</td>

<td>0040</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDfltTrueType</td>

<td>U8</td>

<td>:1</td>

<td>0080</td>

<td>when 1, use TrueType fonts by default (flag obeyed only when doc was
created by WinWord 2.x)</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>fPagSuppressTopSpacing</td>

<td>U8</td>

<td>:1</td>

<td>0100</td>

<td>when 1, file created with SUPPRESSTOPSPACING=YES in win.ini. (flag
obeyed only when doc was created by WinWord 2.x).</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fProtEnabled</td>

<td>U8</td>

<td>:1</td>

<td>0200</td>

<td>when 1, document is protected from edit operations</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDispFormFldSel</td>

<td>U8</td>

<td>:1</td>

<td>0400</td>

<td>when 1, restrict selections to occur only within form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMView</td>

<td>U8</td>

<td>:1</td>

<td>0800</td>

<td>when 1, show revision markings on screen</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRMPrint</td>

<td>U8</td>

<td>:1</td>

<td>1000</td>

<td>when 1, print revision marks when document is printed</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused7_5</td>

<td>U8</td>

<td>:1</td>

<td>2000</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLockRev</td>

<td>U8</td>

<td>:1</td>

<td>4000</td>

<td>when 1, the current revision marking state is locked</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEmbedFonts</td>

<td>U8</td>

<td>:1</td>

<td>8000</td>

<td>when 1, document contains embedded TrueType fonts</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>copts_fNoTabForInd</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>compatibility option: when 1, don't add automatic tab stops for hanging
indent</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fNoSpaceRaiseLower</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>compatibility option: when 1, don't add extra space for raised or lowered
characters</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSuppressSpbfAfterPageBreak</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>compatibility option: when 1, suppress the paragraph Space Before and
Space After options after a page break</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fWrapTrailSpaces</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>compatibility option: when 1, wrap trailing spaces at the end of a
line to the next line</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fMapPrintTextColor</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>compatibility option: when 1, print colors as black on non-color printers</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fNoColumnBalance</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>compatibility option: when 1, don't balance columns for Continuous
Section starts</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fConvMailMergeEsc</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSupressTopSpacing</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>compatibility option: when 1, suppress extra line spacing at top of
page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fOrigWordTableRules</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>compatibility option: when 1, combine table borders like Word 5.x for
the Macintosh</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fTransparentMetafiles</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>compatibility option: when 1, don't blank area between metafile pictures</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fShowBreaksInFrames</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>compatibility option: when 1, show hard page or column breaks in frames</td>
</tr>

<tr>
<td></td>

<td></td>

<td>copts_fSwapBordersFacingPgs</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>compatibility option: when 1, swap left and right pages on odd facing
pages</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused8_12</td>

<td>U16</td>

<td>:4</td>

<td>F000</td>

<td>reserved</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>dxaTab</td>
<!-- initial="720" -->

<td>U16</td>

<td></td>

<td></td>

<td>default tab width. Default 720 twips.</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>wSpare</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>dxaHotZ</td>

<td>U16</td>

<td></td>

<td></td>

<td>width of hyphenation hot zone measured in twips</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>cConsecHypLim</td>

<td>U16</td>

<td></td>

<td></td>

<td>number of lines allowed to have consecutive hyphens</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>wSpare2</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dttmCreated</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was created</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dttmRevised</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was last revised</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dttmLastPrint</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>date and time document was last printed</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>nRevision</td>

<td>S16</td>

<td></td>

<td></td>

<td>number of times document has been revised since its creation</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>tmEdited</td>

<td>S32</td>

<td></td>

<td></td>

<td>time document was last edited</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>cWords</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of words tallied by last Word Count execution</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>cCh</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of characters tallied by last Word Count execution</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>cPg</td>

<td>S16</td>

<td></td>

<td></td>

<td>count of pages tallied by last Word Count execution</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>cParas</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of paragraphs tallied by last Word Count execution</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>rncEdn</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>restart endnote number code&nbsp;
<br>0 don't restart endnote numbering
<br>1 restart for each section
<br>2 restart for each page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nEdn</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>beginning endnote number</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>epc</td>

<td>U16</td>

<td>:2</td>

<td>0003</td>

<td>endnote position code&nbsp;
<br>0 display endnotes at end of section
<br>3 display endnotes at end of document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nfcFtnRef</td>

<td>U16</td>

<td>:4</td>

<td>003C</td>

<td>number format code for auto footnotes&nbsp;
<br>0 Arabic
<br>1 Upper case Roman
<br>2 Lower case Roman
<br>3 Upper case Letter
<br>4 Lower case Letter
<br>[This field is obsoleted by nfcFtnRef2 at 0x1ec (Werner)]</td>
</tr>

<tr>
<td></td>

<td></td>

<td>nfcEdnRef</td>

<td>U16</td>

<td>:4</td>

<td>03C0</td>

<td>number format code for auto endnotes&nbsp;
<br>0 Arabic
<br>1 Upper case Roman
<br>2 Lower case Roman
<br>3 Upper case Letter
<br>4 Lower case Letter
<br>[This field is obsoleted by nfcEdnRef2 at 0x1ee (Werner)]</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrintFormData</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>only print data inside of form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSaveFormData</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>only save document data that is inside of a form field.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShadeFormData</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>shade form fields</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused54_13</td>

<td>U16</td>

<td>:2</td>

<td>6000</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWCFtnEdn</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>when 1, include footnotes and endnotes in word count</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>cLines</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of lines tallied by last Word Count operation</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>cWordsFtnEnd</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of words in footnotes and endnotes tallied by last Word Count
operation</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>cChFtnEdn</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of characters in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>cPgFtnEdn</td>

<td>S16</td>

<td></td>

<td></td>

<td>count of pages in footnotes and endnotes tallied by last Word Count
operation</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>cParasFtnEdn</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of paragraphs in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>74</td>

<td>4A</td>

<td>cLinesFtnEdn</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of paragraphs in footnotes and endnotes tallied by last Word
Count operation</td>
</tr>

<tr>
<td>78</td>

<td>4E</td>

<td>lKeyProtDoc</td>

<td>S32</td>

<td></td>

<td></td>

<td>document protection password key, only valid if dop.fProtEnabled, dop.fLockAtn
or dop.fLockRev are 1.</td>
</tr>

<tr>
<td>82</td>

<td>52</td>

<td>wvkSaved</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>document view kind&nbsp;
<br>0 Normal view
<br>1 Outline view
<br>2 Page View</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wScaleSaved</td>

<td>U16</td>

<td>:9</td>

<td>0FF8</td>

<td>zoom percentage</td>
</tr>

<tr>
<td></td>

<td></td>

<td>zkSaved</td>

<td>U16</td>

<td>:2</td>

<td>3000</td>

<td>zoom type&nbsp;
<br>0 None
<br>1 Full page
<br>2 Page width</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRotateFontW6</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>This is a vertical document (Word 6/95 only)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>iGutterPos</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>Gutter position for this doc: 0 => side; 1 => top.</td>
</tr>

<tr>
<td>84</td>

<td>54</td>

<td>fNoTabForInd</td>

<td>U32</td>

<td>:1</td>

<td>00000001</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNoSpaceRaiseLower</td>

<td>U32</td>

<td>:1</td>

<td>00000002</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSupressSpbfAfterPageBreak</td>

<td>U32</td>

<td>:1</td>

<td>00000004</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWrapTrailSpaces</td>

<td>U32</td>

<td>:1</td>

<td>00000008</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMapPrintTextColor</td>

<td>U32</td>

<td>:1</td>

<td>00000010</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNoColumnBalance</td>

<td>U32</td>

<td>:1</td>

<td>00000020</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fConvMailMergeEsc</td>

<td>U32</td>

<td>:1</td>

<td>00000040</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSupressTopSpacing</td>

<td>U32</td>

<td>:1</td>

<td>00000080</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOrigWordTableRules</td>

<td>U32</td>

<td>:1</td>

<td>00000100</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTransparentMetafiles</td>

<td>U32</td>

<td>:1</td>

<td>00000200</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShowBreaksInFrames</td>

<td>U32</td>

<td>:1</td>

<td>00000400</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSwapBordersFacingPgs</td>

<td>U32</td>

<td>:1</td>

<td>00000800</td>

<td>(see above)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused84_12</td>

<td>U32</td>

<td>:4</td>

<td>0000F000</td>

<td>(reserved)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSuppressTopSpacingMac5</td>

<td>U32</td>

<td>:1</td>

<td>00010000</td>

<td>Suppress extra line spacing at top of page like MacWord5.x</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTruncDxaExpand</td>

<td>U32</td>

<td>:1</td>

<td>00020000</td>

<td>Expand/Condense by whole number of points.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrintBodyBeforeHdr</td>

<td>U32</td>

<td>:1</td>

<td>00040000</td>

<td>Print body text before header/footer</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNoLeading</td>

<td>U32</td>

<td>:1</td>

<td>00080000</td>

<td>Don't add leading (extra space) between rows of text</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused84_20</td>

<td>U32</td>

<td>:1</td>

<td>00100000</td>

<td>(reserved)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMWSmallCaps</td>

<td>U32</td>

<td>:1</td>

<td>00200000</td>

<td>Use larger small caps like MacWord 5.x</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused84_22</td>

<td>U32</td>

<td>:10</td>

<td>FFC00000</td>

<td>(reserved)</td>
</tr>

<tr>
<td>88</td>

<td>58</td>

<td>adt</td>

<td>U16</td>

<td></td>

<td></td>

<td>Autoformat Document Type: 0 for normal. 1 for letter, and 2 for email.</td>
</tr>

<tr>
<td>90</td>

<td>5A</td>

<td>doptypography</td>

<td>DOPTYPOGRAPHY</td>

<td></td>

<td></td>

<td>see DOPTYPOGRAPHY</td>
</tr>

<tr>
<td>400</td>

<td>190</td>

<td>dogrid</td>

<td>DOGRID</td>

<td></td>

<td></td>

<td>see DOGRID</td>
</tr>

<tr>
<td>410</td>

<td>19A</td>

<td>reserved</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td></td>

<td></td>

<td>lvl</td>

<td>U16</td>

<td>:4</td>

<td>001E</td>

<td>Which outline levels are showing in outline view (0 => heading 1 only,
4 => headings 1 through 5, 9 => all levels showing)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGramAllDone</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>Doc has been completely grammar checked</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGramAllClean</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>No grammer errors exist in doc</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSubsetFonts</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>if you are doing font embedding, you should only embed the characters
in the font that are used in the document</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHideLastVersion</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>Hide the version created for autoversion</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHtmlDoc</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>This file is based upon an HTML file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused410_11</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSnapBorder</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>Snap table and page borders to page border</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fIncludeHeader</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>Place header inside page border</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fIncludeFooter</td>

<td>U16</td>

<td>:1</td>

<td>2000</td>

<td>Place footer inside page border</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fForcePageSizePag</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>Are we in online view</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMinFontSizePag</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>Are we auto-promoting fonts to >= hpsZoonFontPag?</td>
</tr>

<tr>
<td>412</td>

<td>19C</td>

<td>fHaveVersions</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>versioning is turned on</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAutoVersion</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>autoversioning is enabled</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused412_2</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td>414</td>

<td>19E</td>

<td>asumyi</td>

<td>ASUMYI</td>

<td></td>

<td></td>

<td>Autosummary info</td>
</tr>

<tr>
<td>426</td>

<td>1AA</td>

<td>cChWS</td>

<td>S32</td>

<td></td>

<td></td>

<td>Count of characters with spaces</td>
</tr>

<tr>
<td>430</td>

<td>1AE</td>

<td>cChWSFtnEdn</td>

<td>S32</td>

<td></td>

<td></td>

<td>Count of characters with spaces in footnotes and endnotes</td>
</tr>

<tr>
<td>434</td>

<td>1B2</td>

<td>grfDocEvents</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>438</td>

<td>1B6</td>

<td>fVirusPrompted</td>

<td>U32</td>

<td>:1</td>

<td>0001</td>

<td>Have we prompted for virus protection on this doc?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVirusLoadSafe</td>

<td>U32</td>

<td>:1</td>

<td>0002</td>

<td>If prompted, load safely for this doc?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>KeyVirusSession30</td>

<td>U32</td>

<td>:30</td>

<td>FFFC</td>

<td>Random session key to sign above bits for a Word session.</td>
</tr>

<tr>
<td>442</td>

<td>1BA</td>

<td>Spare</td>

<td>U8[30]</td>

<td></td>

<td></td>

<td>Spare</td>
</tr>

<tr>
<td>472</td>

<td>1D8</td>

<td>unused472</td>

<td>U32</td>

<td></td>

<td></td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td>476</td>

<td>1DC</td>

<td>unused476</td>

<td>U32</td>

<td></td>

<td></td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td>480</td>

<td>1E0</td>

<td>cDBC</td>

<td>S32</td>

<td></td>

<td></td>

<td>Count of double byte characters</td>
</tr>

<tr>
<td>484</td>

<td>1E4</td>

<td>cDBCFtnEdn</td>

<td>S32</td>

<td></td>

<td></td>

<td>Count od double byte characters in footnotes and endnotes</td>
</tr>

<tr>
<td>488</td>

<td>1E8</td>

<td>unused488</td>

<td>U32</td>

<td></td>

<td></td>

<td>Always set to zero when writing files</td>
</tr>

<tr>
<td>492</td>

<td>1EC</td>

<td>nfcFtnRef2</td>

<td>S16</td>

<td></td>

<td></td>

<td>number format code for auto footnote references&nbsp;
<br>0 Arabic
<br>1 Upper case Roman
<br>2 Lower case Roman
<br>3 Upper case Letter
<br>4 Lower case Letter</td>
</tr>

<tr>
<td>494</td>

<td>1EE</td>

<td>nfcEdnRef2</td>

<td>S16</td>

<td></td>

<td></td>

<td>number format code for auto endnote references&nbsp;
<br>0 Arabic&nbsp;
<div CLASS="tt">1 Upper case Roman</div>
2 Lower case Roman
<br>3 Upper case Letter
<br>4 Lower case Letter</td>
</tr>

<tr>
<td>496</td>

<td>1F0</td>

<td>hpsZoonFontPag</td>

<td>S16</td>

<td></td>

<td></td>

<td>minimum font size if fMinFontSizePag is true</td>
</tr>

<tr>
<td>498</td>

<td>1F2</td>

<td>dywDispPag</td>

<td>S16</td>

<td></td>

<td></td>

<td>height of the window in online view during last repag</td>
</tr>
</table>


<p CLASS="t">In a file with nFib &lt; 103-for example, documents created
with Word 6.0 for Windows-the DOP would end at offset 83. Such a DOP would
have a cbDOP of 84, and a cwDOP of 42.

<p CLASS="t">For files with nFib >= 103, the compatibility options (copts)
section at offset 8 was copied to offset 84 and expanded. Options marked
"(see above)" hold the same value that the same-named field in the old
copts section above had in files with nFib &lt; 103. Such a DOPwould have
a&nbsp; cbDOP = 88 and a cwDOP = 44.

<p CLASS="t">In a file with nFib > 105 the DOP would end here. For this
expanded DOP, cbDOP = 500 and cwDOP = 250.
<br><a NAME="53"></a>
<h3>
Document Typography Info (DOPTYPOGRAPHY)</h3>
These options are Far East only, and are accessible through the Typography
tab of the Tools/Options dialog.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fKerningPunct</td>

<td>U16</td>

<td>:1</td>

<td>00000001</td>

<td>true if we're kerning punctuation</td>
</tr>

<tr>
<td></td>

<td></td>

<td>iJustification</td>

<td>U16</td>

<td>:2</td>

<td>00000006</td>

<td>Kinsoku method of justification:
<br>0 = always expand
<br>1 = compress punctuation
<br>2 = compress punctuation and kana.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>iLevelOfKinsoku</td>

<td>U16</td>

<td>:2</td>

<td>00000018</td>

<td>Level of Kinsoku:
<br>0 = Level 1
<br>1 = Level 2
<br>2 = Custom</td>
</tr>

<tr>
<td></td>

<td></td>

<td>f2on1</td>

<td>U16</td>

<td>:1</td>

<td>00000020</td>

<td>2-page-on-1 feature is turned on.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_6</td>

<td>U16</td>

<td>:10</td>

<td>0000FFC0</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cchFollowingPunct</td>

<td>S16</td>

<td></td>

<td></td>

<td>length of rgxchFPunct</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cchLeadingPunct</td>

<td>S16</td>

<td></td>

<td></td>

<td>length of rgxchLPunct</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>rgxchFPunct</td>

<td>XCHAR[101]</td>

<td></td>

<td></td>

<td>array of characters that should never appear at the start of a line</td>
</tr>

<tr>
<td>208</td>

<td>D0</td>

<td>rgxchLPunct</td>

<td>XCHAR[51]</td>

<td></td>

<td></td>

<td>array of characters that should never appear at the end of a line</td>
</tr>
</table>

<p>cbDOPTYPOGRAPHY (count of bytes of DOPTYPOGRAPHY) is 310 bytes (decimal),
136 (hex)..
<br><a NAME="50"></a>
<h3>
Date and Time (internal date format) (DTTM)</h3>
<!-- sizeOf="4" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>mint</td>

<td>U16</td>

<td>:6</td>

<td>003F</td>

<td>minutes (0-59)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>hr</td>

<td>U16</td>

<td>:5</td>

<td>07C0</td>

<td>hours (0-23)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dom</td>

<td>U16</td>

<td>:5</td>

<td>F800</td>

<td>days of month (1-31)</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>mon</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td>months (1-12)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>yr</td>

<td>U16</td>

<td>:9</td>

<td>1FF0</td>

<td>years (1900-2411)-1900</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wdy</td>

<td>U16</td>

<td>:3</td>

<td>E000</td>

<td>weekday
<br>Sunday=0
<br>Monday=1
<br>Tuesday=2
<br>Wednesday=3
<br>Thursday=4
<br>Friday=5
<br>Saturday=6</td>
</tr>
</table>

<p>cbDTTM (count of bytes of DTTM) is 4.
<br><a NAME="56"></a>
<h3>
Font Family Name (FFN)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cbFfnM1</td>

<td>U8</td>

<td></td>

<td></td>

<td>total length of FFN - 1.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>prq</td>

<td>U8</td>

<td>:2</td>

<td>03</td>

<td>pitch request</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTrueType</td>

<td>U8</td>

<td>:1</td>

<td>04</td>

<td>when 1, font is a TrueType font</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused1_3</td>

<td>U8</td>

<td>:1</td>

<td>08</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ff</td>

<td>U8</td>

<td>:3</td>

<td>70</td>

<td>font family id</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused1_7</td>

<td>U8</td>

<td>:1</td>

<td>80</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>wWeight</td>

<td>S16</td>

<td></td>

<td></td>

<td>base weight of font</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>chs</td>

<td>U8</td>

<td></td>

<td></td>

<td>character set identifier</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>ixchSzAlt</td>

<td>U8</td>

<td></td>

<td></td>

<td>index into ffn.szFfn to the name of the alternate font</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>panose</td>

<td>U8[10]</td>

<td></td>

<td></td>

<td>? This is supposed to be of type PANOSE.</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>fs</td>

<td>U8[24]</td>

<td></td>

<td></td>

<td>? This is supposed to be of type FONTSIGNATURE.</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>xszFfn</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>zero terminated string that records name of font. Possibly followed
by a second xsz which records the name of an alternate font to use if the
first named font does not exist on this system. Maximal size of xszFfn
is 65 characters.</td>
</tr>
</table>
<a NAME="57"></a>
<h3>
File Information Block (FIB)</h3>
In Word version 8, the FIB is reorganized to make future extention easier,
and to make it easier to make backward compatible file format changes.
The FIB now consists of four substructures: the header and three arrays.
The FIB header, is unchanged from past versions. The second part is an
array of 16-bit "shorts", most of which were present in earlier versions
in different locations. The third part is an array of 32-bit longs, many
of which were scattered through the previous version FIB. Finally, there
is an array of FC/LCB pairs, which were divided into several disjoint arrays
in the previous FIB. Future versions of Word will add entries to the three
arrays, so readers of the FIB must be careful to skip over any entries
in each array that were not present in the version for which the reader
was designed. Writers of the FIB must write exactly as many entries as
was defined for the nFib value they put in the FIB.
<p>The <b>FIB</b> structure itself:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0x0000</td>

<td>wIdent</td>

<td>U16</td>

<td></td>

<td></td>

<td>(fibh) FIBH Beginning of the FIB header magic number</td>
</tr>

<tr>
<td>2</td>

<td>0x0002</td>

<td>nFib</td>

<td>U16</td>

<td></td>

<td></td>

<td>FIB version written. This will be >= 101 for all Word 6.0 for Windows
and after documents.</td>
</tr>

<tr>
<td>4</td>

<td>0x0004</td>

<td>nProduct</td>

<td>U16</td>

<td></td>

<td></td>

<td>product version written by</td>
</tr>

<tr>
<td>6</td>

<td>0x0006</td>

<td>lid</td>

<td>U16</td>

<td></td>

<td></td>

<td>language stamp -- localized version
<br>In pre-WinWord 2.0 files this value was the nLocale. If value is &lt;
999, then it is the nLocale, otherwise it is the lid.</td>
</tr>

<tr>
<td>8</td>

<td>0x0008</td>

<td>pnNext</td>

<td>S16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>10</td>

<td>0x000A</td>

<td>fDot</td>

<td>U16</td>

<td>:1</td>

<td>0x0001</td>

<td>Set if this document is a template</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGlsy</td>

<td>U16</td>

<td>:1</td>

<td>0x0002</td>

<td>Set if this document is a glossary</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fComplex</td>

<td>U16</td>

<td>:1</td>

<td>0x0004</td>

<td>when 1, file is in <b>complex, fast-saved format.</b></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHasPic</td>

<td>U16</td>

<td>:1</td>

<td>0x0008</td>

<td>set if file contains 1 or more pictures</td>
</tr>

<tr>
<td></td>

<td></td>

<td>cQuickSaves</td>

<td>U16</td>

<td>:4</td>

<td>0x00F0</td>

<td>count of times file was quicksaved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEncrypted</td>

<td>U16</td>

<td>:1</td>

<td>0x0100</td>

<td>Set if file is encrypted</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWhichTblStm</td>

<td>U16</td>

<td>:1</td>

<td>0x0200</td>

<td>When 0, this fib refers to the table stream named "0Table", when 1,
this fib refers to the table stream named "1Table". Normally, a file will
have only one table stream, but under unusual circumstances a file may
have table streams with both names. In that case, this flag must be used
to decide which table stream is valid.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fReadOnlyRecommended</td>

<td>U16</td>

<td>:1</td>

<td>0x0400</td>

<td>Set when user has recommended that file be read read-only</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWriteReservation</td>

<td>U16</td>

<td>:1</td>

<td>0x0800</td>

<td>Set when file owner has made the file write reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fExtChar</td>

<td>U16</td>

<td>:1</td>

<td>0x1000</td>

<td>Set when using extended character set in file</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLoadOverride</td>

<td>U16</td>

<td>:1</td>

<td>0x2000</td>

<td>REVIEW</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFarEast</td>

<td>U16</td>

<td>:1</td>

<td>0x4000</td>

<td>REVIEW</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCrypto</td>

<td>U16</td>

<td>:1</td>

<td>0x8000</td>

<td>REVIEW</td>
</tr>

<tr>
<td>12</td>

<td>0x000C</td>

<td>nFibBack</td>

<td>U16</td>

<td></td>

<td></td>

<td>This file format it compatible with readers that understand nFib at
or above this value.</td>
</tr>

<tr>
<td>14</td>

<td>0x000E</td>

<td>lKey</td>

<td>U32</td>

<td></td>

<td></td>

<td>File encrypted key, only valid if fEncrypted.</td>
</tr>

<tr>
<td>18</td>

<td>0x0012</td>

<td>envr</td>

<td>U8</td>

<td></td>

<td></td>

<td>environment in which file was created
<br>0 created by Win Word
<br>1 created by Mac Word</td>
</tr>

<tr>
<td>19</td>

<td>0x0013</td>

<td>fMac</td>

<td>U8</td>

<td>:1</td>

<td>0x01</td>

<td>when 1, this file was last saved in the Mac environment</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEmptySpecial</td>

<td>U8</td>

<td>:1</td>

<td>0x02</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLoadOverridePage</td>

<td>U8</td>

<td>:1</td>

<td>0x04</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFutureSavedUndo</td>

<td>U8</td>

<td>:1</td>

<td>0x08</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWord97Saved</td>

<td>U8</td>

<td>:1</td>

<td>0x10</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fSpare0</td>

<td>U8</td>

<td>:3</td>

<td>0xFE</td>

<td></td>
</tr>

<tr>
<td>20</td>

<td>0x0014</td>

<td>chs</td>

<td>U16</td>

<td></td>

<td></td>

<td>Default extended character set id for text in document stream. (overridden
by chp.chse)
<br>0 by default characters in doc stream should be interpreted using the
ANSI character set used by Windows
<br>256 characters in doc stream should be interpreted using the Macintosh
character set.</td>
</tr>

<tr>
<td>22</td>

<td>0x0016</td>

<td>chsTables</td>

<td>U16</td>

<td></td>

<td></td>

<td>Default extended character set id for text in internal data structures
<br>0 by default characters stored in internal data structures should be
interpreted using the ANSI character set used by Windows
<br>256 characters stored in internal data structures should be interpreted
using the Macintosh character set.</td>
</tr>

<tr>
<td>24</td>

<td>0x0018</td>

<td>fcMin</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of first character of text. In <b>non-complex files</b>
a <b>CP</b> can be transformed into an <b>FC</b> by the following transformation:
<br>fc = cp + fib.fcMin.</td>
</tr>

<tr>
<td>28</td>

<td>0x001C</td>

<td>fcMac</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of last character of text in document text stream + 1</td>
</tr>

<tr>
<td>32</td>

<td>0x0020</td>

<td>csw</td>

<td>U16</td>

<td></td>

<td></td>

<td>Count of fields in the array of "shorts"</td>
</tr>

<tr>
<td>34</td>

<td>0x0022</td>

<td>wMagicCreated</td>

<td>U16</td>

<td></td>

<td></td>

<td>[Beginning of the array of shorts, rgls]
<br>Unique number Identifying the File's creator 0x6A62 is the creator
ID for Word and is reserved. Other creators should choose a different value.</td>
</tr>

<tr>
<td>36</td>

<td>0x0024</td>

<td>wMagicRevised</td>

<td>U16</td>

<td></td>

<td></td>

<td>identifies the File's last modifier</td>
</tr>

<tr>
<td>38</td>

<td>0x0026</td>

<td>wMagicCreatedPrivate</td>

<td>U16</td>

<td></td>

<td></td>

<td>private data</td>
</tr>

<tr>
<td>40</td>

<td>0x0028</td>

<td>wMagicRevisedPrivate</td>

<td>U16</td>

<td></td>

<td></td>

<td>private data</td>
</tr>

<tr>
<td>42</td>

<td>0x002A</td>

<td>pnFbpChpFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>44</td>

<td>0x002C</td>

<td>pnChpFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>46</td>

<td>0x002E</td>

<td>cpnBteChp_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>48</td>

<td>0x0030</td>

<td>pnFbpPapFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>50</td>

<td>0x0032</td>

<td>pnPapFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>52</td>

<td>0x0034</td>

<td>cpnBtePap_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>54</td>

<td>0x0036</td>

<td>pnFbpLvcFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>56</td>

<td>0x0038</td>

<td>pnLvcFirst_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>58</td>

<td>0x003A</td>

<td>cpnBteLvc_W6</td>

<td>U16</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>60</td>

<td>0x003C</td>

<td>lidFE</td>

<td>S16</td>

<td></td>

<td></td>

<td>Language id if document was written by Far East version of Word (i.e.
FIB.fFarEast is on)</td>
</tr>

<tr>
<td>62</td>

<td>0x003E</td>

<td>clw</td>

<td>U16</td>

<td></td>

<td></td>

<td>Number of fields in the array of longs</td>
</tr>

<tr>
<td>64</td>

<td>0x0040</td>

<td>cbMac</td>

<td>U32</td>

<td></td>

<td></td>

<td>[Beginning of the array of longs, rglw]
<br>file offset of last byte written to file + 1.</td>
</tr>

<tr>
<td>68</td>

<td>0x0044</td>

<td>lProductCreated</td>

<td>U32</td>

<td></td>

<td></td>

<td>contains the build date of the creator. 10695 indicates the creator
program was compiled on Jan 6, 1995</td>
</tr>

<tr>
<td>72</td>

<td>0x0048</td>

<td>lProductRevised</td>

<td>U32</td>

<td></td>

<td></td>

<td>contains the build date of the File's last modifier</td>
</tr>

<tr>
<td>76</td>

<td>0x004C</td>

<td>ccpText</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of main document text stream</td>
</tr>

<tr>
<td>80</td>

<td>0x0050</td>

<td>ccpFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of footnote subdocument text stream</td>
</tr>

<tr>
<td>84</td>

<td>0x0054</td>

<td>ccpHdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of header subdocument text stream</td>
</tr>

<tr>
<td>88</td>

<td>0x0058</td>

<td>ccpMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of macro subdocument text stream, which should now always be
0.</td>
</tr>

<tr>
<td>92</td>

<td>0x005C</td>

<td>ccpAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of annotation subdocument text stream</td>
</tr>

<tr>
<td>96</td>

<td>0x0060</td>

<td>ccpEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of endnote subdocument text stream</td>
</tr>

<tr>
<td>100</td>

<td>0x0064</td>

<td>ccpTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of textbox subdocument text stream</td>
</tr>

<tr>
<td>104</td>

<td>0x0068</td>

<td>ccpHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>length of header textbox subdocument text stream.</td>
</tr>

<tr>
<td>108</td>

<td>0x006C</td>

<td>pnFbpChpFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>when there was insufficient memory for Word to expand the plcfbte at
save time, the plcfbte is written to the file in a linked list of 512-byte
pieces starting with this pn</td>
</tr>

<tr>
<td>112</td>

<td>0x0070</td>

<td>pnChpFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>the page number of the lowest numbered page in the document that records
CHPX FKP information</td>
</tr>

<tr>
<td>116</td>

<td>0x0074</td>

<td>cpnBteChp</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of CHPX FKPs recorded in file. In non-complex files if the number
of entries in the plcfbteChpx is less than this, the plcfbteChpx is incomplete.</td>
</tr>

<tr>
<td>120</td>

<td>0x0078</td>

<td>pnFbpPapFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>when there was insufficient memory for Word to expand the plcfbte at
save time, the plcfbte is written to the file in a linked list of 512-byte
pieces starting with this pn</td>
</tr>

<tr>
<td>124</td>

<td>0x007C</td>

<td>pnPapFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>the page number of the lowest numbered page in the document that records
PAPX FKP information</td>
</tr>

<tr>
<td>128</td>

<td>0x0080</td>

<td>cpnBtePap</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of PAPX FKPs recorded in file. In non-complex files if the number
of entries in the plcfbtePapx is less than this, the plcfbtePapx is incomplete.</td>
</tr>

<tr>
<td>132</td>

<td>0x0084</td>

<td>pnFbpLvcFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>when there was insufficient memory for Word to expand the plcfbte at
save time, the plcfbte is written to the file in a linked list of 512-byte
pieces starting with this pn</td>
</tr>

<tr>
<td>136</td>

<td>0x0088</td>

<td>pnLvcFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td>the page number of the lowest numbered page in the document that records
LVC FKP information</td>
</tr>

<tr>
<td>140</td>

<td>0x008C</td>

<td>cpnBteLvc</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of LVC FKPs recorded in file. In non-complex files if the number
of entries in the plcfbtePapx is less than this, the plcfbtePapx is incomplete.</td>
</tr>

<tr>
<td>144</td>

<td>0x0090</td>

<td>fcIslandFirst</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>148</td>

<td>0x0094</td>

<td>fcIslandLim</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>152</td>

<td>0x0098</td>

<td>cfclcb</td>

<td>U16</td>

<td></td>

<td></td>

<td>Number of fields in the array of FC/LCB pairs.</td>
</tr>

<tr>
<td>154</td>

<td>0x009A</td>

<td>fcStshfOrig</td>

<td>U32</td>

<td></td>

<td></td>

<td>[Beginning of array of FC/LCB pairs, rgfclcb]
<br>file offset of original allocation for STSH in table stream. During
fast save Word will attempt to reuse this allocation if STSH is small enough
to fit.</td>
</tr>

<tr>
<td>158</td>

<td>0x009E</td>

<td>lcbStshfOrig</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of original STSH allocation</td>
</tr>

<tr>
<td>162</td>

<td>0x00A2</td>

<td>fcStshf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset of STSH in table stream.</td>
</tr>

<tr>
<td>166</td>

<td>0x00A6</td>

<td>lcbStshf</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of current STSH allocation</td>
</tr>

<tr>
<td>170</td>

<td>0x00AA</td>

<td>fcPlcffndRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of footnote reference PLCF of FRD structures.
CPs in PLC are relative to main document text stream and give location
of footnote references.</td>
</tr>

<tr>
<td>174</td>

<td>0x00AE</td>

<td>lcbPlcffndRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of footnote reference PLC== 0 if no footnotes defined
in document.</td>
</tr>

<tr>
<td>178</td>

<td>0x00B2</td>

<td>fcPlcffndTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of footnote text PLC. CPs in PLC are relative
to footnote subdocument text stream and give location of beginnings of
footnote text for corresponding references recorded in plcffndRef. No structure
is stored in this plc. There will just be <b>n+1</b> <b>FC</b> entries
in this PLC when there are <b>n</b> footnotes</td>
</tr>

<tr>
<td>182</td>

<td>0x00B6</td>

<td>lcbPlcffndTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of footnote text PLC. == 0 if no footnotes defined in
document</td>
</tr>

<tr>
<td>186</td>

<td>0x00BA</td>

<td>fcPlcfandRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of annotation reference ATRD PLC. The CPs recorded
in this PLC give the offset of annotation references in the main document.</td>
</tr>

<tr>
<td>190</td>

<td>0x00BE</td>

<td>lcbPlcfandRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of annotation reference PLC.</td>
</tr>

<tr>
<td>194</td>

<td>0x00C2</td>

<td>fcPlcfandTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of annotation text PLC. The Cps recorded in
this PLC give the offset of the annotation text in the annotation sub document
corresponding to the references stored in the plcfandRef. There is a 1
to 1 correspondence between entries recorded in the plcfandTxt and the
plcfandRef. No structure is stored in this PLC.</td>
</tr>

<tr>
<td>198</td>

<td>0x00C6</td>

<td>lcbPlcfandTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the annotation text PLC</td>
</tr>

<tr>
<td>202</td>

<td>0x00CA</td>

<td>fcPlcfsed</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of section descriptor SED PLC. CPs in PLC are
relative to main document.</td>
</tr>

<tr>
<td>206</td>

<td>0x00CE</td>

<td>lcbPlcfsed</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of section descriptor PLC.</td>
</tr>

<tr>
<td>210</td>

<td>0x00D2</td>

<td>fcPlcfpad</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>214</td>

<td>0x00D6</td>

<td>lcbPlcfpad</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>218</td>

<td>0x00DA</td>

<td>fcPlcfphe</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PHE PLC of paragraph heights. CPs in PLC
are relative to main document text stream. Only written for files in <b>complex</b>
format. Should not be written by third party creators of Word files.</td>
</tr>

<tr>
<td>222</td>

<td>0x00DE</td>

<td>lcbPlcfphe</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of paragraph height PLC. ==0 when file is
<b>non-complex</b>.</td>
</tr>

<tr>
<td>226</td>

<td>0x00E2</td>

<td>fcSttbfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of glossary string table. This table consists
of Pascal style strings (strings stored prefixed with a length byte) concatenated
one after another.</td>
</tr>

<tr>
<td>230</td>

<td>0x00E6</td>

<td>lcbSttbfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of glossary string table. == 0 for non-glossary documents.!=0
for glossary documents.</td>
</tr>

<tr>
<td>234</td>

<td>0x00EA</td>

<td>fcPlcfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of glossary PLC. CPs in PLC are relative to
main document and mark the beginnings of glossary entries and are in 1-1
correspondence with entries of sttbfglsy. No structure is stored in this
PLC. There will be <b>n+1</b> <b>FC</b> entries in this PLC when there
are <b>n</b> glossary entries.</td>
</tr>

<tr>
<td>238</td>

<td>0x00EE</td>

<td>lcbPlcfglsy</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of glossary PLC.== 0 for non-glossary documents.!=0
for glossary documents.</td>
</tr>

<tr>
<td>242</td>

<td>0x00F2</td>

<td>fcPlcfhdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>byte offset in table stream of header HDD PLC. CPs are relative to
header subdocument and mark the beginnings of individual headers in the
header subdocument. No structure is stored in this PLC. There will be <b>n+1FC</b>
entries in this PLC when there are <b>n</b> headers stored for the document.</td>
</tr>

<tr>
<td>246</td>

<td>0x00F6</td>

<td>lcbPlcfhdd</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of header PLC.
<br>== 0 if document contains no headers</td>
</tr>

<tr>
<td>250</td>

<td>0x00FA</td>

<td>fcPlcfbteChpx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of character property bin table.PLC. FCs in
PLC are file offsets in the main stream. Describes text of main document
and all subdocuments.</td>
</tr>

<tr>
<td>254</td>

<td>0x00FE</td>

<td>lcbPlcfbteChpx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of character property bin table PLC.</td>
</tr>

<tr>
<td>258</td>

<td>0x0102</td>

<td>fcPlcfbtePapx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of paragraph property bin table.PLC. FCs in
PLC are file offsets in the main stream. Describes text of main document
and all subdocuments.</td>
</tr>

<tr>
<td>262</td>

<td>0x0106</td>

<td>lcbPlcfbtePapx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of paragraph property bin table PLC</td>
</tr>

<tr>
<td>266</td>

<td>0x010A</td>

<td>fcPlcfsea</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PLC reserved for private use. The <b>SEA</b>
is 6 bytes long.</td>
</tr>

<tr>
<td>270</td>

<td>0x010E</td>

<td>lcbPlcfsea</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of private use PLC.</td>
</tr>

<tr>
<td>274</td>

<td>0x0112</td>

<td>fcSttbfffn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of font information STTBF. The sttbfffn is a
STTBF where is string is actually an FFN structure. The <b>n</b>th entry
in the STTBF describes the font that will be displayed when the chp.ftc
for text is equal to <b>n.</b> See the FFN file structure definition.</td>
</tr>

<tr>
<td>278</td>

<td>0x0116</td>

<td>lcbSttbfffn</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in sttbfffn.</td>
</tr>

<tr>
<td>282</td>

<td>0x011A</td>

<td>fcPlcffldMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to the FLD PLC of field positions in the main
document. The CPs point to the beginning CP of a field, the CP of field
separator character inside a field and the ending CP of the field. A field
may be nested within another field. 20 levels of field nesting are allowed.</td>
</tr>

<tr>
<td>286</td>

<td>0x011E</td>

<td>lcbPlcffldMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in plcffldMom</td>
</tr>

<tr>
<td>290</td>

<td>0x0122</td>

<td>fcPlcffldHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to the FLD PLC of field positions in the header
subdocument.</td>
</tr>

<tr>
<td>294</td>

<td>0x0126</td>

<td>lcbPlcffldHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in plcffldHdr</td>
</tr>

<tr>
<td>298</td>

<td>0x012A</td>

<td>fcPlcffldFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to the FLD PLC of field positions in the footnote
subdocument.</td>
</tr>

<tr>
<td>302</td>

<td>0x012E</td>

<td>lcbPlcffldFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in plcffldFtn</td>
</tr>

<tr>
<td>306</td>

<td>0x0132</td>

<td>fcPlcffldAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to the FLD PLC of field positions in the annotation
subdocument.</td>
</tr>

<tr>
<td>310</td>

<td>0x0136</td>

<td>lcbPlcffldAtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes in plcffldAtn</td>
</tr>

<tr>
<td>314</td>

<td>0x013A</td>

<td>fcPlcffldMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>318</td>

<td>0x013E</td>

<td>lcbPlcffldMcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>322</td>

<td>0x0142</td>

<td>fcSttbfbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the STTBF that records bookmark names in
the main document</td>
</tr>

<tr>
<td>326</td>

<td>0x0146</td>

<td>lcbSttbfbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>330</td>

<td>0x014A</td>

<td>fcPlcfbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLCF that records the beginning CP offsets
of bookmarks in the main document. See BKF structure definition</td>
</tr>

<tr>
<td>334</td>

<td>0x014E</td>

<td>lcbPlcfbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>338</td>

<td>0x0152</td>

<td>fcPlcfbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLCF that records the ending CP offsets
of bookmarks recorded in the main document. No structure is stored in this
PLCF.</td>
</tr>

<tr>
<td>342</td>

<td>0x0156</td>

<td>lcbPlcfbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>346</td>

<td>0x015A</td>

<td>fcCmds</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the macro commands. These commands are private
and undocumented.</td>
</tr>

<tr>
<td>350</td>

<td>0x015E</td>

<td>lcbCmds</td>

<td>U32</td>

<td></td>

<td></td>

<td>undocument size of undocument structure not documented above</td>
</tr>

<tr>
<td>354</td>

<td>0x0162</td>

<td>fcPlcmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>358</td>

<td>0x0166</td>

<td>lcbPlcmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>362</td>

<td>0x016A</td>

<td>fcSttbfmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>366</td>

<td>0x016E</td>

<td>lcbSttbfmcr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>370</td>

<td>0x0172</td>

<td>fcPrDrvr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the printer driver information (names of
drivers, port, etc.)</td>
</tr>

<tr>
<td>374</td>

<td>0x0176</td>

<td>lcbPrDrvr</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the printer driver information (names of drivers,
port, etc.)</td>
</tr>

<tr>
<td>378</td>

<td>0x017A</td>

<td>fcPrEnvPort</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the print environment in portrait mode.</td>
</tr>

<tr>
<td>382</td>

<td>0x017E</td>

<td>lcbPrEnvPort</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the print environment in portrait mode.</td>
</tr>

<tr>
<td>386</td>

<td>0x0182</td>

<td>fcPrEnvLand</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the print environment in landscape mode.</td>
</tr>

<tr>
<td>390</td>

<td>0x0186</td>

<td>lcbPrEnvLand</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the print environment in landscape mode.</td>
</tr>

<tr>
<td>394</td>

<td>0x018A</td>

<td>fcWss</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of <b>W</b>indow <b>S</b>ave <b>S</b>tate data
structure. <b>WSS</b> contains dimensions of document's main text window
and the last selection made by Word user.</td>
</tr>

<tr>
<td>398</td>

<td>0x018E</td>

<td>lcbWss</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of WSS. ==0 if unable to store the window state. Should
not be written by third party creators of Word files.</td>
</tr>

<tr>
<td>402</td>

<td>0x0192</td>

<td>fcDop</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of document property data structure.</td>
</tr>

<tr>
<td>406</td>

<td>0x0196</td>

<td>lcbDop</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of document properties.</td>
</tr>

<tr>
<td>410</td>

<td>0x019A</td>

<td>fcSttbfAssoc</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of STTBF of associated strings. The strings
in this table specify document summary info and the paths to special documents
related to this document. See documentation of the STTBFASSOC.</td>
</tr>

<tr>
<td>414</td>

<td>0x019E</td>

<td>lcbSttbfAssoc</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>418</td>

<td>0x01A2</td>

<td>fcClx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of beginning of information for <b>complex</b>
files. Consists of an encoding of all of the <b>prm</b>s quoted by the
document followed by the <b>plcpcd</b> (piece table) for the document.</td>
</tr>

<tr>
<td>422</td>

<td>0x01A6</td>

<td>lcbClx</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of complex file information == 0 if file is <b>non-complex</b>.</td>
</tr>

<tr>
<td>426</td>

<td>0x01AA</td>

<td>fcPlcfpgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>430</td>

<td>0x01AE</td>

<td>lcbPlcfpgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>434</td>

<td>0x01B2</td>

<td>fcAutosaveSource</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the name of the original file. fcAutosaveSource
and cbAutosaveSource should both be 0 if autosave is off.</td>
</tr>

<tr>
<td>438</td>

<td>0x01B6</td>

<td>lcbAutosaveSource</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the name of the original file.</td>
</tr>

<tr>
<td>442</td>

<td>0x01BA</td>

<td>fcGrpXstAtnOwners</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of group of strings recording the names of the
owners of annotations stored in the document</td>
</tr>

<tr>
<td>446</td>

<td>0x01BE</td>

<td>lcbGrpXstAtnOwners</td>

<td>U32</td>

<td></td>

<td></td>

<td>count of bytes of the group of strings</td>
</tr>

<tr>
<td>450</td>

<td>0x01C2</td>

<td>fcSttbfAtnbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the sttbf that records names of bookmarks
for the annotation subdocument</td>
</tr>

<tr>
<td>454</td>

<td>0x01C6</td>

<td>lcbSttbfAtnbkmk</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the sttbf that records names of bookmarks for the
annotation subdocument</td>
</tr>

<tr>
<td>458</td>

<td>0x01CA</td>

<td>fcPlcdoaMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>462</td>

<td>0x01CE</td>

<td>lcbPlcdoaMom</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>466</td>

<td>0x01D2</td>

<td>fcPlcdoaHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>470</td>

<td>0x01D6</td>

<td>lcbPlcdoaHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>474</td>

<td>0x01DA</td>

<td>fcPlcspaMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the <b>FSPA</b> PLC for main document. ==
0 if document has no office art objects.</td>
</tr>

<tr>
<td>478</td>

<td>0x01DE</td>

<td>lcbPlcspaMom</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the <b>FSPA</b> PLC of the main document.</td>
</tr>

<tr>
<td>482</td>

<td>0x01E2</td>

<td>fcPlcspaHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the <b>FSPA</b> PLC for header document.
== 0 if document has no office art objects.</td>
</tr>

<tr>
<td>486</td>

<td>0x01E6</td>

<td>lcbPlcspaHdr</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the <b>FSPA</b> PLC of the header document.</td>
</tr>

<tr>
<td>490</td>

<td>0x01EA</td>

<td>fcPlcfAtnbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of BKF (bookmark first) PLC of the annotation
subdocument</td>
</tr>

<tr>
<td>494</td>

<td>0x01EE</td>

<td>lcbPlcfAtnbkf</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of BKF (bookmark first) PLC of the annotation subdocument</td>
</tr>

<tr>
<td>498</td>

<td>0x01F2</td>

<td>fcPlcfAtnbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of BKL (bookmark last) PLC of the annotation
subdocument</td>
</tr>

<tr>
<td>502</td>

<td>0x01F6</td>

<td>lcbPlcfAtnbkl</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of PLC marking the CP limits of the annotation bookmarks.
No structure is stored in this PLC.</td>
</tr>

<tr>
<td>506</td>

<td>0x01FA</td>

<td>fcPms</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PMS (Print Merge State) information block.
This contains the current state of a print merge operation</td>
</tr>

<tr>
<td>510</td>

<td>0x01FE</td>

<td>lcbPms</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of PMS. ==0 if no current print merge state. Should
not be written by third party creators of Word files.</td>
</tr>

<tr>
<td>514</td>

<td>0x0202</td>

<td>fcFormFldSttbf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of form field Sttbf which contains strings used
in form field dropdown controls</td>
</tr>

<tr>
<td>518</td>

<td>0x0206</td>

<td>lcbFormFldSttbf</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of form field Sttbf</td>
</tr>

<tr>
<td>522</td>

<td>0x020A</td>

<td>fcPlcfendRef</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of endnote reference PLCF of FRD structures.
CPs in PLCF are relative to main document text stream and give location
of endnote references.</td>
</tr>

<tr>
<td>526</td>

<td>0x020E</td>

<td>lcbPlcfendRef</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>530</td>

<td>0x0212</td>

<td>fcPlcfendTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PlcfendRef which points to endnote text in
the endnote document stream which corresponds with the plcfendRef. No structure
is stored in this PLC.</td>
</tr>

<tr>
<td>534</td>

<td>0x0216</td>

<td>lcbPlcfendTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>538</td>

<td>0x021A</td>

<td>fcPlcffldEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to FLD PLCF of field positions in the endnote
subdoc</td>
</tr>

<tr>
<td>542</td>

<td>0x021E</td>

<td>lcbPlcffldEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>546</td>

<td>0x0222</td>

<td>fcPlcfpgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>not used</td>
</tr>

<tr>
<td>550</td>

<td>0x0226</td>

<td>lcbPlcfpgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>554</td>

<td>0x022A</td>

<td>fcDggInfo</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the office art object table data. The format
of office art object table data is found in a separate document.</td>
</tr>

<tr>
<td>558</td>

<td>0x022E</td>

<td>lcbDggInfo</td>

<td>U32</td>

<td></td>

<td></td>

<td>length in bytes of the office art object table data</td>
</tr>

<tr>
<td>562</td>

<td>0x0232</td>

<td>fcSttbfRMark</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to STTBF that records the author abbreviations
for authors who have made revisions in the document.</td>
</tr>

<tr>
<td>566</td>

<td>0x0236</td>

<td>lcbSttbfRMark</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>570</td>

<td>0x023A</td>

<td>fcSttbfCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to STTBF that records caption titles used in
the document.</td>
</tr>

<tr>
<td>574</td>

<td>0x023E</td>

<td>lcbSttbfCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>578</td>

<td>0x0242</td>

<td>fcSttbfAutoCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to the STTBF that records the object names and
indices into the caption STTBF for objects which get auto captions.</td>
</tr>

<tr>
<td>582</td>

<td>0x0246</td>

<td>lcbSttbfAutoCaption</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>586</td>

<td>0x024A</td>

<td>fcPlcfwkb</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream to WKB PLCF that describes the boundaries of
contributing documents in a master document</td>
</tr>

<tr>
<td>590</td>

<td>0x024E</td>

<td>lcbPlcfwkb</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>594</td>

<td>0x0252</td>

<td>fcPlcfspl</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PLCF (of SPLS structures) that records spell
check state</td>
</tr>

<tr>
<td>598</td>

<td>0x0256</td>

<td>lcbPlcfspl</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>602</td>

<td>0x025A</td>

<td>fcPlcftxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PLCF that records the beginning CP in the
text box subdoc of the text of individual text box entries. No structure
is stored in this PLCF</td>
</tr>

<tr>
<td>606</td>

<td>0x025E</td>

<td>lcbPlcftxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>610</td>

<td>0x0262</td>

<td>fcPlcffldTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the FLD PLCF that records field boundaries
recorded in the textbox subdoc.</td>
</tr>

<tr>
<td>614</td>

<td>0x0266</td>

<td>lcbPlcffldTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>618</td>

<td>0x026A</td>

<td>fcPlcfHdrtxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PLCF that records the beginning CP in the
header text box subdoc of the text of individual header text box entries.
No structure is stored in this PLC.</td>
</tr>

<tr>
<td>622</td>

<td>0x026E</td>

<td>lcbPlcfHdrtxbxTxt</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>626</td>

<td>0x0272</td>

<td>fcPlcffldHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the FLD PLCF that records field boundaries
recorded in the header textbox subdoc.</td>
</tr>

<tr>
<td>630</td>

<td>0x0276</td>

<td>lcbPlcffldHdrTxbx</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>634</td>

<td>0x027A</td>

<td>fcStwUser</td>

<td>U32</td>

<td></td>

<td></td>

<td>Macro User storage</td>
</tr>

<tr>
<td>638</td>

<td>0x027E</td>

<td>lcbStwUser</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>642</td>

<td>0x0282</td>

<td>fcSttbttmbd</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of embedded true type font data.</td>
</tr>

<tr>
<td>646</td>

<td>0x0286</td>

<td>lcbSttbttmbd</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>650</td>

<td>0x028A</td>

<td>fcUnused</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>654</td>

<td>0x028E</td>

<td>lcbUnused</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>658</td>

<td>0x0292</td>

<td>fcPgdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td>(FCPGD, beginning of array of fcPgd / fcBkd pairs rgpgdbkd).
<br>offset in table stream of the PLF that records the page descriptors
for the main text of the doc.</td>
</tr>

<tr>
<td>662</td>

<td>0x0296</td>

<td>lcbPgdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>666</td>

<td>0x029A</td>

<td>fcBkdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLCF that records the break descriptors
for the main text of the doc.</td>
</tr>

<tr>
<td>670</td>

<td>0x029E</td>

<td>lcbBkdMother</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>674</td>

<td>0x02A2</td>

<td>fcPgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLF that records the page descriptors
for the footnote text of the doc.</td>
</tr>

<tr>
<td>678</td>

<td>0x02A6</td>

<td>lcbPgdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>682</td>

<td>0x02AA</td>

<td>fcBkdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLCF that records the break descriptors
for the footnote text of the doc.</td>
</tr>

<tr>
<td>686</td>

<td>0x02AE</td>

<td>lcbBkdFtn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>690</td>

<td>0x02B2</td>

<td>fcPgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLF that records the page descriptors
for the endnote text of the doc.</td>
</tr>

<tr>
<td>694</td>

<td>0x02B6</td>

<td>lcbPgdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>698</td>

<td>0x02BA</td>

<td>fcBkdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the PLCF that records the break descriptors
for the endnote text of the doc.</td>
</tr>

<tr>
<td>702</td>

<td>0x02BE</td>

<td>lcbBkdEdn</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>706</td>

<td>0x02C2</td>

<td>fcSttbfIntlFld</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of the STTBF containing field keywords. This
is only used in a small number of the international versions of word. This
field is no longer written to the file for nFib >= 167.</td>
</tr>

<tr>
<td>710</td>

<td>0x02C6</td>

<td>lcbSttbfIntlFld</td>

<td>U32</td>

<td></td>

<td></td>

<td>Always 0 for nFib >= 167.</td>
</tr>

<tr>
<td>714</td>

<td>0x02CA</td>

<td>fcRouteSlip</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of a mailer routing slip.</td>
</tr>

<tr>
<td>718</td>

<td>0x02CE</td>

<td>lcbRouteSlip</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>722</td>

<td>0x02D2</td>

<td>fcSttbSavedBy</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of STTBF recording the names of the users who
have saved this document alternating with the save locations.</td>
</tr>

<tr>
<td>726</td>

<td>0x02D6</td>

<td>lcbSttbSavedBy</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>730</td>

<td>0x02DA</td>

<td>fcSttbFnm</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of STTBF recording filenames of documents which
are referenced by this document.</td>
</tr>

<tr>
<td>734</td>

<td>0x02DE</td>

<td>lcbSttbFnm</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>738</td>

<td>0x02E2</td>

<td>fcPlcfLst</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in the table stream of list format information.</td>
</tr>

<tr>
<td>742</td>

<td>0x02E6</td>

<td>lcbPlcfLst</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>746</td>

<td>0x02EA</td>

<td>fcPlfLfo</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in the table stream of list format override information.</td>
</tr>

<tr>
<td>750</td>

<td>0x02EE</td>

<td>lcbPlfLfo</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>754</td>

<td>0x02F2</td>

<td>fcPlcftxbxBkd</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in the table stream of the textbox break table (a PLCF of BKDs)
for the main document</td>
</tr>

<tr>
<td>758</td>

<td>0x02F6</td>

<td>lcbPlcftxbxBkd</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>762</td>

<td>0x02FA</td>

<td>fcPlcftxbxHdrBkd</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in the table stream of the textbox break table (a PLCF of BKDs)
for the header subdocument</td>
</tr>

<tr>
<td>766</td>

<td>0x02FE</td>

<td>lcbPlcftxbxHdrBkd</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>770</td>

<td>0x0302</td>

<td>fcDocUndo</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in main stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>774</td>

<td>0x0306</td>

<td>lcbDocUndo</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>778</td>

<td>0x030A</td>

<td>fcRgbuse</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in main stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>782</td>

<td>0x030E</td>

<td>lcbRgbuse</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>786</td>

<td>0x0312</td>

<td>fcUsp</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in main stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>790</td>

<td>0x0316</td>

<td>lcbUsp</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>794</td>

<td>0x031A</td>

<td>fcUskf</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>798</td>

<td>0x031E</td>

<td>lcbUskf</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>802</td>

<td>0x0322</td>

<td>fcPlcupcRgbuse</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>806</td>

<td>0x0326</td>

<td>lcbPlcupcRgbuse</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>810</td>

<td>0x032A</td>

<td>fcPlcupcUsp</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>814</td>

<td>0x032E</td>

<td>lcbPlcupcUsp</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>818</td>

<td>0x0332</td>

<td>fcSttbGlsyStyle</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of string table of style names for glossary
entries</td>
</tr>

<tr>
<td>822</td>

<td>0x0336</td>

<td>lcbSttbGlsyStyle</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>826</td>

<td>0x033A</td>

<td>fcPlgosl</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented grammar options PL</td>
</tr>

<tr>
<td>830</td>

<td>0x033E</td>

<td>lcbPlgosl</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>834</td>

<td>0x0342</td>

<td>fcPlcocx</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented ocx data</td>
</tr>

<tr>
<td>838</td>

<td>0x0346</td>

<td>lcbPlcocx</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>842</td>

<td>0x034A</td>

<td>fcPlcfbteLvc</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of character property bin table.PLC. FCs in
PLC are file offsets. Describes text of main document and all subdocuments.</td>
</tr>

<tr>
<td>846</td>

<td>0x034E</td>

<td>lcbPlcfbteLvc</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>850</td>

<td>0x0352</td>

<td>dwLowDateTime</td>

<td>U32</td>

<td></td>

<td></td>

<td>(a.k.a FILETIME ftModified)</td>
</tr>

<tr>
<td>854</td>

<td>0x0356</td>

<td>dwHighDateTime</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>858</td>

<td>0x035A</td>

<td>fcPlcflvc</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of LVC PLCF</td>
</tr>

<tr>
<td>862</td>

<td>0x035E</td>

<td>lcbPlcflvc</td>

<td>U32</td>

<td></td>

<td></td>

<td>size of LVC PLCF, ==0 for <b>non-complex</b> files</td>
</tr>

<tr>
<td>866</td>

<td>0x0362</td>

<td>fcPlcasumy</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of autosummary ASUMY PLCF.</td>
</tr>

<tr>
<td>870</td>

<td>0x0366</td>

<td>lcbPlcasumy</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>874</td>

<td>0x036A</td>

<td>fcPlcfgram</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of PLCF (of SPLS structures) which records grammar
check state</td>
</tr>

<tr>
<td>878</td>

<td>0x036E</td>

<td>lcbPlcfgram</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>882</td>

<td>0x0372</td>

<td>fcSttbListNames</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of list names string table</td>
</tr>

<tr>
<td>886</td>

<td>0x0376</td>

<td>lcbSttbListNames</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>890</td>

<td>0x037A</td>

<td>fcSttbfUssr</td>

<td>U32</td>

<td></td>

<td></td>

<td>offset in table stream of undocumented undo / versioning data</td>
</tr>

<tr>
<td>894</td>

<td>0x037E</td>

<td>lcbSttbfUssr</td>

<td>U32</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>cbFIB (count of bytes of FIB) is 898 (decimal), 382 (hex).
<h4>
Note</h4>
If a table does not exist in the file, its cb in the FIB is zero and its
fc is equal to that of the following table (the latter equality is irrelevant,
as the cb should be used to determine existence of the table).
<h3>
File Information FC/LCB pair (FIBFCLCB)</h3>
The <b>FIBFCLCB</b> structure, used in the last array in the FIB:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>Name</td>

<td>type</td>

<td>Bitfield Size</td>

<td>Bitfield Mask</td>

<td>Comments</td>
</tr>

<tr>
<td>0</td>

<td>0x0000</td>

<td>fc</td>

<td>U32</td>

<td></td>

<td></td>

<td>File position where data begins.</td>
</tr>

<tr>
<td>4</td>

<td>0x0004</td>

<td>lcb</td>

<td>U32</td>

<td></td>

<td></td>

<td>Size of data. Ignore fc if lcb is zero.</td>
</tr>
</table>

<p><a NAME="54"></a>
<h3>
Field Descriptor (FLD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>ch</td>

<td>U8</td>

<td>:5</td>

<td>1F</td>

<td>type of field boundary the FLD describes:
<br>19 field begin mark
<br>20 field separator mark
<br>21 field end mark</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_5</td>

<td>U8</td>

<td>:3</td>

<td>E0</td>

<td>reserved</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>flt</td>

<td>S8</td>

<td></td>

<td></td>

<td>fld.ch == 19 (field begin mark) -> U8 field type (see flt table below).
<br>fld.ch == 20 (field separator mark) -> not present
<br>fld.ch == 21 (field end mark) ->
<br>fDiffer:1 - ignored for saved file
<br>fZombieEmbed:1 - 1 when result still believes this field is an EMBED
or LINK field.
<br>fResultDirty:1 -&nbsp; when user has edited or formatted the result.
== 0 otherwise.
<br>fResultEdited:1 - 1 when user has inserted text into or deleted text
from the result.
<br>fLocked:1 - 1 when field is locked from recalc.
<br>fPrivateResult:1 - 1 whenever the result of the field is never to be
shown.
<br>fNested:1 - 1 when field is nested within another field.
<br>fHasSep:1 - 1 when field has a field separator.</td>
</tr>
</table>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>flt value</td>

<td>live/dead</td>

<td>field type</td>
</tr>

<tr>
<td>1</td>

<td></td>

<td>unknown keyword</td>
</tr>

<tr>
<td>2</td>

<td>live</td>

<td>possible bookmark (syntax matches bookmark name)</td>
</tr>

<tr>
<td>3</td>

<td>live</td>

<td>bookmark reference</td>
</tr>

<tr>
<td>4</td>

<td>dead</td>

<td>index entry</td>
</tr>

<tr>
<td>5</td>

<td>live</td>

<td>footnote reference</td>
</tr>

<tr>
<td>6</td>

<td>live</td>

<td>Set command (for Print Merge)</td>
</tr>

<tr>
<td>7</td>

<td>live</td>

<td>If command (for Print Merge)</td>
</tr>

<tr>
<td>8</td>

<td>live</td>

<td>create index</td>
</tr>

<tr>
<td>9</td>

<td>dead</td>

<td>table of contents entry</td>
</tr>

<tr>
<td>10</td>

<td>live</td>

<td>Style reference</td>
</tr>

<tr>
<td>11</td>

<td>dead</td>

<td>document reference</td>
</tr>

<tr>
<td>12</td>

<td>live</td>

<td>sequence mark</td>
</tr>

<tr>
<td>13</td>

<td>live</td>

<td>create table-of-contents</td>
</tr>

<tr>
<td>14</td>

<td>live</td>

<td>quote Info variable</td>
</tr>

<tr>
<td>15</td>

<td>live</td>

<td>quote Title variable</td>
</tr>

<tr>
<td>16</td>

<td>live</td>

<td>quote Subject variable</td>
</tr>

<tr>
<td>17</td>

<td>live</td>

<td>quote Author variable</td>
</tr>

<tr>
<td>18</td>

<td>live</td>

<td>quote Keywords variable</td>
</tr>

<tr>
<td>19</td>

<td>live</td>

<td>quote Comments variable</td>
</tr>

<tr>
<td>20</td>

<td>live</td>

<td>quote Last Revised By variable</td>
</tr>

<tr>
<td>21</td>

<td>live</td>

<td>quote Creation Date variable</td>
</tr>

<tr>
<td>22</td>

<td>live</td>

<td>quote Revision Date variable</td>
</tr>

<tr>
<td>23</td>

<td>live</td>

<td>quote Print Date variable</td>
</tr>

<tr>
<td>24</td>

<td>live</td>

<td>quote Revision Number variable</td>
</tr>

<tr>
<td>25</td>

<td>live</td>

<td>quote Edit Time variable</td>
</tr>

<tr>
<td>26</td>

<td>live</td>

<td>quote Number of Pages variable</td>
</tr>

<tr>
<td>27</td>

<td>live</td>

<td>quote Number of Words variable</td>
</tr>

<tr>
<td>28</td>

<td>live</td>

<td>quote Number of Characters variable</td>
</tr>

<tr>
<td>29</td>

<td>live</td>

<td>quote File Name variable</td>
</tr>

<tr>
<td>30</td>

<td>live</td>

<td>quote Document Template Name variable</td>
</tr>

<tr>
<td>31</td>

<td>live</td>

<td>quote Current Date variable</td>
</tr>

<tr>
<td>32</td>

<td>live</td>

<td>quote Current Time variable</td>
</tr>

<tr>
<td>33</td>

<td>live</td>

<td>quote Current Page variable</td>
</tr>

<tr>
<td>34</td>

<td>live</td>

<td>evaluate expression</td>
</tr>

<tr>
<td>35</td>

<td>live</td>

<td>insert literal text</td>
</tr>

<tr>
<td>36</td>

<td>live</td>

<td>Include command (Print Merge)</td>
</tr>

<tr>
<td>37</td>

<td>live</td>

<td>page reference</td>
</tr>

<tr>
<td>38</td>

<td>live</td>

<td>Ask command (Print Merge)</td>
</tr>

<tr>
<td>39</td>

<td>live</td>

<td>Fill-in command to display prompt (Print Merge)</td>
</tr>

<tr>
<td>40</td>

<td>live</td>

<td>Data command (Print Merge)</td>
</tr>

<tr>
<td>41</td>

<td>live</td>

<td>Next command (Print Merge)</td>
</tr>

<tr>
<td>42</td>

<td>live</td>

<td>NextIf command (Print Merge)</td>
</tr>

<tr>
<td>43</td>

<td>live</td>

<td>SkipIf (Print Merge)</td>
</tr>

<tr>
<td>44</td>

<td>live</td>

<td>inserts number of current Print Merge record</td>
</tr>

<tr>
<td>45</td>

<td>live</td>

<td>DDE reference</td>
</tr>

<tr>
<td>46</td>

<td>live</td>

<td>DDE automatic reference</td>
</tr>

<tr>
<td>47</td>

<td>live</td>

<td>Inserts Glossary Entry</td>
</tr>

<tr>
<td>48</td>

<td>live</td>

<td>sends characters to printer without translation</td>
</tr>

<tr>
<td>49</td>

<td>live</td>

<td>Formula definition</td>
</tr>

<tr>
<td>50</td>

<td>live</td>

<td>Goto Button</td>
</tr>

<tr>
<td>51</td>

<td>live</td>

<td>Macro Button</td>
</tr>

<tr>
<td>52</td>

<td>live</td>

<td>insert auto numbering field in outline format</td>
</tr>

<tr>
<td>53</td>

<td>live</td>

<td>insert auto numbering field in legal format</td>
</tr>

<tr>
<td>54</td>

<td>live</td>

<td>insert auto numbering field in Arabic number format</td>
</tr>

<tr>
<td>55</td>

<td>live</td>

<td>reads a TIFF file</td>
</tr>

<tr>
<td>56</td>

<td>live</td>

<td>Link</td>
</tr>

<tr>
<td>57</td>

<td>live</td>

<td>Symbol</td>
</tr>

<tr>
<td>58</td>

<td>live</td>

<td>Embedded Object</td>
</tr>

<tr>
<td>59</td>

<td>live</td>

<td>Merge fields</td>
</tr>

<tr>
<td>60</td>

<td>live</td>

<td>User Name</td>
</tr>

<tr>
<td>61</td>

<td>live</td>

<td>User Initial</td>
</tr>

<tr>
<td>62</td>

<td>live</td>

<td>User Address</td>
</tr>

<tr>
<td>63</td>

<td>live</td>

<td>Bar code</td>
</tr>

<tr>
<td>64</td>

<td>live</td>

<td>Document variable</td>
</tr>

<tr>
<td>65</td>

<td>live</td>

<td>Section</td>
</tr>

<tr>
<td>66</td>

<td>live</td>

<td>Section pages</td>
</tr>

<tr>
<td>67</td>

<td>live</td>

<td>Include Picture</td>
</tr>

<tr>
<td>68</td>

<td>live</td>

<td>Include Text</td>
</tr>

<tr>
<td>69</td>

<td>live</td>

<td>File Size</td>
</tr>

<tr>
<td>70</td>

<td>live</td>

<td>Form Text Box</td>
</tr>

<tr>
<td>71</td>

<td>live</td>

<td>Form Check Box</td>
</tr>

<tr>
<td>72</td>

<td>live</td>

<td>Note Reference</td>
</tr>

<tr>
<td>73</td>

<td>live</td>

<td>Create Table of Authorities</td>
</tr>

<tr>
<td>74</td>

<td>dead</td>

<td>Mark Table of Authorities Entry</td>
</tr>

<tr>
<td>75</td>

<td>live</td>

<td>Merge record sequence number</td>
</tr>

<tr>
<td>76</td>

<td>either</td>

<td>Macro</td>
</tr>

<tr>
<td>77</td>

<td>dead</td>

<td>Private</td>
</tr>

<tr>
<td>78</td>

<td>live</td>

<td>Insert Database</td>
</tr>

<tr>
<td>79</td>

<td>live</td>

<td>Autotext</td>
</tr>

<tr>
<td>80</td>

<td>live</td>

<td>Compare two values</td>
</tr>

<tr>
<td>81</td>

<td>live</td>

<td>Plug-in module private</td>
</tr>

<tr>
<td>82</td>

<td>live</td>

<td>Subscriber</td>
</tr>

<tr>
<td>83</td>

<td>live</td>

<td>Form List Box</td>
</tr>

<tr>
<td>84</td>

<td>live</td>

<td>Advance</td>
</tr>

<tr>
<td>85</td>

<td>live</td>

<td>Document property</td>
</tr>

<tr>
<td>86</td>

<td>live</td>

<td></td>
</tr>

<tr>
<td>87</td>

<td>live</td>

<td>OCX</td>
</tr>

<tr>
<td>88</td>

<td>live</td>

<td>Hyperlink</td>
</tr>

<tr>
<td>89</td>

<td>live</td>

<td>AutoTextList</td>
</tr>

<tr>
<td>90</td>

<td>live</td>

<td>List element</td>
</tr>

<tr>
<td>91</td>

<td>live</td>

<td>HTML control</td>
</tr>
</table>

<p>Since dead fields have no entry in the plcffld, the string in the field
code must be used to determine the field type. All versions of Word '97
use English field code strings, except French, German, and Spanish versions
of Word. The strings for all languages for all possible dead fields are
listed below.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>flt value</td>

<td>English string</td>

<td>French string</td>

<td>German string</td>

<td>Spanish string</td>

<td>field type</td>
</tr>

<tr>
<td>4</td>

<td>XE</td>

<td>EX</td>

<td>XE</td>

<td>E</td>

<td>index entry</td>
</tr>

<tr>
<td>9</td>

<td>TC</td>

<td>TE</td>

<td>INHALT</td>

<td>TC</td>

<td>table of contents entry</td>
</tr>

<tr>
<td>11</td>

<td>RD</td>

<td>RD</td>

<td>RD</td>

<td>RD</td>

<td>document reference</td>
</tr>

<tr>
<td>74</td>

<td>TA</td>

<td>TA</td>

<td>TA</td>

<td>TA</td>

<td>Mark Table of Authorities Entry</td>
</tr>

<tr>
<td>76</td>

<td></td>

<td></td>

<td></td>

<td></td>

<td>Macro</td>
</tr>

<tr>
<td>77</td>

<td>PRIVATE</td>

<td>PRIVE</td>

<td>PRIVATE</td>

<td>PRIVATESPA</td>

<td>Private</td>
</tr>
</table>
<a NAME="58"></a>
<h3>
Footnote Reference Descriptor (FRD)</h3>
The FRD is stored in both the plcffndRef and the plcfendRef
<!-- sizeOf="2" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>nAuto</td>

<td>S16</td>

<td></td>

<td></td>

<td>if > 0, the note is an automatically numbered note, otherwise it has
a custom mark</td>
</tr>
</table>
<a NAME="55"></a>
<h3>
File Shape Address (FSPA)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>spid</td>

<td>S32</td>

<td></td>

<td></td>

<td>Shape Identifier. Used in conjunction with the office art data (found
via <b>fcDggInfo</b> in the <b>FIB</b>) to find the actual data for this
shape.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>xaLeft</td>

<td>S32</td>

<td></td>

<td></td>

<td>xa left of rectangle enclosing shape relative to the origin of the
shape</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>yaTop</td>

<td>S32</td>

<td></td>

<td></td>

<td>ya top of rectangle enclosing shape relative to the origin of the shape</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>xaRight</td>

<td>S32</td>

<td></td>

<td></td>

<td>xa right of rectangle enclosing shape relative to the origin of the
shape</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>yaBottom</td>

<td>S32</td>

<td></td>

<td></td>

<td>ya bottom of the rectangle enclosing shape relative to the origin of
the shape</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>fHdr</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 in the undo doc when shape is from the header doc, 0 otherwise (undefined
when not in the undo doc)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>bx</td>

<td>U16</td>

<td>:2</td>

<td>0006</td>

<td>x position of shape relative to anchor CP
<br>0 relative to page margin
<br>1 relative to top of page
<br>2 relative to text (column for horizontal text; paragraph for vertical
text)
<br>3 reserved for future use</td>
</tr>

<tr>
<td></td>

<td></td>

<td>by</td>

<td>U16</td>

<td>:2</td>

<td>0018</td>

<td>y position of shape relative to anchor CP
<br>0 relative to page margin
<br>1 relative to top of page
<br>2 relative to text (paragraph for horizontal text; column for vertical
text)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wr</td>

<td>U16</td>

<td>:4</td>

<td>01E0</td>

<td>text wrapping mode
<br>0 like 2, but doesn't require absolute object
<br>1 no text next to shape
<br>2 wrap around absolute object
<br>3 wrap as if no object present
<br>4 wrap tightly around object
<br>5 wrap tightly, but allow holes
<br>6-15 reserved for future use</td>
</tr>

<tr>
<td></td>

<td></td>

<td>wrk</td>

<td>U16</td>

<td>:4</td>

<td>1E00</td>

<td>text wrapping mode type (valid only for wrapping modes 2 and 4
<br>0 wrap both sides
<br>1 wrap only on left
<br>2 wrap only on right
<br>3 wrap only on largest side</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRcaSimple</td>

<td>U16</td>

<td>:1</td>

<td>2000</td>

<td>when set, temporarily overrides bx, by, forcing the xaLeft, xaRight,
yaTop, and yaBottom fields to all be page relative.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBelowText</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>1 shape is below text
<br>0 shape is above text</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAnchorLock</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>1 anchor is locked
<br>0 anchor is not locked</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>cTxbx</td>

<td>S32</td>

<td></td>

<td></td>

<td>count of textboxes in shape (undo doc only)</td>
</tr>
</table>

<p>cbFSPA (count of bytes of FSPA) is 26 (decimal), 1A (hex).
<br><a NAME="87"></a>
<h3>
TeXtBoX Story (FTXBXS)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cTxbx</td>

<td>S32</td>

<td></td>

<td></td>

<td>when not fReusable, counts the number of textboxes in this story chain</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>iNextReuse</td>

<td>S32</td>

<td></td>

<td></td>

<td>when fReusable, the index of the next in the linked list of reusable
FTXBXSs</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cReusable</td>

<td>S32</td>

<td></td>

<td></td>

<td>if fReusable, counts the number of reusable FTXBXSs follow this one
in the linked list</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>fReusable</td>

<td>S16</td>

<td></td>

<td></td>

<td>this FTXBXS is not currently in use</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>reserved</td>

<td>U32</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>lid</td>

<td>S32</td>

<td></td>

<td></td>

<td>Shape Identifier (see FSPA) for first Office Shape in textbox chain.</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>txidUndo</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>cbFTXBXS (cout of bytes of FTXBXS) is 22 (decimal), 16 (hex).
<br><a NAME="64"></a>
<h3>
List Format Override (LFO)</h3>
<!-- sizeOf="16" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0x0</td>

<td>lsid</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>List ID of corresponding LSTF (see LSTF)</td>
</tr>

<tr>
<td>4</td>

<td>0x4</td>

<td>unused4</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>8</td>

<td>0x8</td>

<td>unused8</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>12</td>

<td>0xC</td>

<td>clfolvl</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>count of levels whose format is overridden (see LFOLVL)</td>
</tr>

<tr>
<td>13</td>

<td>0xD</td>

<td>reserved</td>

<td>U8[3]</td>

<td>3</td>

<td></td>

<td>reserved</td>
</tr>
</table>
<a NAME="65"></a>
<h3>
List Format Override for a single LeVeL (LFOLVL)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>iStartAt</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>start-at value if fFormatting == false and fStartAt == true. (if fFormatting
== true, the start-at is stored in the LVL)</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>ilvl</td>

<td>U8</td>

<td>:4</td>

<td>0x0F</td>

<td>the level to be overridden</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fStartAt</td>

<td>U8</td>

<td>:1</td>

<td>0x10</td>

<td>true if the start-at value is overridden</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFormatting</td>

<td>U8</td>

<td>:1</td>

<td>0x20</td>

<td>true if the formatting is overriden (in which case the LFOLVL should
contain a pointer to a LVL)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unsigned4_6</td>

<td>U8</td>

<td>:2</td>

<td>0xC0</td>

<td>reserved</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>reserved</td>

<td>U8[3]</td>

<td>3</td>

<td></td>

<td>reserved</td>
</tr>
</table>
<a NAME="62"></a>
<h3>
Line Spacing Descriptor (LSPD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>dyaLine</td>
<!-- initial="240" -->

<td>S16</td>

<td></td>

<td></td>

<td>see description of sprmPDyaLine for description of the meaning of dyaLine</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fMultLinespace</td>
<!-- initial="1" -->

<td>S16</td>

<td></td>

<td></td>

<td>see description of sprmPDyaLine in the Sprm Definitions section for
description of the meaning of dyaLine and fMultLinespace fields.</td>
</tr>
</table>

<p>cbLSPD (count of bytes of LSPD) is 4.
<br><a NAME="63"></a>
<h3>
LiST Data (on File) (LSTF)</h3>
<!-- sizeOf="28" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0x00</td>

<td>lsid</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>Unique List ID</td>
</tr>

<tr>
<td>4</td>

<td>0x04</td>

<td>tplc</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>Unique template code</td>
</tr>

<tr>
<td>8</td>

<td>0x08</td>

<td>rgistd</td>

<td>U16[9]</td>

<td>18</td>

<td></td>

<td>Array of shorts containing the istd's linked to each level of the list,
or istdNil (4095) if no style is linked.</td>
</tr>

<tr>
<td>26</td>

<td>0x1A</td>

<td>fSimpleList</td>

<td>U8</td>

<td>:1</td>

<td>0x01</td>

<td>true if this is a simple (one-level) list; false if this is a multilevel
(nine-level) list.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRestartHdn</td>

<td>U8</td>

<td>:1</td>

<td>0x02</td>

<td>Word 6 compatibility option: true if the list should start numbering
over at the beginning of each section</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unsigned26_2</td>

<td>U8</td>

<td>:6</td>

<td>0xFC</td>

<td>reserved</td>
</tr>

<tr>
<td>27</td>

<td>0x1B</td>

<td>reserved</td>

<td>U8</td>

<td>U8</td>

<td></td>

<td>reserved</td>
</tr>
</table>
<a NAME="61"></a>
<h3>
List LeVeL (on File) (LVLF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0x00</td>

<td>iStartAt</td>

<td>U32</td>

<td>4</td>

<td></td>

<td>start at value for this list level</td>
</tr>

<tr>
<td>4</td>

<td>0x04</td>

<td>nfc</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>number format code (see anld.nfc for a list of options)</td>
</tr>

<tr>
<td>5</td>

<td>0x05</td>

<td>jc</td>

<td>U8</td>

<td>:2</td>

<td>0x03</td>

<td>alignment (left, right, or centered) of the paragraph number.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLegal</td>

<td>U8</td>

<td>:1</td>

<td>0x04</td>

<td>true (==1) if the level turns all inherited numbers to arabic, false
if it preserves their number format code (nfc)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNoRestart</td>

<td>U8</td>

<td>:1</td>

<td>0x08</td>

<td>true if the level's number sequence is not restarted by higher (more
significant) levels in the list</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrev</td>

<td>U8</td>

<td>:1</td>

<td>0x10</td>

<td>Word 6 compatibility option: equivalent to anld.fPrev (see ANLD)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPrevSpace</td>

<td>U8</td>

<td>:1</td>

<td>0x20</td>

<td>Word 6 compatibility option: equivalent to anld.fPrevSpace (see ANLD)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fWord6</td>

<td>U8</td>

<td>:1</td>

<td>0x40</td>

<td>true if this level was from a converted Word 6 document. If it is true,
all of the Word 6 compability options become valid; otherwise they are
ignored.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused5_7</td>

<td>U8</td>

<td>:1</td>

<td>0x80</td>

<td>unused.</td>
</tr>

<tr>
<td>6</td>

<td>0x06</td>

<td>rgbxchNums</td>

<td>U8[9]</td>

<td>9</td>

<td></td>

<td>contains the character offsets into the LVL's XST of the inherited
numbers of previous levels. This array should be zero terminated unless
it is full (all 9 levels full). The XST contains place holders for any
paragraph numbers contained in the text of the number, and the place holder
contains the ilvl of the inherited number, so lvl.xst[lvl.rgbxchNums[0]]
== the level of the first inherited number in this level.</td>
</tr>

<tr>
<td>15</td>

<td>0x0F</td>

<td>ixchFollow</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>the type of character following the number text for the paragraph:
0 == tab, 1 == space, 2 == nothing.</td>
</tr>

<tr>
<td>16</td>

<td>0x10</td>

<td>dxaSpace</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>Word 6 compatibility option: equivalent to anld.dxaSpace (see ANLD)</td>
</tr>

<tr>
<td>20</td>

<td>0x14</td>

<td>dxaIndent</td>

<td>S32</td>

<td>4</td>

<td></td>

<td>Word 6 compatibility optino: equivalent to anld.dxaIndent (see ANLD)</td>
</tr>

<tr>
<td>24</td>

<td>0x18</td>

<td>cbGrpprlChpx</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>length, in bytes, of the LVL's grpprlChpx</td>
</tr>

<tr>
<td>25</td>

<td>0x19</td>

<td>cbGrpprlPapx</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>length, in bytes, of the LVL's grpprlPapx</td>
</tr>

<tr>
<td>26</td>

<td>0X1A</td>

<td>reserved</td>

<td>U16</td>

<td>2</td>

<td></td>

<td>reserved</td>
</tr>
</table>

<h2>
<a NAME="METAFILEPICT"></a></h2>

<h3>
Window's (METAFILEPICT)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>mm</td>

<td>S16</td>

<td></td>

<td></td>

<td>Specifies the mapping mode in which the picture is drawn.&nbsp;</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>xExt</td>

<td>S16</td>

<td></td>

<td></td>

<td>Specifies the size of the metafile picture for all modes except the
MM_ISOTROPIC and MM_ANISOTROPIC modes. (For more information about these
modes, see the yExt member.) The x-extent specifies the width of the rectangle
within which the picture is drawn. The coordinates are in units that correspond
to the mapping mode.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>yExt</td>

<td>S16</td>

<td></td>

<td></td>

<td>Specifies the size of the metafile picture for all modes except the
MM_ISOTROPIC and MM_ANISOTROPIC modes. The y-extent specifies the height
of the rectangle within which the picture is drawn. The coordinates are
in units that correspond to the mapping mode.&nbsp;
<p>For MM_ISOTROPIC and MM_ANISOTROPIC modes, which can be scaled, the
xExt and yExt members contain an optional suggested size in MM_HIMETRIC
units.
<p>For MM_ANISOTROPIC pictures, xExt and yExt can be zero when no suggested
size is supplied. For MM_ISOTROPIC pictures, an aspect ratio must be supplied
even when no suggested size is given. (If a suggested size is given, the
aspect ratio is implied by the size.) To give an aspect ratio without implying
a suggested size, set xExt and yExt to negative values whose ratio is the
appropriate aspect ratio. The magnitude of the negative xExt and yExt values
is ignored; only the ratio is used.</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>hMF</td>

<td>S16</td>

<td></td>

<td></td>

<td>Identifies a memory metafile.</td>
</tr>
</table>

<p><a NAME="67"></a>
<h3>
Number Revision Mark Data (NUMRM)</h3>
The NUMRM structure is used to track revision marking data for paragraph
numbers, and is stored in the PAP for each numbered paragraph. When revision
marking tracking is turned on, we fill out the NUMRM for each number with
the data required to recreate the number's text. Then at display time,
that string is compared with the current paragraph number string, and displayed
as changed (old deleted, current inserted) if the strings differ. The string
construction algorithm is the same as for an LVL structure.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fNumRM</td>

<td>U8</td>

<td>1</td>

<td></td>

<td>True if this paragraph was numbered when revision mark tracking was
turned on</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>unused1</td>

<td>U8</td>

<td>1</td>

<td></td>

<td></td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>ibstNumRM</td>

<td>S16</td>

<td>2</td>

<td></td>

<td>index to author IDs stored in hsttbfRMark for the paragraph number
change</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dttmNumRM</td>

<td>DTTM</td>

<td>4</td>

<td></td>

<td>Date of the paragraph number change</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>rgbxchNums</td>

<td>U8[9]</td>

<td>9</td>

<td></td>

<td>Index into NUMRM.xst of the locations of paragraph number place holders
for each level (see LVL.rgxchNums)</td>
</tr>

<tr>
<td>17</td>

<td>11</td>

<td>rgnfc</td>

<td>U8[9]</td>

<td>9</td>

<td></td>

<td>Number Format Code for the paragraph number place holders for each
level (see LVL.nfc)</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>unused26</td>

<td>S16</td>

<td>2</td>

<td></td>

<td></td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>PNBR</td>

<td>U32[9]</td>

<td>36</td>

<td></td>

<td>Numerical value for each level place holder in NUMRM.xst.</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>xst</td>

<td>XCHAR[32]</td>

<td>64</td>

<td></td>

<td>The text string for the paragraph number, containing level place holders</td>
</tr>
</table>

<p>cbNUMRM (count of bytes of NUMRM) is 128 (decimal), 80 (hex).
<p><a NAME="_OBJHEADER"></a>
<h3>
Embedded Object properties (OBJHEADER)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>lcb</td>

<td>U32</td>

<td>4</td>

<td></td>

<td>length of object (including this header)</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cbHeader</td>

<td>U16</td>

<td>2</td>

<td></td>

<td>length of this header (for future use)</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>icf</td>

<td>U16</td>

<td>2</td>

<td></td>

<td>Index to clipboard format of object</td>
</tr>
</table>

<p><a NAME="66"></a>
<h3>
Outline LiST Data (OLST)</h3>
<!-- sizeOf="212" -->

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>rganlv</td>

<td>ANLV[9]</td>

<td></td>

<td></td>

<td>an array of 9 ANLV structures describing how heading numbers should
be displayed for each of Word's 9 outline heading levels</td>
</tr>

<tr>
<td>144</td>

<td>90</td>

<td>fRestartHdr</td>

<td>U8</td>

<td></td>

<td></td>

<td>when ==1, restart heading on section break</td>
</tr>

<tr>
<td>145</td>

<td>91</td>

<td>fSpareOlst2</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>146</td>

<td>92</td>

<td>fSpareOlst3</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>147</td>

<td>93</td>

<td>fSpareOlst4</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>148</td>

<td>94</td>

<td>rgxch</td>

<td>XCHAR[32]</td>

<td></td>

<td></td>

<td>text before/after number</td>
</tr>
</table>

<p>cbOLST (count of bytes of OLST) is 212(decimal), D4(hex).
<br><a NAME="70"></a>
<h3>
Paragraph Properties (PAP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>istd</td>

<td>U16</td>

<td></td>

<td></td>

<td>index to style descriptor . This is an index to an STD in the <b>STSH</b>
structure</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>jc</td>

<td>U8</td>

<td></td>

<td></td>

<td>justification code
<br>0 left justify
<br>1 center
<br>2 right justify
<br>3 left and right justify</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>fKeep</td>

<td>U8</td>

<td></td>

<td></td>

<td>keep entire paragraph on one page if possible</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fKeepFollow</td>

<td>U8</td>

<td></td>

<td></td>

<td>keep paragraph on same page with next paragraph if possible</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>fPageBreakBefore</td>

<td>U8</td>

<td></td>

<td></td>

<td>start this paragraph on new page</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fBrLnAbove</td>

<td>U8</td>

<td>:1</td>

<td>0001</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBrLnBelow</td>

<td>U8</td>

<td>:1</td>

<td>0002</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnused</td>

<td>U8</td>

<td>:2</td>

<td>0006</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcVert</td>

<td>U8</td>

<td>:2</td>

<td>0030</td>

<td>vertical position code. Specifies coordinate frame to use when paragraphs
are absolutely positioned.
<br>0 vertical position coordinates are relative to margin
<br>1 coordinates are relative to page
<br>2 coordinates are relative to text. This means: relative to where the
next non-APO text would have been placed if this APO did not exist.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pcHorz</td>

<td>U8</td>

<td>:2</td>

<td>00C0</td>

<td>horizontal position code. Specifies coordinate frame to use when paragraphs
are absolutely positioned.
<br>0 horiz. position coordinates are relative to column.
<br>1 coordinates are relative to margin
<br>2 coordinates are relative to page</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>brcp</td>

<td>U8</td>

<td></td>

<td></td>

<td>the brcp and brcl fields have been superseded by the newly defined
brcLeft, brcTop, etc. fields. They remain in the PAP for compatibility
with MacWord 3.0
<br>rectangle border codes
<br>0 none
<br>1 border above
<br>2 border below
<br>15 box around
<br>16 bar to left of paragraph</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>brcl</td>

<td>U8</td>

<td></td>

<td></td>

<td>border line style
<br>0 single
<br>1 thick
<br>2 double
<br>3 shadow</td>
</tr>

<tr>
<td>9</td>

<td>9</td>

<td>unused9</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>ilvl</td>

<td>U8</td>

<td></td>

<td></td>

<td>when non-zero, list level for this paragraph (0-based index! Look at the sprmPIlvl docu (Werner))</td>
</tr>

<tr>
<td>11</td>

<td>B</td>

<td>fNoLnn</td>

<td>U8</td>

<td></td>

<td></td>

<td>no line numbering for this paragraph. (makes this an exception to the
section property of line numbering)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>ilfo</td>

<td>S16</td>

<td></td>

<td></td>

<td>when non-zero, (1-based) index into the pllfo identifying the list
to which the paragraph belongs</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>nLvlAnm</td>

<td>U8</td>

<td></td>

<td></td>

<td>no longer used</td>
</tr>

<tr>
<td>15</td>

<td>F</td>

<td>unused15</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>fSideBySide</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph is a side by side paragraph</td>
</tr>

<tr>
<td>17</td>

<td>11</td>

<td>unused17</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>fNoAutoHyph</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 0, text in paragraph may be auto hyphenated.</td>
</tr>

<tr>
<td>19</td>

<td>13</td>

<td>fWidowControl</td>
<!-- initial="1" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, Word will prevent widowed lines in this paragraph from being
placed at the beginning of a page</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>dxaRight</td>

<td>S32</td>

<td></td>

<td></td>

<td>indent from right margin (signed).</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dxaLeft</td>

<td>S32</td>

<td></td>

<td></td>

<td>indent from left margin (signed)</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dxaLeft1</td>

<td>S32</td>

<td></td>

<td></td>

<td>first line indent; signed number relative to dxaLeft</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>lspd</td>

<td>LSPD</td>

<td></td>

<td></td>

<td>line spacing descriptor</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>dyaBefore</td>

<td>U32</td>

<td></td>

<td></td>

<td>vertical spacing before paragraph (unsigned)</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>dyaAfter</td>

<td>U32</td>

<td></td>

<td></td>

<td>vertical spacing after paragraph (unsigned)</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>phe</td>

<td>PHE</td>

<td></td>

<td></td>

<td>height of current paragraph.</td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>fCrLf</td>

<td>U8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>57</td>

<td>39</td>

<td>fUsePgsuSettings</td>

<td>U8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>58</td>

<td>3A</td>

<td>fAdjustRight</td>

<td>U8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>59</td>

<td>3B</td>

<td>unused59</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>fKinsoku</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, apply kinsoku rules when performing line wrapping</td>
</tr>

<tr>
<td>61</td>

<td>3D</td>

<td>fWordWrap</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, perform word wrap</td>
</tr>

<tr>
<td>62</td>

<td>3E</td>

<td>fOverflowPunct</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, apply overflow punctuation rules when performing line wrapping</td>
</tr>

<tr>
<td>63</td>

<td>3F</td>

<td>fTopLinePunct</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, perform top line punctuation processing</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>fAutoSpaceDE</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, auto space FE and alphabetic characters</td>
</tr>

<tr>
<td>65</td>

<td>41</td>

<td>fAutoSpaceDN</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, auto space FE and numeric characters</td>
</tr>

<tr>
<td>66</td>

<td>42</td>

<td>wAlignFont</td>

<td>U16</td>

<td></td>

<td></td>

<td>font alignment
<br>0 Hanging
<br>1 Centered
<br>2 Roman
<br>3 Variable
<br>4 Auto</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>fVertical</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBackward</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRotateFont</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused68_3</td>

<td>U16</td>

<td>:13</td>

<td>FFF8</td>

<td>reserved</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>unused70</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>72</td>

<td>48</td>

<td>fInTable</td>

<td>S8</td>

<td></td>

<td></td>

<td>when 1, paragraph is contained in a table row</td>
</tr>

<tr>
<td>73</td>

<td>49</td>

<td>fTtp</td>

<td>S8</td>

<td></td>

<td></td>

<td>when 1, paragraph consists only of the row mark special character and
marks the end of a table row.</td>
</tr>

<tr>
<td>74</td>

<td>4A</td>

<td>wr</td>

<td>U8</td>

<td></td>

<td></td>

<td>Wrap Code for absolute objects</td>
</tr>

<tr>
<td>75</td>

<td>4B</td>

<td>fLocked</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, paragraph may not be edited</td>
</tr>

<tr>
<td>76</td>

<td>4C</td>

<td>ptap</td>

<td>U32</td>

<td></td>

<td></td>

<td>TAP used internally by Word</td>
</tr>

<tr>
<td>80</td>

<td>50</td>

<td>dxaAbs</td>

<td>S32</td>

<td></td>

<td></td>

<td>when positive, is the horizontal distance from the reference frame
specified by pap.pcHorz. 0 means paragraph is positioned at the left with
respect to the reference frame specified by pcHorz. Certain negative values
have special meaning:
<br>-4 paragraph centered horizontally within reference frame
<br>-8 paragraph adjusted right within reference frame
<br>-12 paragraph placed immediately inside of reference frame
<br>-16 paragraph placed immediately outside of reference frame</td>
</tr>

<tr>
<td>84</td>

<td>54</td>

<td>dyaAbs</td>

<td>S32</td>

<td></td>

<td></td>

<td>when positive, is the vertical distance from the reference frame specified
by pap.pcVert. 0 means paragraph's y-position is unconstrained. Certain
negative values have special meaning:
<br>-4 paragraph is placed at top of reference frame
<br>-8 paragraph is centered vertically within reference frame
<br>-12 paragraph is placed at bottom of reference frame.</td>
</tr>

<tr>
<td>88</td>

<td>58</td>

<td>dxaWidth</td>

<td>S32</td>

<td></td>

<td></td>

<td>when not == 0, paragraph is constrained to be dxaWidth wide, independent
of current margin or column settings.</td>
</tr>

<tr>
<td>92</td>

<td>5C</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border above paragraph</td>
</tr>

<tr>
<td>96</td>

<td>60</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the left of paragraph</td>
</tr>

<tr>
<td>100</td>

<td>64</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border below paragraph</td>
</tr>

<tr>
<td>104</td>

<td>68</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the right of paragraph</td>
</tr>

<tr>
<td>108</td>

<td>6C</td>

<td>brcBetween</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of border to place between conforming paragraphs. Two
paragraphs conform when both have borders, their brcLeft and brcRight matches,
their widths are the same, they both belong to tables or both do not, and
have the same absolute positioning props.</td>
</tr>

<tr>
<td>112</td>

<td>70</td>

<td>brcBar</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of border to place on outside of text when facing pages
are to be displayed.</td>
</tr>

<tr>
<td>116</td>

<td>74</td>

<td>dxaFromText</td>

<td>S32</td>

<td></td>

<td></td>

<td>horizontal distance to be maintained between an absolutely positioned
paragraph and any non-absolute positioned text</td>
</tr>

<tr>
<td>120</td>

<td>78</td>

<td>dyaFromText</td>

<td>S32</td>

<td></td>

<td></td>

<td>vertical distance to be maintained between an absolutely positioned
paragraph and any non-absolute positioned text</td>
</tr>

<tr>
<td>124</td>

<td>7C</td>

<td>dyaHeight</td>

<td>U16</td>

<td>:15</td>

<td>7FFF</td>

<td>height of abs obj; 0 == Auto</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMinHeight</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>0 = Exact, 1 = At Least</td>
</tr>

<tr>
<td>126</td>

<td>7E</td>

<td>shd</td>

<td>SHD</td>

<td></td>

<td></td>

<td>shading</td>
</tr>

<tr>
<td>128</td>

<td>80</td>

<td>dcs</td>

<td>DCS</td>

<td></td>

<td></td>

<td>drop cap specifier (see DCS definition)</td>
</tr>

<tr>
<td>130</td>

<td>82</td>

<td>lvl</td>
<!-- initial="9" -->

<td>S8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>131</td>

<td>83</td>

<td>fNumRMIns</td>

<td>S8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>132</td>

<td>84</td>

<td>anld</td>

<td>ANLD</td>

<td></td>

<td></td>

<td>autonumber list descriptor (see ANLD definition)</td>
</tr>

<tr>
<td>216</td>

<td>D8</td>

<td>fPropRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 1, properties have been changed with revision marking on</td>
</tr>

<tr>
<td>218</td>

<td>DA</td>

<td>ibstPropRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when properties have
been changed when revision marking was enabled</td>
</tr>

<tr>
<td>220</td>

<td>DC</td>

<td>dttmPropRMark</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which properties of this were changed for this run of
text by the author. (Only recorded when revision marking is on.)</td>
</tr>

<tr>
<td>224</td>

<td>E0</td>

<td>numrm</td>

<td>NUMRM</td>

<td></td>

<td></td>

<td>paragraph numbering revision mark data (see NUMRM)</td>
</tr>

<tr>
<td>352</td>

<td>160</td>

<td>itbdMac</td>

<td>S16</td>

<td></td>

<td></td>

<td>number of tabs stops defined for paragraph. Must be >= 0 and &lt;=
64.</td>
</tr>

<tr>
<td>354</td>

<td>162</td>

<td>rgdxaTab</td>

<td>std::vector<Word97::TabDescriptor></td>

<td></td>

<td></td>

<td>array of { positions of itbdMac tab stops ; itbdMac tab descriptors }
itbdMax == 64.
The SPEC doesn't have such a structure, obviously. This is a wv2 change.
(This data is never in the file as is, it comes from the SPRMs).</td>
</tr>
</table>

<p>cbPAP (count of bytes of PAP) is 610 (decimal), 262(hex)
<p>The standard PAP is all zeros except:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>fWidowControl</td>

<td>1</td>
</tr>

<tr>
<td>fMultLineSpace</td>

<td>1</td>
</tr>

<tr>
<td>dyaLine</td>

<td>240 twips</td>
</tr>

<tr>
<td>lvl</td>

<td>9</td>
</tr>
</table>
<a NAME="71"></a>
<h3>
Paragraph Property Exceptions (PAPX)</h3>
The <b>PAPX</b> is stored within <b>FKPs</b> and within the <b>STSH</b>.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of bytes of following data in PAPX. The first byte of a PAPX
is a count of bytes when a PAPX is stored in a STSH. Count of bytes is
used because only paragraph sprms are stored in a STSH PAPX.</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cw</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of words for this byte and the following data in PAPX. The first
byte of a PAPX is a count of words when PAPX is stored in an FKP. If this
value is 0, it is a 'pad' byte and the count is stored in the following
byte, Count of words is used because PAPX in an FKP can contain paragraph
<b>and</b>
table sprms.</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>(cw)</td>

<td>U8</td>

<td></td>

<td></td>

<td>if previous byte is 0, this is the count of words of following data
in PAPX (not including this and previous 'pad' byte)</td>
</tr>

<tr>
<td>1/2</td>

<td>1/2</td>

<td>istd</td>

<td>U16</td>

<td></td>

<td></td>

<td>index to style descriptor of the style from which the paragraph inherits
its paragraph and character properties</td>
</tr>

<tr>
<td>3/4</td>

<td>3/4</td>

<td>grpprl</td>

<td>character array</td>

<td></td>

<td></td>

<td>a list of the sprms that encode the differences between PAP for a paragraph
and the PAP for the style used. When a paragraph bound is also the end
of a table row, the PAPX also contains a list of table sprms which express
the difference of table row's TAP from an empty TAP that has been cleared
to zeros. The table sprms are recorded in the list after all of the paragraph
sprms. See Sprms definitions for list of sprms that are used in PAPXs.</td>
</tr>
</table>

<p>For calculating papx.cw when storing in a FKP: For even-sized grpprl's,
the grpprl plus the istd and cw bytes will be an even number of bytes,
so we store the count of words for all three elements in papx.cw. For odd-sized
grpprl's, the three elements will be an odd number of bytes, which can't
be represented with a count of words; so, we store a 'pad' byte of 0 at
the beginning (in the normal cw location), followed by a count that is
the size of the grpprl and istd byte only (since that's an even number
of bytes). In either case, papx.cw is immediately followed by the istd
and grpprl.
<br><a NAME="60"></a>
<h3>
Formatted Disk Page for PAPXs (PAPXFKP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>rgfc</td>

<td>FC[fkp.crun+1]</td>

<td></td>

<td></td>

<td>Each <b>FC</b> is the limit <b>FC</b> of a paragraph (i.e. points to
the next character past an end of paragraph mark). There will be fkp.crun+1
recorded in the FKP.</td>
</tr>

<tr>
<td>4*(fkp.crun+1)</td>

<td></td>

<td>rgbx</td>

<td>BX[fkp.crun]</td>

<td></td>

<td></td>

<td>an array of the BX data structure. The <b>ith</b> BX entry in the array
describes the paragraph beginning at fkp.rgfc[i]. The BX is a 13 byte data
structure. The first byte of each BX is the word offset of the <b>PAPX</b>
recorded for the paragraph corresponding to this BX.
<b>.</b>. If the byte
stored is 0, this represents a 1 line paragraph 15 pixels high with Normal
style (stc == 0) whose column width is 7980 dxas. The last 12 bytes of
the BX is a PHE structure which stores the current paragraph height for
the paragraph corresponding to the BX. If a plcfphe has an entry that maps
to the FC for this paragraph, that entry's PHE overrides the PHE stored
in the FKP.11*fkp.crun+4 unused space. As new runs/paragraphs are recorded
in the <b>FKP</b>, unused space is reduced by 17 if CHPX/PAPX is already
recorded and is reduced by 17+sizeof(PAPX) if property is not already recorded.</td>
</tr>

<tr>
<td>511-sizeof(grppapx)</td>

<td></td>

<td>grppapx</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>grppapx consists of all of the <b>PAPX</b>s stored in <b>FKP</b> concatenated
end to end. Each <b>PAPX</b> begins with a count of words which records
its length padded to a word boundary.</td>
</tr>

<tr>
<td>511</td>

<td></td>

<td>crun</td>

<td>U8</td>

<td></td>

<td></td>

<td>count of paragraphs for <b>PAPX FKP.</b></td>
</tr>
</table>

<p>The <b>PAP</b> is never stored in a Word file. It is derived by expanding
stored <b>PAPX</b>s.
<br><a NAME="73"></a>
<h3>
Piece Descriptor (PCD)</h3>
<!-- sizeOf="8" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fNoParaLast</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>when 1, means that piece contains no end of paragraph marks.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPaphNil</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fCopied</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_3</td>

<td>U16</td>

<td>:5</td>

<td>00F8</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fn</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>used internally by Word</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fc</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset of beginning of piece. The size of the <b>ith</b> piece
can be determined by subtracting rgcp[<b>i</b>] of the containing
<b>plcfpcd</b>
from its rgcp[<b>i+1</b>].</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>prm</td>

<td>PRM</td>

<td></td>

<td></td>

<td>contains either a single sprm or else an index number of the grpprl
which contains the sprms that modify the properties of the piece.</td>
</tr>
</table>

<p>cbPCD (count of bytes of PCD) is 8.
<br><a NAME="68"></a>
<h3>
Page Descriptor (PGD)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fContinue</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>1 only when footnote is continued from previous page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>1 when page is dirty (i.e. pagination cannot be trusted)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRight</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>1 when right hand side page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fPgnRestart</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>1 when page number must be reset to 1.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fEmptyPage</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>1 when section break forced page to be empty.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fAllFtn</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>1 when page contains nothing but footnotes</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_6</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>unused</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTableBreaks</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>table breaks have been calculated for this page.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMarked</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>used temporarily while word is running.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColumnBreaks</td>

<td>U16</td>

<td>:1</td>

<td>0200</td>

<td>column breaks have been calculated for this page.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fTableHeader</td>

<td>U16</td>

<td>:1</td>

<td>0400</td>

<td>page had a table header at the end</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fNewPage</td>

<td>U16</td>

<td>:1</td>

<td>0800</td>

<td>page has never been valid since created, must recalculate the bounds
of this page. If this is the last page, this PGD may really represent many
pages.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>bkc</td>

<td>U16</td>

<td>:4</td>

<td>F000</td>

<td>section break code</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>lnn</td>

<td>U16</td>

<td></td>

<td></td>

<td>line number of first line, -1 if no line numbering</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>pgn</td>

<td>U16</td>

<td></td>

<td></td>

<td>page number as printed</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>dym</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>
</table>

<p>When we have a blank page or footnote-only page, we redefine the fields
at the beginning of the PGD as shown in the alternate description below:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>unused0_0</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fGhost</td>

<td>U16</td>

<td>:2</td>

<td>0030</td>

<td>redefine fEmptyPage and fAllFtn. true when blank page or footnote only
page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_6</td>

<td>U16</td>

<td>:10</td>

<td>FFC0</td>

<td></td>
</tr>
</table>

<p>cbPGD (count of bytes of PGD) is 10.
<br><a NAME="69"></a>
<h3>
Paragraph Height (PHE)</h3>
<!-- sizeOf="12" -->
The <b>PHE</b> is a substructure of the <b>PAP</b> and the <b>PAPXFKP</b>
and is also stored in the <b>PLCFPHE</b>.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fSpare</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>PHE entry is invalid when == 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDiffLines</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>when 1, total height of paragraph is known but lines in paragraph have
different heights.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_3</td>

<td>U16</td>

<td>:5</td>

<td>00F8</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>clMac</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>when fDiffLines is 0 is number of lines in paragraph</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>unused2</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dxaCol</td>

<td>S32</td>

<td></td>

<td></td>

<td>width of lines in paragraph</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>dym</td>

<td>S32</td>

<td></td>

<td></td>

<td>when fDiffLines is 0, is height of every line in paragraph in pixels
(dymLine)
<br>when fDiffLines is 1, is the total height in pixels of the paragraph
(dymHeight)</td>
</tr>
</table>

<h3>
Paragraph Height in a Table (PHE2)</h3>
<p>If the PHE is stored in a PAP whose fTtp field is set (non-zero), the
following structure is used:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fSpare</td>

<td>U32</td>

<td>:1</td>

<td>0001</td>

<td>reserved</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnk</td>

<td>U32</td>

<td>:1</td>

<td>0002</td>

<td>PHE entry is invalid when == 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>dcpTtpNext</td>

<td>U32</td>

<td>:30</td>

<td></td>

<td>if not == 0, used as a hint when finding the next row</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>dxaCol</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>dymTableHeight</td>

<td>S32</td>

<td></td>

<td></td>

<td>height of table row</td>
</tr>
</table>

<p>cbPHE (the count of bytes of PHE) is 12.
<p>If there is no paragraph height information stored for a paragraph,
all of the fields in the <b>PHE</b> are set to 0. If a paragraph contains
more than 127 lines, the clMac, dylLine variant cannot be used, so fDiffLines
must be set to 1 and the total size of the paragraph stored in dylHeight.
If a paragraph height is greater than 32767 twips, the height cannot be
represented by a <b>PHE</b> so all fields of the <b>PHE</b> must be set
to 0.
<p>If a new Word file is created, the <b>PHE</b> of every <b>papx fkp</b>
entry created to describe the paragraphs of the file should be set to 0.
If a Word file is altered in place (a character of the file changed to
a new character or a property changed), the paragraph containing the change
must have its <b>papx.phe</b> field set to 0. If this paragraph is in a
table row, the <b>PHE</b> in the <b>papx</b> at the end of the row (indicated
by fInTable) must also be set to 0.
<br><a NAME="72"></a>
<h3>
Picture Descriptor (on File) (PICF)</h3>
The PICF is followed by a variable array of bytes containing Window's metafile,
bitmap or TIFF file filename.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>lcb</td>

<td>U32</td>

<td></td>

<td></td>

<td>number of bytes in the PIC structure plus size of following picture
data which may be a Window's metafile, a bitmap, or the filename of a TIFF
file. In the case of a Macintosh PICT picture, this includes the size of
the PIC, the standard "x" metafile, and the Macintosh PICT data. See Appendix
B for more information.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cbHeader</td>

<td>U16</td>

<td></td>

<td></td>

<td>number of bytes in the PIC (to allow for future expansion).</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>mfp</td>

<td>METAFILEPICT</td>

<td></td>

<td></td>

<td>If a Windows metafile is stored immediately following the PIC structure,
the mfp is a Window's METAFILEPICT structure. When the data immediately
following the PIC is a TIFF filename, mfp.mm == 98 If a bitmap is stored
after the pic, mfp.mm == 99
<p>When the PIC describes a bitmap, mfp.xExt is the width of the bitmap
in pixels and mfp.yExt is the height of the bitmap in pixels..</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>bm_rcWinMF</td>

<td>U8[14]</td>

<td></td>

<td></td>

<td>Window's bitmap structure when PIC describes a BITMAP (14 bytes).
<br>Rect for window origin and extents when metafile is stored -- ignored
if 0 (8 bytes).</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dxaGoal</td>

<td>S16</td>

<td></td>

<td></td>

<td>horizontal measurement in twips of the rectangle the picture should
be imaged within. when scaling bitmaps, dxaGoal and dyaGoal may be ignored
if the operation would cause the bitmap to shrink or grow by a non -power-of-two
factor</td>
</tr>

<tr>
<td>30</td>

<td>1E</td>

<td>dyaGoal</td>

<td>S16</td>

<td></td>

<td></td>

<td>vertical measurement in twips of the rectangle the picture should be
imaged within.</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>mx</td>

<td>U16</td>

<td></td>

<td></td>

<td>horizontal scaling factor supplied by user expressed in .001% units.</td>
</tr>

<tr>
<td>34</td>

<td>22</td>

<td>my</td>

<td>U16</td>

<td></td>

<td></td>

<td>vertical scaling factor supplied by user expressed in .001% units.</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>dxaCropLeft</td>

<td>S16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the left in twips. for all
of the Crop values, a positive measurement means the specified border has
been moved inward from its original setting and a negative measurement
means the border has been moved outward from its original setting.</td>
</tr>

<tr>
<td>38</td>

<td>26</td>

<td>dyaCropTop</td>

<td>S16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the top in twips.</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>dxaCropRight</td>

<td>S16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the right in twips.</td>
</tr>

<tr>
<td>42</td>

<td>2A</td>

<td>dyaCropBottom</td>

<td>S16</td>

<td></td>

<td></td>

<td>the amount the picture has been cropped on the bottom in twips.</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>brcl</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td>Obsolete, superseded by brcTop, etc. In WinWord 1.x, it was the type
of border to place around picture
<br>0 single
<br>1 thick
<br>2 double
<br>3 shadow</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFrameEmpty</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>picture consists of a single frame</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBitmap</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>==1, when picture is just a bitmap</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fDrawHatch</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>==1, when picture is an active OLE object</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fError</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>==1, when picture is just an error message</td>
</tr>

<tr>
<td></td>

<td></td>

<td>bpp</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>bits per pixel
<br>0 unknown
<br>1 monochrome
<br>4 VGA</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border above picture</td>
</tr>

<tr>
<td>50</td>

<td>32</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the left of picture</td>
</tr>

<tr>
<td>54</td>

<td>36</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border below picture</td>
</tr>

<tr>
<td>58</td>

<td>3A</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification for border to the right of picture</td>
</tr>

<tr>
<td>62</td>

<td>3E</td>

<td>dxaOrigin</td>

<td>S16</td>

<td></td>

<td></td>

<td>horizontal offset of hand annotation origin</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>dyaOrigin</td>

<td>S16</td>

<td></td>

<td></td>

<td>vertical offset of hand annotation origin</td>
</tr>

<tr>
<td>66</td>

<td>42</td>

<td>cProps</td>

<td>S16</td>

<td></td>

<td></td>

<td>unused</td>
</tr>
</table>

<p>This is followed by a variable array of bytes containing Window's metafile,
bitmap or TIFF file filename.
<br><a NAME="74"></a>
<h3>
Plex of CPs stored in File (PLCF)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td></td>

<td>rgfc</td>

<td>FC[]</td>

<td></td>

<td></td>

<td>given that the size of PLCF is cb and the size of the structure stored
in plc is cbStruct, then the number of structure instances stored in PLCF,
iMac is given by (cb -4)/(4 + cbStruct) The number of FCs stored in the
PLCF will be iMac + 1.</td>
</tr>

<tr>
<td>4*(iMac+1)</td>

<td></td>

<td>rgstruct</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>array of some arbitrary structure.</td>
</tr>
</table>

<p>cbPLC (count of bytes of a PLC) is iMac(4 + cbStruct) + 4.
<br><a NAME="75"></a>
<h3>
Property Modifier(variant 1) (PRM)</h3>
<!-- sizeOf="2" -->
The <b>PRM</b> has two variants. In the first variant, the <b>PRM</b> records
a single <b>sprm</b> with a bit- or byte-sized operand.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fComplex</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>set to 0 for variant 1</td>
</tr>

<tr>
<td></td>

<td></td>

<td>isprm</td>

<td>U16</td>

<td>:7</td>

<td>00FE</td>

<td>index to entry into rgsprmPrm</td>
</tr>

<tr>
<td></td>

<td></td>

<td>val</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>sprm's operand</td>
</tr>
</table>

<p>cbPRM (count of bytes of PRM) is 2.
<p>Since isprm is 7 bits, rgsprmPrm can hold 0x80 entries.
<p>{sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmPIncLvl, sprmPJc, sprmPFSideBySide,
sprmPFKeep, sprmPFKeepFollow, sprmPFPageBreakBefore, sprmPBrcl, sprmPBrcp,
sprmPIlvl, sprmNoop, sprmPFNoLineNumb, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmPFInTable, sprmPFTtp,
sprmNoop, sprmNoop, sprmNoop, sprmPPc, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmNoop, sprmNoop, sprmNoop, sprmPWr, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmNoop, sprmNoop, sprmPFNoAutoHyph, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmNoop, sprmPFLocked, sprmPFWidowControl, sprmNoop, sprmPFKinsoku, sprmPFWordWrap,
sprmPFOverflowPunct, sprmPFTopLinePunct, sprmPFAutoSpaceDE, sprmPFAutoSpaceDN,
sprmNoop, sprmNoop, sprmPISnapBaseLine, sprmNoop, sprmNoop, sprmNoop, sprmCFStrikeRM,
sprmCFRMark, sprmCFFldVanish, sprmNoop, sprmNoop, sprmNoop, sprmCFData,
sprmNoop, sprmNoop, sprmNoop, sprmCFOle2, sprmNoop, sprmCHighlight, sprmCFEmboss,
sprmCSfxText, sprmNoop, sprmNoop, sprmNoop, sprmCPlain, sprmNoop, sprmCFBold,
sprmCFItalic, sprmCFStrike, sprmCFOutline, sprmCFShadow, sprmCFSmallCaps,
sprmCFCaps, sprmCFVanish, sprmNoop, sprmCKul, sprmNoop, sprmNoop, sprmNoop,
sprmCIco, sprmNoop, sprmCHpsInc, sprmNoop, sprmCHpsPosAdj, sprmNoop, sprmCIss,
sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmNoop, sprmNoop, sprmCFDStrike, sprmCFImprint, sprmCFSpec, sprmCFObj,
sprmPicBrcl, sprmPOutLvl, sprmNoop, sprmNoop, sprmNoop, sprmNoop, sprmNoop,
sprmPPnbrRMarkNot}
<br><a NAME="76"></a>
<h3>
Property Modifier(variant 2) (PRM2)</h3>
In the second variant, prm.fComplex is 1, and the rest of the structure
records an index to a grpprl stored in the <b>CLX</b> (described in <b>Complex
File Format</b> topic).
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fComplex</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>set to 1 for variant 2</td>
</tr>

<tr>
<td></td>

<td></td>

<td>igrpprl</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td>index to a <b>grpprl</b> stored in <b>CLX</b> portion of file.</td>
</tr>
</table>

<p>cbPRM (count of bytes of PRM) is 2.
<br><a NAME="78"></a>
<h3>
Routing Recipient (RR)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U16</td>

<td></td>

<td></td>

<td>count of bytes of private system data</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cbSzRecip</td>

<td>U16</td>

<td></td>

<td></td>

<td>count of bytes in recipient string (including null terminator).</td>
</tr>
</table>

<p>cbRR (count of bytes of RR) is 4.
<br><a NAME="77"></a>
<h3>
Routing Slip (RS)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fRouted</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 1, document has been routed to at least one recipient.</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fReturnOrig</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 1, document should be routed to the originator after it has been
routed to all recipients.</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fTrackStatus</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 1, a status message is sent to the originator each time the document
is forwarded to a recipient on the routing list.</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fDirty</td>

<td>S16</td>

<td></td>

<td></td>

<td>unused( should be 0)</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>nProtect</td>

<td>S16</td>

<td></td>

<td></td>

<td>document protection while routing
<br>0 recipients can make changes to the document and all changes are untracked.
<br>1 recipients can add annotations and make changes to the document.
Any changes are tracked by revision marks, and revision marking cannot
be turned off.
<br>2 recipients can only add annotations to the document.
<br>3 recipients can enter information only in form fields.</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>iStage</td>

<td>S16</td>

<td></td>

<td></td>

<td>index of the current recipient.</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>delOption</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 0, document is routed to each recipient in turn. when 1, document
is routed to all recipients simultaneously.</td>
</tr>

<tr>
<td>14</td>

<td>E</td>

<td>cRecip</td>

<td>S16</td>

<td></td>

<td></td>

<td>count of recipients.</td>
</tr>
</table>

<p>cbRS (count of bytes of RS) is 16 (decimal), 10 (hex).
<br><a NAME="79"></a>
<h3>
Section Descriptor (SED)</h3>
<!-- sizeOf="12" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fn</td>

<td>S16</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fcSepx</td>

<td>U32</td>

<td></td>

<td></td>

<td>file offset in main stream to beginning of SEPX stored for section.
If sed.fcSepx == 0xFFFFFFFF, the section properties for the section are
equal to the standard SEP (see SEP definition).</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fnMpr</td>

<td>S16</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>fcMpr</td>

<td>U32</td>

<td></td>

<td></td>

<td>points to offset in FC space of main stream where the Macintosh Print
Record for a document created on a Mac will be stored</td>
</tr>
</table>

<p>cbSED (count of bytes of SED) is 12 (decimal), C (hex).
<br><a NAME="80"></a>
<h3>
Section Properties (SEP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>bkc</td>

<td>U8</td>
<!-- initial="2" -->

<td></td>

<td></td>

<td>break code:
<br>0 No break
<br>1 New column
<br>2 New page
<br>3 Even page
<br>4 Odd page</td>
</tr>

<tr>
<td>1</td>

<td>1</td>

<td>fTitlePage</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1 when a title page is to be displayed</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fAutoPgn</td>

<td>S8</td>

<td></td>

<td></td>

<td>only for Mac compatibility, used only during open, when 1, sep.dxaPgn
and sep.dyaPgn are valid page number locations</td>
</tr>

<tr>
<td>3</td>

<td>3</td>

<td>nfcPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>page number format code:
<br>0 Arabic
<br>1 Roman (upper case)
<br>2 Roman (lower case)
<br>3 Letter (upper case)
<br>4 Letter (lower case)</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fUnlocked</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1, when a section in a locked document is unlocked</td>
</tr>

<tr>
<td>5</td>

<td>5</td>

<td>cnsPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>chapter number separator for page numbers</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fPgnRestart</td>

<td>U8</td>

<td></td>

<td></td>

<td>set to 1 when page numbering should be restarted at the beginning of
this section</td>
</tr>

<tr>
<td>7</td>

<td>7</td>

<td>fEndNote</td>
<!-- initial="1" -->

<td>U8</td>

<td></td>

<td></td>

<td>when 1, footnotes placed at end of section. When 0, footnotes are placed
at bottom of page.</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>lnc</td>

<td>S8</td>

<td></td>

<td></td>

<td>line numbering code:
<br>0 Per page
<br>1 Restart
<br>2 Continue</td>
</tr>

<tr>
<td>9</td>

<td>9</td>

<td>grpfIhdt</td>

<td>S8</td>

<td></td>

<td></td>

<td>specification of which headers and footers are included in this section.
See explanation in Headers and Footers topic. No longer used.</td>
</tr>

<tr>
<td>10</td>

<td>A</td>

<td>nLnnMod</td>

<td>U16</td>

<td></td>

<td></td>

<td>if 0, no line numbering, otherwise this is the line number modulus
(e.g. if nLnnMod is 5, line numbers appear on line 5, 10, etc.)</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>dxaLnn</td>

<td>S32</td>

<td></td>

<td></td>

<td>distance of</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>dxaPgn</td>
<!-- initial="720" -->

<td>S16</td>

<td></td>

<td></td>

<td>when fAutoPgn ==1, gives the x position of auto page number on page
in twips (for Mac compatibility only)</td>
</tr>

<tr>
<td>18</td>

<td>12</td>

<td>dyaPgn</td>
<!-- initial="720" -->

<td>S16</td>

<td></td>

<td></td>

<td>when fAutoPgn ==1, gives the y position of auto page number on page
in twips (for Mac compatibility only)</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>fLBetween</td>

<td>S8</td>

<td></td>

<td></td>

<td>when ==1, draw vertical lines between columns</td>
</tr>

<tr>
<td>21</td>

<td>15</td>

<td>vjc</td>

<td>S8</td>

<td></td>

<td></td>

<td>vertical justification code
<br>0 top justified
<br>1 centered
<br>2 fully justified vertically
<br>3 bottom justified</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>dmBinFirst</td>

<td>U16</td>

<td></td>

<td></td>

<td>bin number supplied from windows printer driver indicating which bin
the first page of section will be printed.</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dmBinOther</td>

<td>U16</td>

<td></td>

<td></td>

<td>bin number supplied from windows printer driver indicating which bin
the pages other than the first page of section will be printed.</td>
</tr>

<tr>
<td>26</td>

<td>1A</td>

<td>dmPaperReq</td>

<td>U16</td>

<td></td>

<td></td>

<td>dmPaper code for form selected by user</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>top page border</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>left page border</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>bottom page border</td>
</tr>

<tr>
<td>40</td>

<td>28</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>right page border</td>
</tr>

<tr>
<td>44</td>

<td>2C</td>

<td>fPropRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>when 1, properties have been changed with revision marking on</td>
</tr>

<tr>
<td>46</td>

<td>2E</td>

<td>ibstPropRMark</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to author IDs stored in hsttbfRMark. used when properties have
been changed when revision marking was enabled</td>
</tr>

<tr>
<td>48</td>

<td>30</td>

<td>dttmPropRMark</td>

<td>DTTM</td>

<td></td>

<td></td>

<td>Date/time at which properties of this were changed for this run of
text by the author. (Only recorded when revision marking is on.)</td>
</tr>

<tr>
<td>52</td>

<td>34</td>

<td>dxtCharSpace</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>56</td>

<td>38</td>

<td>dyaLinePitch</td>

<td>S32</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>60</td>

<td>3C</td>

<td>clm</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>62</td>

<td>3E</td>

<td>unused62</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>64</td>

<td>40</td>

<td>dmOrientPage</td>
<!-- initial="1" -->

<td>U8</td>

<td></td>

<td></td>

<td>orientation of pages in that section. set to 1 when portrait, 2 when
landscape</td>
</tr>

<tr>
<td>65</td>

<td>41</td>

<td>iHeadingPgn</td>

<td>U8</td>

<td></td>

<td></td>

<td>heading number level for page number</td>
</tr>

<tr>
<td>66</td>

<td>42</td>

<td>pgnStart</td>
<!-- initial="1" -->

<td>U16</td>

<td></td>

<td></td>

<td>user specified starting page number.</td>
</tr>

<tr>
<td>68</td>

<td>44</td>

<td>lnnMin</td>

<td>S16</td>

<td></td>

<td></td>

<td>beginning line number for section</td>
</tr>

<tr>
<td>70</td>

<td>46</td>

<td>wTextFlow</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>72</td>

<td>48</td>

<td>unused72</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>74</td>

<td>4A</td>

<td>pgbApplyTo</td>

<td>U16</td>

<td>:3</td>

<td>0007</td>

<td>pgbProp page border properties. page border applies to:
<br>0 all pages in this section
<br>1 first page in this section
<br>2 all pages in this section but first
<br>3 whole document (all sections)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pgbPageDepth</td>

<td>U16</td>

<td>:2</td>

<td>0018</td>

<td>page border depth:
<br>0 in front
<br>1 in back</td>
</tr>

<tr>
<td></td>

<td></td>

<td>pgbOffsetFrom</td>

<td>U16</td>

<td>:3</td>

<td>00E0</td>

<td>page border offset from:
<br>0 offset from text
<br>1 offset from edge of page</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused74_8</td>

<td>U16</td>

<td>:8</td>

<td>FF00</td>

<td>reserved</td>
</tr>

<tr>
<td>76</td>

<td>4C</td>

<td>xaPage</td>
<!-- initial="12240" -->

<td>U32</td>

<td></td>

<td></td>

<td>default value is 12240 twipswidth of page</td>
</tr>

<tr>
<td>80</td>

<td>50</td>

<td>yaPage</td>
<!-- initial="15840" -->

<td>U32</td>

<td></td>

<td></td>

<td>default value is 15840 twipsheight of page</td>
</tr>

<tr>
<td>84</td>

<td>54</td>

<td>xaPageNUp</td>
<!-- initial="12240" -->

<td>U32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>88</td>

<td>58</td>

<td>yaPageNUp</td>
<!-- initial="15840" -->

<td>U32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>92</td>

<td>5C</td>

<td>dxaLeft</td>
<!-- initial="1800" -->

<td>U32</td>

<td></td>

<td></td>

<td>default value is 1800 twipsleft margin</td>
</tr>

<tr>
<td>96</td>

<td>60</td>

<td>dxaRight</td>
<!-- initial="1800" -->

<td>U32</td>

<td></td>

<td></td>

<td>default value is 1800 twipsright margin</td>
</tr>

<tr>
<td>100</td>

<td>64</td>

<td>dyaTop</td>
<!-- initial="1440" -->

<td>S32</td>

<td></td>

<td></td>

<td>default value is 1440 twipstop margin</td>
</tr>

<tr>
<td>104</td>

<td>68</td>

<td>dyaBottom</td>
<!-- initial="1440" -->

<td>S32</td>

<td></td>

<td></td>

<td>default value is 1440 twipsbottom margin</td>
</tr>

<tr>
<td>108</td>

<td>6C</td>

<td>dzaGutter</td>

<td>U32</td>

<td></td>

<td></td>

<td>default value is 0 twips gutter width</td>
</tr>

<tr>
<td>112</td>

<td>70</td>

<td>dyaHdrTop</td>
<!-- initial="720" -->

<td>U32</td>

<td></td>

<td></td>

<td>y position of top header measured from top edge of page.</td>
</tr>

<tr>
<td>116</td>

<td>74</td>

<td>dyaHdrBottom</td>
<!-- initial="720" -->

<td>U32</td>

<td></td>

<td></td>

<td>y position of bottom header measured from top edge of page.</td>
</tr>

<tr>
<td>120</td>

<td>78</td>

<td>ccolM1</td>

<td>S16</td>

<td></td>

<td></td>

<td>number of columns in section - 1.</td>
</tr>

<tr>
<td>122</td>

<td>7A</td>

<td>fEvenlySpaced</td>
<!-- initial="1" -->

<td>S8</td>

<td></td>

<td></td>

<td>when == 1, columns are evenly spaced. Default value is 1.</td>
</tr>

<tr>
<td>123</td>

<td>7B</td>

<td>unused123</td>

<td>U8</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>124</td>

<td>7C</td>

<td>dxaColumns</td>
<!-- initial="720" -->

<td>S32</td>

<td></td>

<td></td>

<td>distance that will be maintained between columns</td>
</tr>

<tr>
<td>128</td>

<td>80</td>

<td>rgdxaColumnWidthSpacing</td>

<td>std::vector<U32></td>

<td></td>

<td></td>

<td>array of 89 longs that determine bounds of irregular width columns [Changed that to a
vector for obvoius reasons (Werner)]</td>
</tr>

<tr>
<td>484</td>

<td>1E4</td>

<td>dxaColumnWidth</td>

<td>S32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>488</td>

<td>1E8</td>

<td>dmOrientFirst</td>

<td>U8</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>489</td>

<td>1E9</td>

<td>fLayout</td>

<td>U8</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>490</td>

<td>1EA</td>

<td>unused490</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>492</td>

<td>1EC</td>

<td>olstAnm</td>

<td>OLST</td>

<td></td>

<td></td>

<td>multilevel autonumbering list data (see OLST definition)</td>
</tr>
</table>

<p>The standard SEP is all zeros except as follows:
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>bkc</td>

<td>2 (new page)</td>
</tr>

<tr>
<td>dyaPgn</td>

<td>720 twips (equivalent to .5 in)</td>
</tr>

<tr>
<td>dxaPgn</td>

<td>720 twips</td>
</tr>

<tr>
<td>fEndnote</td>

<td>1 (True)</td>
</tr>

<tr>
<td>fEvenlySpaced</td>

<td>1 (True)</td>
</tr>

<tr>
<td>xaPage</td>

<td>12240 twips</td>
</tr>

<tr>
<td>yaPage</td>

<td>15840 twips</td>
</tr>

<tr>
<td>xaPageNUp</td>

<td>12240 twips</td>
</tr>

<tr>
<td>yaPageNUp</td>

<td>15840 twips</td>
</tr>

<tr>
<td>dyaHdrTop</td>

<td>720 twips</td>
</tr>

<tr>
<td>dyaHdrBottom</td>

<td>720 twips</td>
</tr>

<tr>
<td>dmOrientPage</td>

<td>1 (portrait orientation)</td>
</tr>

<tr>
<td>dxaColumns</td>

<td>720 twips</td>
</tr>

<tr>
<td>dyaTop</td>

<td>1440 twips</td>
</tr>

<tr>
<td>dxaLeft</td>

<td>1800 twips</td>
</tr>

<tr>
<td>dyaBottom</td>

<td>1440 twips</td>
</tr>

<tr>
<td>dxaRight</td>

<td>1800 twips</td>
</tr>

<tr>
<td>pgnStart</td>

<td>1</td>
</tr>
</table>

<p>cbSEP (count of bytes of SEP) is 704(decimal), 2C0(hex).
<br><a NAME="81"></a>
<h3>
Section Property Exceptions (SEPX)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comment</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cb</td>

<td>U16</td>

<td></td>

<td></td>

<td>count of bytes in remainder of <b>SEPX.</b></td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>grpprl</td>

<td>U8[]</td>

<td>cb</td>

<td></td>

<td>list of sprms that encodes the differences between the properties of
a section and Word's default section properties.</td>
</tr>
</table>
<a NAME="82"></a>
<h3>
Shading Descriptor (SHD)</h3>
The SHD is a substructure of the <b>CHP</b> and <b>PAP</b>.
<!-- sizeOf="2" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>icoFore</td>

<td>U16</td>

<td>:5</td>

<td>001F</td>

<td>foreground color (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>icoBack</td>

<td>U16</td>

<td>:5</td>

<td>03E0</td>

<td>background color (see chp.ico)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>ipat</td>

<td>U16</td>

<td>:6</td>

<td>FC00</td>

<td>shading pattern (see ipat table below)
<br>0 Automatic
<br>1 Solid
<br>2 5 Percent
<br>3 10 Percent
<br>4 20 Percent
<br>5 25 Percent
<br>6 30 Percent
<br>7 40 Percent
<br>8 50 Percent
<br>9 60 Percent
<br>10 70 Percent
<br>11 75 Percent
<br>12 80 Percent
<br>13 90 Percent
<br>14 Dark Horizontal
<br>15 Dark Vertical
<br>16 Dark Forward Diagonal
<br>17 Dark Backward Diagonal
<br>18 Dark Cross
<br>19 Dark Diagonal Cross
<br>20 Horizontal
<br>21 Vertical
<br>22 Forward Diagonal
<br>23 Backward Diagonal
<br>24 Cross
<br>25 Diagonal Cross
<br>35 2.5 Percent
<br>36 7.5 Percent
<br>37 12.5 Percent
<br>38 15 Percent
<br>39 17.5 Percent
<br>40 22.5 Percent
<br>41 27.5 Percent
<br>42 32.5 Percent
<br>43 35 Percent
<br>44 37.5 Percent
<br>45 42.5 Percent
<br>46 45 Percent
<br>47 47.5 Percent
<br>48 52.5 Percent
<br>49 55 Percent
<br>50 57.5 Percent
<br>51 62.5 Percent
<br>52 65 Percent
<br>53 67.5 Percent
<br>54 72.5 Percent
<br>55 77.5 Percent
<br>56 82.5 Percent
<br>57 85 Percent
<br>58 87.5 Percent
<br>59 92.5 Percent
<br>60 95 Percent
<br>61 97.5 Percent
<br>62 97 Percent</td>
</tr>
</table>

<p>cbSHD (count of bytes of SHD) is 2.
<br><a NAME="15"></a>
<h3>
STyle Definition (STD)</h3>
The style description is stored in an STD structure as follows:
<pre>// STD: STyle Definition
//&nbsp;&nbsp; The STD contains the entire definition of a style.
//&nbsp;&nbsp; It has two parts, a fixed-length base (cbSTDBase bytes long)
//&nbsp;&nbsp; and a variable length remainder holding the name, and the upx and upe
//&nbsp;&nbsp; arrays (a upx and upe for each type stored in the style, std.cupx)
//&nbsp;&nbsp; Note that new fields can be added to the BASE of the STD without
//&nbsp;&nbsp; invalidating the file format, because the STSHI contains the length
//&nbsp;&nbsp; that is stored in the file.&nbsp; When reading STDs from an older version,
//&nbsp;&nbsp; new fields will be zero.</pre>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>sti</td>

<td>U16</td>

<td>:12</td>

<td>0FFF</td>

<td>invariant style identifier</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fScratch</td>

<td>U16</td>

<td>:1</td>

<td>1000</td>

<td>spare field for any temporary use, always reset back to zero!</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fInvalHeight</td>

<td>U16</td>

<td>:1</td>

<td>2000</td>

<td>PHEs of all text with this style are wrong</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHasUpe</td>

<td>U16</td>

<td>:1</td>

<td>4000</td>

<td>UPEs have been generated</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMassCopy</td>

<td>U16</td>

<td>:1</td>

<td>8000</td>

<td>std has been mass-copied; if unused at save time, style should be deleted</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>sgc</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td>style type code</td>
</tr>

<tr>
<td></td>

<td></td>

<td>istdBase</td>

<td>U16</td>

<td>:12</td>

<td>FFF0</td>

<td>base style</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>cupx</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td># of UPXs (and UPEs)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>istdNext</td>

<td>U16</td>

<td>:12</td>

<td>FFF0</td>

<td>next style</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>bchUpe</td>

<td>U16</td>

<td></td>

<td></td>

<td>offset to end of upx's, start of upe's</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>fAutoRedef</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>auto redefine style when appropriate</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHidden</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>hidden from UI?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused8_3</td>

<td>U16</td>

<td>:14</td>

<td>FFFC</td>

<td>unused bits</td>
</tr>

<tr>
<td>10</td>

<td>0xA</td>

<td>xstzName</td>

<td>XCHAR[]</td>

<td></td>

<td></td>

<td>sub-names are separated by chDelimStyle</td>
</tr>

<tr>
<td></td>

<td></td>

<td>grupx</td>

<td>U8[]</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>grupe</td>

<td>U8[]</td>

<td></td>

<td></td>

<td>the UPEs are not stored on the file; they are a cache of the based-on
chain</td>
</tr>
</table>

<p>The cb preceding each STD is the length of the data, which includes
all of the STD except the grupe array (which is derived after the file
is read in, by building each UPE from the base style UPE plus the exceptions
in the UPX.) A cb of zero indicates an empty slot in the style array, i.e.
no style has that istd. Note that the STD structure may be longer or shorter
than the one stored in the file, stshi.cbSTDBaseInFile indicates the length
of the base of the STD (up to stzName) as stored in the file. The stylesheet
reader routine has to take this into account.
<p>The variable-length part of the STD actually has three variable-length
subparts, the xstzName, the grupx, and the grupe. Since this doesn't fit
well into a C structure declaration, some processing is needed to figure
out where one part stops and the next part begins. An important note is
that all variable-length parts and subparts of the STD begin on EVEN-BYTE
OFFSETS within the STD, even if the length of the preceding variable-length
part was odd.
<p>std.sti: The sti is an identifier which built-in style this is, or stiUser
for a user-defined style. An sti is intended to be permanent through versions
of Word, although new sti's may be added in new versions. The sti definitions
are:
<pre>// standard sti codes - these are invariant identifiers for built-in styles
// and must remain the same (i.e. don't renumber them, or old files will be
// messed up.)
// NOTE: sti and istd are the same for Normal and level styles
// If you want to define a new built-in style:
//&nbsp;&nbsp; 1) Decide if you really need one--it will exist in all future versions!
//&nbsp;&nbsp; 2) Add a new sti below.&nbsp; You can take the first available slot.
//&nbsp;&nbsp; 3) Change stiMax, and stiPapMax or stiChpMax
//&nbsp;&nbsp; 4) Add entry to _dnsti, and the two ids's in strman.pp
//&nbsp;&nbsp; 5) Add case in GetDefaultUpdForSti
//&nbsp;&nbsp; 6) Change cstiMaxBuiltinDependents if necessary
// If you want to change the definition of a built-in style
//&nbsp;&nbsp; 1) In order to make WinWord 2 documents that use the style look like
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; they did in WinWord 2, add a case in GetDefaultUpdForSti to handle
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fOldDef.&nbsp; This definition will be used when converting WinWord 2
//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stylesheets.
//&nbsp;&nbsp; 2) If you change the name of a built-in style, increment nVerBuiltInNames
#define stiNormal&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp; // 0x0000

#define stiLev1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1&nbsp;&nbsp;&nbsp;&nbsp; // 0x0001
#define stiLev2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2&nbsp;&nbsp;&nbsp;&nbsp; // 0x0002
#define stiLev3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3&nbsp;&nbsp;&nbsp;&nbsp; // 0x0003
#define stiLev4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4&nbsp;&nbsp;&nbsp;&nbsp; // 0x0004
#define stiLev5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5&nbsp;&nbsp;&nbsp;&nbsp; // 0x0005
#define stiLev6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 6&nbsp;&nbsp;&nbsp;&nbsp; // 0x0006
#define stiLev7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 7&nbsp;&nbsp;&nbsp;&nbsp; // 0x0007
#define stiLev8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 8&nbsp;&nbsp;&nbsp;&nbsp; // 0x0008
#define stiLev9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9&nbsp;&nbsp;&nbsp;&nbsp; // 0x0009
#define stiLevFirst&nbsp;&nbsp;&nbsp; stiLev1
#define stiLevLast&nbsp;&nbsp;&nbsp;&nbsp; stiLev9

#define stiIndex1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10&nbsp;&nbsp;&nbsp; // 0x000A
#define stiIndex2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11&nbsp;&nbsp;&nbsp; // 0x000B
#define stiIndex3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 12&nbsp;&nbsp;&nbsp; // 0x000C
#define stiIndex4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 13&nbsp;&nbsp;&nbsp; // 0x000D
#define stiIndex5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 14&nbsp;&nbsp;&nbsp; // 0x000E
#define stiIndex6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 15&nbsp;&nbsp;&nbsp; // 0x000F
#define stiIndex7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 16&nbsp;&nbsp;&nbsp; // 0x0010
#define stiIndex8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 17&nbsp;&nbsp;&nbsp; // 0x0011
#define stiIndex9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 18&nbsp;&nbsp;&nbsp; // 0x0012
#define stiIndexFirst&nbsp; stiIndex1
#define stiIndexLast&nbsp;&nbsp; stiIndex9

#define stiToc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 19&nbsp;&nbsp;&nbsp; // 0x0013
#define stiToc2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 20&nbsp;&nbsp;&nbsp; // 0x0014
#define stiToc3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 21&nbsp;&nbsp;&nbsp; // 0x0015
#define stiToc4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 22&nbsp;&nbsp;&nbsp; // 0x0016
#define stiToc5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 23&nbsp;&nbsp;&nbsp; // 0x0017
#define stiToc6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 24&nbsp;&nbsp;&nbsp; // 0x0018
#define stiToc7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 25&nbsp;&nbsp;&nbsp; // 0x0019
#define stiToc8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 26&nbsp;&nbsp;&nbsp; // 0x001A
#define stiToc9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 27&nbsp;&nbsp;&nbsp; // 0x001B
#define stiTocFirst&nbsp;&nbsp;&nbsp; stiToc1
#define stiTocLast&nbsp;&nbsp;&nbsp;&nbsp; stiToc9

#define stiNormIndent&nbsp; 28&nbsp;&nbsp;&nbsp; // 0x001C
#define stiFtnText&nbsp;&nbsp;&nbsp;&nbsp; 29&nbsp;&nbsp;&nbsp; // 0x001D
#define stiAtnText&nbsp;&nbsp;&nbsp;&nbsp; 30&nbsp;&nbsp;&nbsp; // 0x001E
#define stiHeader&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 31&nbsp;&nbsp;&nbsp; // 0x001F
#define stiFooter&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 32&nbsp;&nbsp;&nbsp; // 0x0020
#define stiIndexHeading 33&nbsp;&nbsp; // 0x0021
#define stiCaption&nbsp;&nbsp;&nbsp;&nbsp; 34&nbsp;&nbsp;&nbsp; // 0x0022
#define stiToCaption&nbsp;&nbsp; 35&nbsp;&nbsp;&nbsp; // 0x0023
#define stiEnvAddr&nbsp;&nbsp;&nbsp;&nbsp; 36&nbsp;&nbsp;&nbsp; // 0x0024
#define stiEnvRet&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 37&nbsp;&nbsp;&nbsp; // 0x0025
#define stiFtnRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 38&nbsp;&nbsp;&nbsp; // 0x0026&nbsp; char style
#define stiAtnRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 39&nbsp;&nbsp;&nbsp; // 0x0027&nbsp; char style
#define stiLnn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 40&nbsp;&nbsp;&nbsp; // 0x0028&nbsp; char style
#define stiPgn&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 41&nbsp;&nbsp;&nbsp; // 0x0029&nbsp; char style
#define stiEdnRef&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 42&nbsp;&nbsp;&nbsp; // 0x002A&nbsp; char style
#define stiEdnText&nbsp;&nbsp;&nbsp;&nbsp; 43&nbsp;&nbsp;&nbsp; // 0x002B
#define stiToa&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 44&nbsp;&nbsp;&nbsp; // 0x002C
#define stiMacro&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 45&nbsp;&nbsp;&nbsp; // 0x002D
#define stiToaHeading&nbsp; 46&nbsp;&nbsp;&nbsp; // 0x002E
#define stiList&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 47&nbsp;&nbsp;&nbsp; // 0x002F
#define stiListBullet&nbsp; 48&nbsp;&nbsp;&nbsp; // 0x0030
#define stiListNumber&nbsp; 49&nbsp;&nbsp;&nbsp; // 0x0031
#define stiList2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 50&nbsp;&nbsp;&nbsp; // 0x0032
#define stiList3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 51&nbsp;&nbsp;&nbsp; // 0x0033
#define stiList4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 52&nbsp;&nbsp;&nbsp; // 0x0034
#define stiList5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 53&nbsp;&nbsp;&nbsp; // 0x0035
#define stiListBullet2 54&nbsp;&nbsp;&nbsp; // 0x0036
#define stiListBullet3 55&nbsp;&nbsp;&nbsp; // 0x0037
#define stiListBullet4 56&nbsp;&nbsp;&nbsp; // 0x0038
#define stiListBullet5 57&nbsp;&nbsp;&nbsp; // 0x0039
#define stiListNumber2 58&nbsp;&nbsp;&nbsp; // 0x003A
#define stiListNumber3 59&nbsp;&nbsp;&nbsp; // 0x003B
#define stiListNumber4 60&nbsp;&nbsp;&nbsp; // 0x003C
#define stiListNumber5 61&nbsp;&nbsp;&nbsp; // 0x003D
#define stiTitle&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 62&nbsp;&nbsp;&nbsp; // 0x003E
#define stiClosing&nbsp;&nbsp;&nbsp;&nbsp; 63&nbsp;&nbsp;&nbsp; // 0x003F
#define stiSignature&nbsp;&nbsp; 64&nbsp;&nbsp;&nbsp; // 0x0040
#define stiNormalChar&nbsp; 65&nbsp;&nbsp;&nbsp; // 0x0041&nbsp; char style
#define stiBodyText&nbsp;&nbsp;&nbsp; 66&nbsp;&nbsp;&nbsp; // 0x0042
#define stiBodyText2&nbsp;&nbsp; 67&nbsp;&nbsp;&nbsp; // 0x0043
#define stiListCont&nbsp;&nbsp;&nbsp; 68&nbsp;&nbsp;&nbsp; // 0x0044
#define stiListCont2&nbsp;&nbsp; 69&nbsp;&nbsp;&nbsp; // 0x0045
#define stiListCont3&nbsp;&nbsp; 70&nbsp;&nbsp;&nbsp; // 0x0046
#define stiListCont4&nbsp;&nbsp; 71&nbsp;&nbsp;&nbsp; // 0x0047
#define stiListCont5&nbsp;&nbsp; 72&nbsp;&nbsp;&nbsp; // 0x0048
#define stiMsgHeader&nbsp;&nbsp; 73&nbsp;&nbsp;&nbsp; // 0x0049
#define stiSubtitle&nbsp;&nbsp;&nbsp; 74&nbsp;&nbsp;&nbsp; // 0x004A
#define stiSalutation&nbsp; 75&nbsp;&nbsp;&nbsp; // 0x004B
#define stiDate&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 76&nbsp;&nbsp;&nbsp; // 0X004C
#define stiBodyText1I&nbsp; 77&nbsp;&nbsp;&nbsp; // 0x004D
#define stiBodyText1I2 78&nbsp;&nbsp;&nbsp; // 0x004E
#define stiNoteHeading 79&nbsp;&nbsp;&nbsp; // 0x004F
#define stiBodyText2&nbsp;&nbsp; 80&nbsp;&nbsp;&nbsp; // 0x0050
#define stiBodyText3&nbsp;&nbsp; 81&nbsp;&nbsp;&nbsp; // 0x0051
#define stiBodyTextInd2 82&nbsp;&nbsp; // 0x0052
#define stiBodyTextInd3 83&nbsp;&nbsp; // 0x0053
#define stiBlockQuote&nbsp; 84&nbsp;&nbsp;&nbsp; // 0x0054
#define stiHyperlink&nbsp;&nbsp; 85&nbsp;&nbsp;&nbsp; // 0x0055&nbsp; char style
#define stiHyperlinkFollowed 86 // 0x0056&nbsp;&nbsp; char style
#define stiStrong&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 87&nbsp;&nbsp;&nbsp; // 0x0057&nbsp; char style
#define stiEmphasis&nbsp;&nbsp;&nbsp; 88&nbsp;&nbsp;&nbsp; // 0x0058&nbsp; char style
#define stiNavPane&nbsp;&nbsp;&nbsp;&nbsp; 89&nbsp;&nbsp;&nbsp; // 0x0059&nbsp; char style
#define stiPlainText&nbsp;&nbsp; 90&nbsp;&nbsp;&nbsp; // 0x005A
#define stiMax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 91&nbsp;&nbsp;&nbsp; // number of defined sti's

#define stiUser&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0ffe&nbsp; // user styles are distinguished by name
#define stiNil&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0fff&nbsp; // max for 12 bits</pre>
See below for the names of these styles.
<p>std.stc: The type of each style is indicated by std.sgc. The two types
currently in use are:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>sgcPara</td>

<td>1</td>

<td>// A paragraph style</td>
</tr>

<tr>
<td>sgcChp</td>

<td>2</td>

<td>// A character style</td>
</tr>
</table>

<p>More style types may exist in the future, so styles of an unknown type
should be discarded.
<p>std.istdBase: The style that this style is based on. A style is always
based on another style or the null style (istdNil). Following a "chain"
of based-on styles will always end at the null style, because a based-on
chain cannot have a loop in it. A style can have up to 11 "ancestors" in
its based-on chain, including the null style. A style's definition is built
up from the style that it is based on. See std.cupx, std.grupx, std.grupe.
<p>std.istdNext: The style that should be applied after this one. For a
paragraph style, this is the style that is applied when Enter is pressed
at the end of a paragraph. For a character style, the next style is essentially
ignored, but should be the same as the current style.
<p>std.xstzName: The name of the style, including aliases. The name is
stored as an xstz (preceded by a length byte, followed by a null-terminator.)
[Attention: It seems that for Word97 the lenght "byte" is in fact a short(!) (Werner)]
A style name can contain multiple "aliases", separated by commas. Aliases
are alternate names for the same style (e.g. a style named "a,b,c" has
three aliases, and can be referred to by "a", "b", or "c", or any combination.)
WinWord 2.x did not have aliases, but MacWord 5.x did. If a style is a
built-in style, the built-in stylename is always stored first.
<p>All names (and aliases) must be unique within a stylesheet (e.g. styles
"a,b" and "b,c" should not exist in the same stylesheet, as "b" matches
multiple stylenames.)
<p>A stylename (including all its aliases and comma separators) can be
up to 253 characters long. So the xstz format of that name can be up to
255 characters. Stylenames are case sensitive.
<p>The built-in stylenames (corresponding to each sti above) are defined
for each language version of Word. For the USA, the names are:
<pre>// These are the names of the built-in styles as we want to present them
// to the user.
Normal
Heading 1
Heading 2
Heading 3
Heading 4
Heading 5
Heading 6
Heading 7
Heading 8
Heading 9
Index 1
Index 2
Index 3
Index 4
Index 5
Index 6
Index 7
Index 8
Index 9
TOC 1
TOC 2
TOC 3
TOC 4
TOC 5
TOC 6
TOC 7
TOC 8
TOC 9
Normal Indent
Footnote Text
Annotation Text
Header
Footer
Index Heading
Caption
Table of Figures
Envelope Address
Envelope Return
Footnote Reference
Annotation Reference
Line Number
Page Number
Endnote Reference
Endnote Text
Table of Authorities
Macro Text
TOA Heading
List
List 2
List 3
List 4
List 5
List Bullet
List Bullet 2
List Bullet 3
List Bullet 4
List Bullet 5
List Number
List Number 2
List Number 3
List Number 4
List Number 5
Title
Closing
Signature
Default Paragraph Font
Body Text
Body Text Indent
List Continue
List Continue 2
List Continue 3
List Continue 4
List Continue 5
Message Header
Subtitle
Salutation
Date
Body Text First Indent
Body Text First Indent 2
Note Heading
Body Text 2
Body Text 3
Body Text Indent 2
Body Text Indent 3
Block Text
Hyperlink
Followed Hyperlink
Strong
Emphasis
Document Map
Plain Text</pre>
std.cupx: This is the number of UPXs in the std.grupx array. See below.
<p>std.grupx: This is an array of variable-length UPXs, with std.cupx UPXs
in the array. This array begins after the variable-length xstzName field,
at the next even-byte offset within the STD. A UPX (Universal Property
eXception) describes the difference in formatting of this style as compared
to its based-on style. The UPX structure looks like this:
<pre>typedef union _UPX
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar grpprl[cbMaxGrpprlStyleChpx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } chpx;
&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ushort istd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar grpprl[cbMaxGrpprlStylePapx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } papx;
&nbsp;&nbsp;&nbsp; uchar rgb[1];
&nbsp;&nbsp;&nbsp; } UPX;</pre>
Each UPX stored in a file is not a complete UPX, rather it is a UPX with
all trailing zero bytes lopped off, and preceded by a ushort length field.
So it is stored like:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Field</td>

<td>Size</td>

<td>Comment</td>
</tr>

<tr>
<td>cbUPX</td>

<td>2 bytes</td>

<td>size of the following UPX structure</td>
</tr>

<tr>
<td>UPX</td>

<td>(cbUPX)</td>

<td>Nonzero prefix of a UPX structure</td>
</tr>
</table>

<p>Each UPX begins on an even-byte offset within the STD, even if the length
of the previous UPX (cbUPX) was odd.
<p>The meaning of each UPX depends on the style type (std.sgc). For a paragraph
style, std.cupx is 2. The first UPX is a paragraph UPX (UPX.papx) and the
second UPX is a character UPX (UPX.chpx). For a character style, std.cupx
is 1, and that UPX is a character UPX (UPX.chpx). Note that new UPXs may
be added in the future, so std.cupx might be larger than expected. Any
UPXs past those expected should be discarded.
<p>The grpprl within each UPX contains the differences of this property
type for this style from the UPE of that property type for the based on
style. For example, if two paragraph styles, A and B, were identical except
that B was bold where A was not, and B was based on A, B would have two
UPXs, where the paragraph UPX would have an empty grpprl, and the character
UPX would have a bold sprm in the grpprl. Thus B looks just like A (since
B is based on A), with the exception that B is bold.
<p>std.grupe: This is an array (group) of variable-length UPEs. These are
not stored in the file! Rather, they are constructed using the std.istdBase
and std.grupx fields. A UPE (Universal Property Expansion) describes the
"end-result" of the property formatting, i.e. what the style looks like.
The UPE structure is the non-zero prefix of a UPD structure. The UPD structure
looks like this:
<pre>typedef union _UPD
&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp; PAP pap;
&nbsp;&nbsp;&nbsp; CHP chp;
&nbsp;&nbsp;&nbsp; struct
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ushort istd;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar cbGrpprl;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; uchar grpprl[cbMaxGrpprlStyleChpx];
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } chpx;
&nbsp;&nbsp;&nbsp; } UPD;</pre>
The std.grupe and std.grupx arrays are similar: there is one UPE for each
UPX, and internally they are stored similarly (a length ushort followed
by a non-zero prefix), though remember that the UPEs are not stored in
the file. The meaning of each UPE depends on the style type (std.sgc).
For a paragraph style, the first UPE is a PAP (UPE.pap). The second UPE
is a CHP (UPE.chp). For a character style, the first UPE is a CHPX (UPE.chpx).
<p>The UPEs for a style are constructed by taking the UPEs from the based-on
style, and applying the UPXs to them. Obviously, if the UPEs for the based-on
style haven't yet been constructed, that style's UPE needs to be constructed
first. Eventually by following the based-on chain, a style will be based
on the null style (istdNil). The UPEs for the null style are predefined:
<ul>
<li>
The UPE.pap for the null style is all zeros, except fWidowControl which
is 1, dyaLine which is 240, and fMultLinespace which is 1.</li>

<li>
The UPE.chp for the null style is all zeros, except istd which is 10 (istdNormalChar),
hps which is 20, lid which is 0x0400, and ftc which is set to the STSHI.ftcStandardChpStsh.</li>

<li>
The UPE.chpx for the null style has an istd of zero, a cbGrpprl of zero
(and an empty grpprl).</li>
</ul>
So, for a paragraph style, the first UPE is a UPE.pap. It can be constructed
by starting the with first UPE from the based-on style (std.istdBase),
and then applying the first UPX (UPX.papx) in std.grupx to that UPE. To
apply a UPX.papx to a UPE.pap, set UPE.pap.istd equal to UPX.papx.istd,
and then apply the UPX.papx.grpprl to UPE.pap. Similarly, the second UPE
is a UPE.chp. It can be constructed by starting with the second UPE from
the based-on style, and then applying the second UPX (UPX.chpx) in std.grupx
to that UPE. To apply a UPX.chpx to a UPE.chp, apply the UPX.chpx.grpprl
to UPE.chp. Note that a UPE.chp for a paragraph style should always have
UPE.chp.istd == istdNormalChar.
<p>For a character style, the first (and only) UPE (a UPE.chpx) can be
constructed by starting with the first UPE from the based-on style (std.istdBase),
and then applying the first UPX (UPX.chpx) in std.grupx to that UPE. To
apply a UPX.chpx to a UPE.chpx, take the grpprl in UPE.chpx.grpprl (which
has a length of UPE.chpx.cbGrpprl) and merge the grpprl in UPX.chpx.grpprl
into it. Merging grpprls is a tricky business, but for character styles
it is easy because no prls in character style grpprls should interact with
each other. Each prl from the source (the UPX.chpx.grpprl) should be inserted
into the destination (the UPE.chpx.grpprl) so that the sprm of each prl
is in increasing order, and any prls that have the same sprm are replaced
by the prl in the source. UPE.chpx.cbGrpprl is then set to the length of
resulting grpprl, and UPE.chpx.istd is set to the style's istd.
<br><a NAME="14"></a>
<h3>
STyleSHeet Information (STSHI)</h3>
<!-- sizeOf="18" -->
The STSHI structure has the following format:
<pre>// STSHI: STyleSHeet Information, as stored in a file
//&nbsp; Note that new fields can be added to the STSHI without invalidating
//&nbsp; the file format, because it is stored preceded by it's length.
//&nbsp; When reading a STSHI from an older version, new fields will be zero.</pre>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>cstd</td>

<td>U16</td>

<td></td>

<td></td>

<td>Count of styles in stylesheet</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>cbSTDBaseInFile</td>

<td>U16</td>

<td></td>

<td></td>

<td>Length of STD Base as stored in a file</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>fStdStylenamesWritten</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>Are built-in stylenames stored?</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused4_2</td>

<td>U16</td>

<td>:15</td>

<td>FFFE</td>

<td>Spare flags</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>stiMaxWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Max sti known when this file was written</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>istdMaxFixedWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>How many fixed-index istds are there?</td>
</tr>

<tr>
<td>10</td>

<td>0xA</td>

<td>nVerBuiltInNamesWhenSaved</td>

<td>U16</td>

<td></td>

<td></td>

<td>Current version of built-in stylenames</td>
</tr>

<tr>
<td>12</td>

<td>0xC</td>

<td>rgftcStandardChpStsh</td>

<td>U16[3]</td>

<td></td>

<td></td>

<td>ftc used by StandardChpStsh for this document</td>
</tr>
</table>

<p>The cb preceding the STSHI in the file is the length of the STSHI as
stored in the file. The current definition of the STSHI structure might
be longer or shorter than that stored in the file, the stylesheet reader
routine needs to take this into account.
<p>stshi.cstd: The number of styles in this stylesheet. There will be stshi.cstd
(cbSTD, STD) pairs in the file following the STSHI. Note that styles can
be empty, i.e. cbSTD == 0.
<p>stshi.cbSTDBaseInFile: The STD structure (see below) is divided into
a fixed-length "base", and a variable length part. The stshi.cbSTDBaseInFile
indicates the size in bytes of the fixed-length base of the STD as it was
written in this file. If the STD base is grown in a future version, the
file format doesn't change, because the stylesheet reader can discard parts
it doesn't know about, or use defaults if the file's STD is not as large
as it was expecting. (Currently, stshi.cbSTDBaseInFile is 8.)
<p>stshi.fStdStylenamesWritten: Previous versions of Word did not store
the style name if the style was a built-in style; Word 6.0 does, for compatibility
with future versions. Note that the built-in stylenames may need to be
"regenerated" if the file is opened in a different language or if stshi.nVerBuiltInNamesWhenSaved
doesn't match the expected value.
<p>stshi.stiMaxWhenSaved: This indicates the last built-in style known
to the version of Word that saved this file.
<p>stshi.istdMaxFixedWhenSaved: Each array of styles has some fixed-index
styles at the beginning. This indicates the number of fixed-index positions
reserved in the stylesheet when it was saved.
<p>stshi.nVerBuiltInNamesWhenSaved: Since built-in stylenames are saved
with the document, this provides an way to see if the saved names are the
same "version" as the names in the version of Word that is loading the
file. If not, the built-in stylenames need to be "regenerated", i.e. the
old names need to be replaced with the new.
<p>stshi.rgftcStandardChpStsh: This is the default fonts for this stylesheet.
The first is for Asci characters (0-127), the second is for Far East characters,
and the third is the default font for non-Far East, non-Asci text. See
notes on sprmCRgftcX for details.
<br><a NAME="86"></a>
<h3>
Table Properties (TAP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>jc</td>

<td>S16</td>

<td></td>

<td></td>

<td>justification code. specifies how table row should be justified within
its column.
<br>0 left justify
<br>1 center
<br>2 right justify</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>dxaGapHalf</td>

<td>S32</td>

<td></td>

<td></td>

<td>measures half of the white space that will be maintained between text
in adjacent columns of a table row. A dxaGapHalf width of white space will
be maintained on both sides of a column boundary.</td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>dyaRowHeight</td>

<td>S32</td>

<td></td>

<td></td>

<td>when greater than 0. guarantees that the height of the table will be
at least dyaRowHeight high. When less than 0, guarantees that the height
of the table will be exactly absolute value of dyaRowHeight high. When
0, table will be given a height large enough to represent all of the text
in all of the cells of the table. Cells with vertical text flow make no
contribution to the computation of the height of rows with auto or at least
height. Neither do vertically merged cells, except in the last row of the
vertical merge. If an auto height row consists entirely of cells which
have vertical text direction or are vertically merged, and the row does
not contain the last cell in any vertical cell merge, then the row is given
height equal to that of the end of cell mark in the first cell.</td>
</tr>

<tr>
<td>10</td>

<td>A6</td>

<td>fCantSplit</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, table row may not be split across page bounds</td>
</tr>

<tr>
<td>11</td>

<td>B</td>

<td>fTableHeader</td>

<td>U8</td>

<td></td>

<td></td>

<td>when 1, table row is to be used as the header of the table</td>
</tr>

<tr>
<td>12</td>

<td>C</td>

<td>tlp</td>

<td>TLP</td>

<td></td>

<td></td>

<td>table look specifier (see TLP definition)</td>
</tr>

<tr>
<td>16</td>

<td>10</td>

<td>lwHTMLProps</td>

<td>S32</td>

<td></td>

<td></td>

<td>reserved for future use</td>
</tr>

<tr>
<td>20</td>

<td>14</td>

<td>fCaFull</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFirstRow</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastRow</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fOutline</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>used internally by Word</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused20_12</td>

<td>U16</td>

<td>:12</td>

<td>FFE0</td>

<td>reserved</td>
</tr>

<tr>
<td>22</td>

<td>16</td>

<td>itcMac</td>

<td>S16</td>

<td></td>

<td></td>

<td>count of cells defined for this row. ItcMac must be >= 0 and less than
or equal to 64.</td>
</tr>

<tr>
<td>24</td>

<td>18</td>

<td>dxaAdjust</td>

<td>S32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>28</td>

<td>1C</td>

<td>dxaScale</td>

<td>S32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>32</td>

<td>20</td>

<td>dxsInch</td>

<td>S32</td>

<td></td>

<td></td>

<td>used internally by Word</td>
</tr>

<tr>
<td>36</td>

<td>24</td>

<td>rgdxaCenter</td>

<td>std::vector<S16></td>

<td></td>

<td></td>

<td>rgdxaCenter[0] is the left boundary of cell 0 measured relative to
margin.. rgdxaCenter[tap.itcMac - 1] is left boundary of last cell. rgdxaCenter[tap.itcMac]
is right boundary of last cell. (Changed the array to a vector)</td>
</tr>

<tr>
<td>166</td>

<td>A6</td>

<td>rgdxaCenterPrint</td>

<td>std::vector<S16></td>

<td></td>

<td></td>

<td>used internally by Word (Changed the array to a vector)</td>
</tr>

<tr>
<td>296</td>

<td>128</td>

<td>rgtc</td>

<td>std::vector<TC></td>

<td></td>

<td></td>

<td>array of table cell descriptors (Changed the array to a vector)</td>
</tr>

<tr>
<td>1576</td>

<td>628</td>

<td>rgshd</td>

<td>std::vector<SHD></td>

<td></td>

<td></td>

<td>array of cell shades (Changed the array to a vector)</td>
</tr>

<tr>
<td>1704</td>

<td>6A8</td>

<td>rgbrcTable</td>

<td>BRC[6]</td>

<td></td>

<td></td>

<td>array of border defaults for cells</td>
</tr>
</table>

<p>cbTAP (count of bytes of TAP) is 1728 (decimal), 6C0(hex).
<br><a NAME="83"></a>
<h3>
Tab Descriptor (TBD)</h3>
The <b>TBD</b> is a substructure of the <b>PAP</b>.
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>jc</td>

<td>U8</td>

<td>:3</td>

<td>07</td>

<td>justification code
<br>0 left tab
<br>1 centered tab
<br>2 right tab
<br>3 decimal tab
<br>4 bar</td>
</tr>

<tr>
<td></td>

<td></td>

<td>tlc</td>

<td>U8</td>

<td>:3</td>

<td>38</td>

<td>tab leader code
<br>0 no leader
<br>1 dotted leader
<br>2 hyphenated leader
<br>3 single line leader
<br>4 heavy line leader</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused0_6</td>

<td>U8</td>

<td>:2</td>

<td>C0</td>

<td>reserved</td>
</tr>
</table>

<p>cbTBD (count of bytes of TBD) is 1.
<br><a NAME="84"></a>
<h3>
Table Cell Descriptors (TC)</h3>
The <b>TC</b> is a substructure of the <b>TAP.</b>
<!-- sizeOf="20" -->
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fFirstMerged</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>set to 1 when cell is first cell of a range of cells that have been
merged. When a cell is merged, the display areas of the merged cells are
consolidated and the text within the cells is interpreted as belonging
to one text stream for purposes of calculating line breaks.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fMerged</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>set to 1 when cell has been merged with preceding cell.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVertical</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>set to 1 when cell has vertical text flow</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBackward</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>for a vertical table cell, text flow is bottom to top when 1 and is
bottom to top when 0.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fRotateFont</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>set to 1 when cell has rotated characters (i.e. uses @font)</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVertMerge</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>set to 1 when cell is vertically merged with the cell(s) above and/or
below. When cells are vertically merged, the display area of the merged
cells are consolidated. The consolidated area is used to display the contents
of the first vertically merged cell (the cell with fVertRestart set to
1), and all other vertically merged cells (those with fVertRestart set
to 0) must be empty. Cells can only be merged vertically if their left
and right boundaries are (nearly) identical (i.e. if corresponding entries
in rgdxaCenter of the table rows differ by at most 3).</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fVertRestart</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>set to 1 when the cell is the first of a set of vertically merged cells.
The contents of a cell with fVertStart set to 1 are displayed in the consolidated
area belonging to the entire set of vertically merged cells. Vertically
merged cells with fVertRestart set to 0 must be empty.</td>
</tr>

<tr>
<td></td>

<td></td>

<td>vertAlign</td>

<td>U16</td>

<td>:2</td>

<td>0180</td>

<td>specifies the alignment of the cell contents relative to text flow
(e.g. in a cell with bottom to top text flow and bottom vertical alignment,
the text is shifted horizontally to match the cell's right boundary):
<br>0 top
<br>1 center
<br>2 bottom</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fUnused</td>

<td>U16</td>

<td>:7</td>

<td>FE00</td>

<td>reserved</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>wUnused</td>

<td>U16</td>

<td></td>

<td></td>

<td>reserved</td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>brcTop</td>

<td>BRC</td>

<td></td>

<td></td>

<td>BRC[cbrcTc] rgbrc: notational convenience for referring to brcTop,
brcLeft, etc. fields.
<br>specification of the top border of a table cell</td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>brcLeft</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of left border of table row</td>
</tr>

<tr>
<td>12</td>

<td>12</td>

<td>brcBottom</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of bottom border of table row</td>
</tr>

<tr>
<td>16</td>

<td>16</td>

<td>brcRight</td>

<td>BRC</td>

<td></td>

<td></td>

<td>specification of right border of table row.</td>
</tr>
</table>

<p>cbTC (count of bytes of TC) is 20(decimal), 14(hex).
<br><a NAME="85"></a>
<h3>
Table Autoformat Look sPecifier (TLP)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>itl</td>

<td>S16</td>

<td></td>

<td></td>

<td>index to Word's table of table looks:
<br>0 (none)
<br>1 Simple 1
<br>2 Simple 2
<br>3 Simple 3
<br>4 Classic 1
<br>5 Classic 2
<br>6 Classic 3
<br>7 Classic 4
<br>8 Colorful 1
<br>9 Colorful 2
<br>10 Colorful 3
<br>11 Columns 1
<br>12 Columns 2
<br>13 Columns 3
<br>14 Columns 4
<br>15 Columns 5
<br>16 Grid 1
<br>17 Grid 2
<br>18 Grid 3
<br>19 Grid 4
<br>20 Grid 5
<br>21 Grid 6
<br>22 Grid 7
<br>23 Grid 8
<br>24 List 1
<br>25 List 2
<br>26 List 3
<br>27 List 4
<br>28 List 5
<br>29 List 6
<br>30 List 7
<br>31 List 8
<br>32 3D Effects 1
<br>33 3D Effects 2
<br>34 3D Effects 3
<br>35 Contemporary
<br>36 Elegant
<br>37 Professional
<br>38 Subtle1
<br>39 Subtle2</td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>fBorders</td>

<td>U16</td>

<td>:1</td>

<td>0001</td>

<td>when ==1, use the border properties from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fShading</td>

<td>U16</td>

<td>:1</td>

<td>0002</td>

<td>when ==1, use the shading properties from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fFont</td>

<td>U16</td>

<td>:1</td>

<td>0004</td>

<td>when ==1, use the font from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fColor</td>

<td>U16</td>

<td>:1</td>

<td>0008</td>

<td>when ==1, use the color from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fBestFit</td>

<td>U16</td>

<td>:1</td>

<td>0010</td>

<td>when ==1, do best fit from the selected table look</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHdrRows</td>

<td>U16</td>

<td>:1</td>

<td>0020</td>

<td>when ==1, apply properties from the selected table look to the header
rows in the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastRow</td>

<td>U16</td>

<td>:1</td>

<td>0040</td>

<td>when ==1, apply properties from the selected table look to the last
row in the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fHdrCols</td>

<td>U16</td>

<td>:1</td>

<td>0080</td>

<td>when ==1, apply properties from the selected table look to the header
columns of the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>fLastCol</td>

<td>U16</td>

<td>:1</td>

<td>0100</td>

<td>when ==1, apply properties from the selected table look to the last
column of the table</td>
</tr>

<tr>
<td></td>

<td></td>

<td>unused2_9</td>

<td>U16</td>

<td>:7</td>

<td>FE00</td>

<td>unused</td>
</tr>
</table>

<p>cbTLP (count of bytes of TLP) is 4.
<br><a NAME="88"></a>
<h3>
WorK Book (WKB)</h3>

<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>b10</td>

<td>b16</td>

<td>field</td>

<td>type</td>

<td>size</td>

<td>bitfield</td>

<td>comments</td>
</tr>

<tr>
<td>0</td>

<td>0</td>

<td>fn</td>

<td>S16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>2</td>

<td>2</td>

<td>grfwkb</td>

<td>U16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>4</td>

<td>4</td>

<td>lvl</td>

<td>S16</td>

<td></td>

<td></td>

<td></td>
</tr>

<tr>
<td>6</td>

<td>6</td>

<td>fnpt</td>

<td>U16</td>

<td>:4</td>

<td>000F</td>

<td></td>
</tr>

<tr>
<td></td>

<td></td>

<td>fnpd</td>

<td>U16</td>

<td>:12</td>

<td>FFF0</td>

<td></td>
</tr>

<tr>
<td>8</td>

<td>8</td>

<td>doc</td>

<td>S32</td>

<td></td>

<td></td>

<td>unused</td>
</tr>
</table>

<p>cbWKB (count of bytes of WKB) is 12 (decimal), C (hex).
<br><a NAME="89"></a>
<h2>
Appendix A - Reading a Macintosh PICT Graphic</h2>
As described under "picture" in the Definition section of this document,
some pictures in Word documents are stored as Macintosh PICT graphics,
particularly in files created by Word for the Macintosh. All pictures,
including these, are stored as a block of binary data attached to a special
chPic character in the text stream. This block always begins with a PIC
structure. (Please see the "picture" definition mentioned above for more
information on general picture-reading.)
<p>Normal graphics follow the PIC structure with a single Office shape,
Windows metafile, bitmap, or TIFF representation, as described in the "picture"
definition section. Macintosh PICT graphics have a standard, unchanging
Windows metafile after the PIC which always depicts an "x", followed by
the actual Macintosh PICT picture. This is for backward-compatibility with
older readers, which expect to find a Windows metafile after the PIC structure.
These readers will simply display the fixed "x" image. In the Macintosh
PICT case, the PIC structure's lcb field represents the size of the entire
picture data block, including the PIC itself, the "x" metafile and the
Macintosh PICT data. (see the description of the PIC structure in the Structure
Definitions section of this document.)
<p>To distinguish between normal and Macintosh PICT graphics, a reader
needs to detect the presence of the special "x" metafile. The bytes below
are in an early portion of the "x" metafile.
<pre>U8 rgbWmfXBegin[] =
{
&nbsp;&nbsp; '\x14', '\x00', '\x00', '\x00', '\x26', '\x06', '\x0F', '\x00', '\x1E', '\x00',
&nbsp;&nbsp; '\xFF', '\xFF', '\xFF', '\xFF', '\x04', '\x00', '\x14', '\x00', '\x00', '\x00',
&nbsp;&nbsp; '\x57', '\x6F', '\x72', '\x64', '\x0E', '\x00', '\x4D', '\x69', '\x63', '\x72',
&nbsp;&nbsp; '\x6F', '\x73', '\x6F', '\x66', '\x74', '\x20', '\x57', '\x6F', '\x72', '\x64',
&nbsp;&nbsp; '\x0E', '\x00', '\x00', '\x00', '\x26', '\x06', '\x0F', '\x00', '\x12', '\x00',
&nbsp;&nbsp; '\x57', '\x6F', '\x72', '\x64', '\xFF', '\xFF', '\x08', '\x00', '\x00', '\x00'

&nbsp;&nbsp; /* "x" wmf and PICT data sizes immediately follow as 2 four-byte longs */
};

#define cbMETAHDR 18 // size of a standard Windows metafile header
#define cbWmfXBegin 60&nbsp; // length of this beginning section of the x metafile</pre>
After reading the PIC structure from the picture data block, the reader
should skip cbMETAHDR bytes (the size of a standard Windows metafile header).
It should then compare the next cbWmfXBegin bytes in the picture data block
against the bytes in the rgbWmfXBegin array above. If they do not match,
the picture is a normal picture -- Windows metafile, bitmap or TIFF.
<p>If they <i>do</i> match, then the reader should read the next 8 bytes
in the picture data block as two 4-byte "long"s (Intel 80x86 byte order).
These numbers are the sizes (in bytes) of the "x" metafile and the Macintosh
PICT data, respectively. The size of the "x" metafile is measured from
its start immediately after the PIC structure. It is possible for the PICT's
size to be zero. In this case, there is no PICT data, and the reader may
use the "x" Windows metafile as the picture's representation.
<br><a NAME="90"></a>
<h2>
Appendix B - Calculation of font (FTC) and language (LID)</h2>
Certain Unicode characters are shared between Far East and non-Far East
scripts requiring the calculation of font and language based on the Unicode
character code and the chp.idctHint property.
<p>Characters are classified into one of four groups, ASCII, Far East,
floating, and non-Far East. Properties are calculated as follows:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Character type</td>

<td>Font (ftc)</td>

<td>Language (lid)</td>
</tr>

<tr>
<td>ASCII</td>

<td>sprmCRgftc0</td>

<td>sprmCRglid0</td>
</tr>

<tr>
<td>non-Far East</td>

<td>sprmCRgftc2</td>

<td>sprmCRglid0</td>
</tr>

<tr>
<td>Far East</td>

<td>sprmCRgftc1</td>

<td>sprmCRglid1</td>
</tr>

<tr>
<td>shared character</td>

<td>sprmCRgftc2 if chp.idctHint is 0
<br>sprmCRgftc1 if chp.idctHint is 1</td>

<td>sprmCRglid0 if chp.idctHint is 0
<br>sprmCRglid1 if chp.idctHint is 1</td>
</tr>
</table>

<p>The table below defines the classification of various ranges of Unicode
characters:
<br>&nbsp;
<table BORDER=2 CELLSPACING=0 CELLPADDING=4 >
<tr>
<td>Unicode subrange</td>

<td>character range</td>

<td>Classification</td>
</tr>

<tr>
<td>usrBasicLatin</td>

<td>0x20 -> 0x7f</td>

<td>ASCII</td>
</tr>

<tr>
<td>usrLatin1</td>

<td>0xa0 -> 0xff</td>

<td>some shared (see notes below)</td>
</tr>

<tr>
<td>usrLatinXA</td>

<td>0x100 -> 0x17f</td>

<td>some shared (see notes below)</td>
</tr>

<tr>
<td>usrLatinXB</td>

<td>0x180 -> 0x24f</td>

<td>some shared (see notes below)</td>
</tr>

<tr>
<td>usrIPAExtensions</td>

<td>0x250 -> 0x2af</td>

<td>some shared (see notes below)</td>
</tr>

<tr>
<td>usrSpacingModLetters</td>

<td>0x2b0 -> 0x2ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrCombDiacritical</td>

<td>0x300 -> 0x36f</td>

<td>shared</td>
</tr>

<tr>
<td>usrBasicGreek</td>

<td>0x370 -> 0x3cf</td>

<td>shared</td>
</tr>

<tr>
<td>usrGreekSymbolsCop</td>

<td>0x3d0 -> 0x3ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrCyrillic</td>

<td>0x400 -> 0x4ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrArmenian</td>

<td>0x500 -> 0x58f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrBasicHebrew</td>

<td>0x5d0 -> 0x5ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrHebrewXA</td>

<td>0x590 -> 0x5cf</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrBasicArabic</td>

<td>0x600 -> 0x652</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrArabicX</td>

<td>0x653 -> 0x6ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrDevangari</td>

<td>0x900 -> 0x97f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrBengali</td>

<td>0x980 -> 0x9ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrGurmukhi</td>

<td>0xa00 -> 0xa7f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrGujarati</td>

<td>0xa80 -> 0xaff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrOriya</td>

<td>0xb00 -> 0xb7f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrTamil</td>

<td>0x0b80 -> 0x0bff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrTelugu</td>

<td>0x0c00 -> 0x0c7f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrKannada</td>

<td>0x0c80 -> 0x0cff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrMalayalam</td>

<td>0x0d00 -> 0x0d7f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrThai</td>

<td>0x0e00 -> 0x0e7f</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrLao</td>

<td>0x0e80 -> 0x0eff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrBasicGeorgian</td>

<td>0x10d0 -> 0x10ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrGeorgianExtended</td>

<td>0x10a0 -> 0x10cf</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrHangulJamo</td>

<td>0x1100 -> 0x11ff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrLatinExtendedAdd</td>

<td>0x1e00 -> 0x1eff</td>

<td>shared</td>
</tr>

<tr>
<td>usrGreekExtended</td>

<td>0x1f00 -> 0x1fff</td>

<td>non-Far East</td>
</tr>

<tr>
<td>usrGeneralPunct</td>

<td>0x2000 -> 0x206f</td>

<td>shared</td>
</tr>

<tr>
<td>usrSuperAndSubscript</td>

<td>0x2070 -> 0x209f</td>

<td>shared</td>
</tr>

<tr>
<td>usrCurrencySymbols</td>

<td>0x20a0 -> 0x20cf</td>

<td>shared</td>
</tr>

<tr>
<td>usrCombDiacriticsS</td>

<td>0x20d0 -> 0x20ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrLetterlikeSymbols</td>

<td>0x2100 -> 0x214f</td>

<td>shared</td>
</tr>

<tr>
<td>usrNumberForms</td>

<td>0x2150 -> 0x218f</td>

<td>shared</td>
</tr>

<tr>
<td>usrArrows</td>

<td>0x2190 -> 0x21ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrMathematicalOps</td>

<td>0x2200 -> 0x22ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrMiscTechnical</td>

<td>0x2300 -> 0x23ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrControlPictures</td>

<td>0x2400 -> 0x243f</td>

<td>shared</td>
</tr>

<tr>
<td>usrOpticalCharRecog</td>

<td>0x2440 -> 0x245f</td>

<td>shared</td>
</tr>

<tr>
<td>usrEnclosedAlphanum</td>

<td>0x2460 -> 0x24ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrBoxDrawing</td>

<td>0x2500 -> 0x257f</td>

<td>shared</td>
</tr>

<tr>
<td>usrBlockElements</td>

<td>0x2580 -> 0x259f</td>

<td>shared</td>
</tr>

<tr>
<td>usrGeometricShapes</td>

<td>0x25a0 -> 0x25ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrMiscDingbats</td>

<td>0x2600 -> 0x26ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrDingbats</td>

<td>0x2700 -> 0x27bf</td>

<td>shared</td>
</tr>

<tr>
<td>usrCJKSymAndPunct</td>

<td>0x3000 -> 0x303f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrHiragana</td>

<td>0x3040 -> 0x309f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrKatakana</td>

<td>0x30a0 -> 0x30ff</td>

<td>Far East</td>
</tr>

<tr>
<td>usrBopomofo</td>

<td>0x3100 -> 0x312f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrHangulCompatJamo</td>

<td>0x3130 -> 0x318f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrCJKMisc</td>

<td>0x3190 -> 0x319f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrEnclosedCJKLtMnth</td>

<td>0x3200 -> 0x32ff</td>

<td>Far East</td>
</tr>

<tr>
<td>usrCJKCompatibility</td>

<td>0x3300 -> 0x33ff</td>

<td>Far East</td>
</tr>

<tr>
<td>usrHangul</td>

<td>0xac00 -> 0xd7a3</td>

<td>Far East</td>
</tr>

<tr>
<td>usrReserved1</td>

<td></td>

<td></td>
</tr>

<tr>
<td>usrReserved2</td>

<td></td>

<td></td>
</tr>

<tr>
<td>usrCJKUnifiedIdeo</td>

<td>0x4e00 -> 0x9fff</td>

<td>Far East</td>
</tr>

<tr>
<td>usrPrivateUseArea</td>

<td>0xe000 -> 0xf8ff</td>

<td>shared</td>
</tr>

<tr>
<td>usrCJKCompatibilityIdeographs</td>

<td>0xf900 -> 0xfaff</td>

<td>Far East</td>
</tr>

<tr>
<td>usrAlphaPresentationForms</td>

<td>0xfb00 -> 0xfb4f</td>

<td>shared</td>
</tr>

<tr>
<td>usrArabicPresentationFormsA</td>

<td>0xfb50 -> 0xfdff</td>

<td>shared</td>
</tr>

<tr>
<td>usrCombiningHalfMarks</td>

<td>0xfe20 -> 0xfe2f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrCJKCompatForms</td>

<td>0xfe30 -> 0xfe4f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrSmallFormVariants</td>

<td>0xfe50 -> 0xfe6f</td>

<td>Far East</td>
</tr>

<tr>
<td>usrArabicPresentationFormsB</td>

<td>0xfe70 -> 0xfefe</td>

<td>shared</td>
</tr>

<tr>
<td>usrHFWidthForms</td>

<td>0xff00 -> 0xffef</td>

<td>Far East</td>
</tr>

<tr>
<td>usrSpecials</td>

<td>0xfff0 -> 0xfffd</td>

<td>non-Far East</td>
</tr>
</table>

<p>The table below describes the behavior of the unicode subrange usrLatin1.
Shared characters are marked in this table with a 1, while characters marked
with a 0 are considered "non-Far East". All other characters in this unicode
subrange are considered "non-Far East".
<pre>&nbsp;&nbsp; // 0&nbsp; 1&nbsp; 2&nbsp; 3&nbsp; 4&nbsp; 5&nbsp; 6&nbsp; 7&nbsp; 8&nbsp; 9&nbsp; a&nbsp; b&nbsp; c&nbsp; d&nbsp; e&nbsp; f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, // 0x00a0-0x00af
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, // 0x00b0-0x00bf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00c0-0x00cf
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00d0-0x00df
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00e0-0x00ef
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, // 0x00f0-0x00ff
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; };</pre>
The table below describes the behavior of the unicode range usrLatinXA.
Shared characters are marked in this table with a 1, while characters marked
with a 0 are considered "non-Far East". All other characters in this unicode
subrange are considered "non-Far East".
<pre>&nbsp;&nbsp; // 0&nbsp; 1&nbsp; 2&nbsp; 3&nbsp; 4&nbsp; 5&nbsp; 6&nbsp; 7&nbsp; 8&nbsp; 9&nbsp; a&nbsp; b&nbsp; c&nbsp; d&nbsp; e&nbsp; f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x0100-0x010f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, // 0x0110-0x011f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, // 0x0120-0x012f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x0130-0x013f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, // 0x0140-0x014f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0x0150-0x015f
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, // 0x0160-0x016f</pre>
In usrLatinXB shared characters are 0x192, 0x1FA, 0x1FB, 0x1FC, 0x1FD,
0x1FE and 0x1FF. All other characters in this unicode subrange are considered
"non-Far East".
<p>In usrIPAExtensions shared characters are 0x251, and 0x261.
<p>An optimization is available. If the Far East font chp.ftcFE is 0 and
chp.idctHint is 0 and chp.ftcAscii is equal to chp.ftcOther, the font is
chp.ftcAscii and the language is chp.lidDefault.
</body>
</html>
